
function attach(sm)
	sm:subscribe({signal = "on_spawn", fun = this.init})
	sm:subscribe({signal = "on_take",  fun = this.on_take}) --должен вызываться первым в on_take!
end


ammo = {} --Используется во многих скриптах
local repack = false


function init() --Инициализация переменных, выполняется единожды
	for k, _ in pairs(ammo_section) do --Список патронов возьмём из таблицы в _G
		ammo[k] = {
			["repack"] = false,
			["box"] = sys_ini:r_u32(k, "box_size")
		}
	end
	--log3("AMMO tbl afther init: %s", ammo)
end

--------
-- вызывается при добавлении в инвентарь ГГ любых патрон
-- здесь будем только ставить флажки о необходимости проверки,
-- саму проверку и перепаковку сделаем в апдейте актёра,
-- если перепаковку делать прям здесь, то будут сильные тормоза
-- при взятии из нычки кучи патрон (взять всё)
--------
function on_take(obj, s_obj)
	if device().precache_frame > 1 then return end --Во время загрузки ничего не делаем

	local section = s_obj:section_name()
	if ammo[section] then
		--log3("~~[%s.on_take] Size of [%s]: [%s], default in box: [%s]", script_name(), obj:name(), get_ammo_size(obj), ammo[section].box)
		if not ammo[section].repack then
			if get_ammo_size(obj) < ammo[section].box then
				ammo[section].repack = true
				repack = true
				run_repack_ammo_timer()
			end
		end
		return true --Вроде бы патроны более в on_take нигде не нужны, можно закончить цепочку вызовов.
	end
end


function on_update() --Поиск в инвентаре неполных пачек и их переупаковка
	if not repack then return end
	if level.get_inventory_wnd():IsShown() then return end

	local repack_tbl = {}
	db.actor:inventory_for_each(function(obj, npc)
		if npc:is_in_ruck(obj) then
			local sect = obj:section()
			local ammo_data = ammo[sect]
			if ammo_data and ammo_data.repack then
				local size = get_ammo_size(obj)
				if size < ammo_data.box then
					if not repack_tbl[sect] then
						repack_tbl[sect] = {["size"] = size, ["remove_ids"] = {obj:id()}}
					else
						repack_tbl[sect]["size"] = repack_tbl[sect]["size"] + size
						table.insert(repack_tbl[sect]["remove_ids"], obj:id())
					end
				end
			end
		end
	end)

	for k, v in pairs(repack_tbl) do
		if #v.remove_ids > 1 and v.size > 0 then
			for i = 1, #v.remove_ids do
				local id = v.remove_ids[i]
				local obj = level.object_by_id(id)
				if obj then
					db.actor:drop_item(obj) --НЕ ЗАКОММЕНТИРОВАТЬ НИ В КОЕМ СЛУЧАЕ!!!
					death_manager.shedule_release(obj)
				end
			end
			--log3("--[%s] Create ammo! Section: [%s], size: [%s]", script_name(), k, v.size)
			ogse.spawn_ammo_in_inv(k, v.size)
		end
	end

	for k, v in pairs(ammo) do
		if v.repack then ammo[k].repack = false end
	end
	repack = false
end


local repack_ammo_t
function run_repack_ammo_timer()
  if not repack_ammo_t then
    repack_ammo_t = check_repack_ammo_timer():start()
  end
end

class "check_repack_ammo_timer" ( ogse_qt.quick_timer )
function check_repack_ammo_timer:__init() super()
end
function check_repack_ammo_timer:condition()
  on_update()
  return not repack
end
function check_repack_ammo_timer:action()
  repack_ammo_t = nil
end


--------
-- возвращает колличество патрон в пачке
-- http://www.amk-team.ru/forum/index.php?showtopic=10538&p=713968
--------
function get_ammo_size(obj)
	ASSERT(obj, "[dunin_ammo.get_ammo_size] object is a nil reference!")
	ASSERT(obj:is_ammo(), "[dunin_ammo.get_ammo_size] object '%s' is not an ammo!", obj:name())

	return obj:get_go_int16( "", 476 )
end
