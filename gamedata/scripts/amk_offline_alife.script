-----------------------------------------------------------------------
--- amk_offline_alife.script                                       
--- Модуль оффлайновой жизни
--- Авторы: © AMK TEAM 2007-2008. Адаптация под OGSE - KamikaZze
--- version 1.0 (09/09/2011)                                             
-----------------------------------------------------------------------

-- Нужны списки тайников, которые НПС не будут обыскивать.
off_npcs={}
items={}
relation_matrix={}
tables_ready = false
local sell_table = {}
local always_keep_item = {}
last_debug_message = ""
local excluded_npcs = {
	["esc_bridge_soldier1"]	= true,
	["esc_bridge_soldier2"]	= true,
	["esc_bridge_soldier3"]	= true,
	["esc_bridge_soldier4"]	= true,
	["esc_bridge_soldier5"]	= true,
	["esc_bridge_soldier1_0000"]	= true,
	["zona_brother1"]	= true,
	["zona_brother2"]	= true,
	["freezer_bandos"]	= true,
	["stalker_tikar"]	= true,
	["major_wounded"]	= true,
	["bar_arena_kaligula"]	= true,
	["dik_the_drifter"]	= true,
	["bar_dr_gorbovsky"]	= true,
	["dar_officer"]	= true,
	["dolg_sergant"]	= true,
	["newbie_arthunter"]	= true,
	["bratstvo_agent_1"]	= true,
	["bridge_lekar"]	= true,
	["ds_hunter"]	= true,
	["bratstvo_cleaner"]	= true,
	["bratstvo_vrach"]	= true,
	["bratstvo_orujeinik"]	= true,
	["bratstvo_cleaner"]	= true,
	["hohol"]	= true,
	["second_neutral"]	= true,
	["bar_kulg_agent"]	= true,
	["yan_soldier"]	= true,
	["esc_wolf"]	= true,
	["stalker_hvost"]	= true,
	["stalker_kolya"]	= true,
	["deadcity_bar_nardyman"]	= true,
	["deadcity_bar_billiardman"]	= true,
	["deadcity_bar_restsofa"]	= true,
	["deadcity_bar_sleeper"]	= true,
	["deadcity_bar_zasranets"]	= true,
	["deadcity_bar_drinkman"]	= true,
	["deadcity_bar_barman"]	= true,
	["deadcity_bar_guard1"]	= true,
	["deadcity_bar_guard2"]	= true,
	["esc_lekar"]					=	true,
	["first_neutral"]				=	true,
	["esc_buharik"]					=	true,
	["esc_guns_remontnik"]			=	true,
}

local full_debug = false

local wpn_fp = {}
-- Пора апдейт делать
local bFlag = false
-- Номер последнего отработанного обьекта
local iCounter = 0
-- Время последнего глобального апдейта
local iTime = -1
-- Как часто делать апдейты, игровые минуты
local iFreq = 60 * 3
local initialized = false

local monster_params = {}

local maps={
	"l01_escape"
}

local protected = {
	5008,
	5013,
	5014,
	5041,
	5065,
	5084,
	5104,
	5205,
	5222,
	5226,
	5237,
	5238,
	5243,
	5244,
	5245,
	5246,
	5247,
	5248,
	5249,
	5250,
	5254,
	5255,
	5408,
	5413,
	5428,
	5433,
	5434,
	5444,
	5446,
	5470,
	5471,
	5472,
	5473,
	5474,
	573
}

local smart_filters = {
	"esc_bridge", "esc_blokpost"
}


local rel_enemy,rel_friend

--радиус "обзора"
local look_radius=100
--интенсивность поиска (количество отрабатываемых неписей)
--local search_intensivity=40
local search_intensivity=60
-- продолжительность боев
local max_rounds = 10
-- При каком уровне здоровья НПС считается раненым
local health_wound = 0.20
local health_wound_set = 0.02
-- Эталон firepower\distance при distance = 1 который снимет 100% health
local base_fp = 1400
-- Коэффициент для расстояния
local dist_coeff = 8
-- Вещи дешевле продает торговцам
local sell_limit = 3000
-- Рейтинг за убийство. При убийстве более слабого - 0.5 * rate_kill_base, более сильного - 2 * rate_kill_base
local rate_kill_base = 100
local rate_art_found = 100
local to_actor = 150
local look_radius_box = 100

local weapons_military = {
-- пистолеты
["wpn_pm"]					= true,
["wpn_fort"]				= true,
["wpn_pb"]					= true,
["wpn_tt"]					= true,
--ПП
["wpn_ppsh41"]				= true,
--Штурмовые
["wpn_aks74ub"]				= true,
["wpn_ak74n"]				= true,
["wpn_val"]					= true,
["wpn_ak102"]				= true,
["wpn_akm"]					= true,
["wpn_groza"]				= true,
["wpn_groza_m1"]			= true,
--Снайперки
["wpn_vintorez"]			= true,
["wpn_svu"]					= true,
["wpn_swd"]					= true,
["wpn_vintorez_m1"]			= true,
--Пулеметы
["wpn_rpk74_sk1"]			= true,
["wpn_pkm"]					= true,
--Тяжелое
["wpn_rpg7"]				= true,
--Огнемет
["wpn_flame"]				= true
}

local grenades_types = {
-- Гранаты
["grenade_light"]			= true,
["grenade_f1"]				= true,
["grenade_rgd5"]			= true,
["wpn_addon_grenade_launcher"] = true,
["wpn_addon_grenade_launcher_m203"] = true

}

local medkit_types = {
-- Аптечки
["medkit"]					= true,
["medkit_army"]				= true,
["medkit_scientic"]			= true
}

local food_types = {

["bread_a"]					= true,
["bread"]					= true,
["kolbasa"]					= true,
["kolbasa_a"]				= true,
["conserva"]				= true,
["kartoshka"]				= true,
["syrok"]					= true,
["conserva2"]				= true

}

local drink_types = {

["vodka_a"]				= true,
["vodka"]				= true,
["energy_drink"]		= true,
["kefir"]				= true,
["voda"]				= true,
["sigaret"]				= true

}

local detector_types = {

["interactive_detector_simple"]			= true,
["interactive_detector_advanced"]		= true,
["interactive_detector_elite"]			= true

}

local monster_parts_types = {

["mutant_flesh_eye"]			= true,
["mutant_boar_leg"]				= true,
["mutant_dog_tail"]				= true,
["mutant_psevdodog_tail"]		= true,
["mutant_krovosos_jaw"]			= true,
["mutant_burer_hand"]			= true,
["mutant_snork_leg"]			= true,
["mutant_zombie_hand"]			= true

}


local stalkers_comm = {

["actor"]			= true,
["actor_dolg"]		= true,
["actor_freedom"]	= true,
["stalker"]			= true,
["dolg"]			= true,
["freedom"]			= true,
["bandit"]			= true

}

function write_log(s)
	if full_debug then
		log1(s)
	end
end

function init() -- KZ. Запускается из ogse.on_game_load() ДО update_npc_tables()
	if (initialized == false) then
		if has_alife_info("gar_seryi_meet") then
			maps={ "l01_escape", "l02_garbage", "l05_bar" }		
		end
		if has_alife_info("agroprom_military_case_have") then
			maps={ "l01_escape", "l02_garbage", "l03_agroprom", "l05_bar" }
		end
		if has_alife_info("val_actor_has_borov_key") then
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "l05_bar" }
		end
		if has_alife_info("esc_darklab_documents_read") then
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "k01_darkscape_ogse", "l22_marsh", "l05_bar" }
		end
		if has_alife_info("bar_rescue_research_done") or has_alife_info("bar_rescue_research_fail") or has_alife_info("bar_heli_scene_professor_die") then
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "k01_darkscape_ogse", "l22_marsh", "l05_bar", "l06_rostok" }
		end
		if has_alife_info("yantar_attack_start") then
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "k01_darkscape_ogse", "l22_marsh", "l05_bar", "l06_rostok", "l08_yantar" }
		end
		if has_alife_info("mil_freedom_quests_end") then
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "k01_darkscape_ogse", "l22_marsh", "l05_bar", "l06_rostok", "l08_yantar", "l07_military" }
		end
		if has_alife_info("rad_antennas_reached") then
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "k01_darkscape_ogse", "l09_deadcity_ogse", "l22_marsh", "l05_bar", "l06_rostok", "l08_yantar", "l07_military", "l10_radar" }
		end
		if has_alife_info("pri_followers_start") then
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "k01_darkscape_ogse", "l09_deadcity_ogse", "l22_marsh", "l05_bar", "l06_rostok", "l08_yantar", "l07_military", "l10_radar", "l11_pripyat" }
		end
		if has_alife_info("pri_what_the_fuck") then -- Фриплей - везде гуляем.
			maps={ "l01_escape", "l02_garbage", "l03_agroprom",	"l04_darkvalley", "l05_bar", "l06_rostok", "l07_military",
				"l08_yantar", "l10_radar", "l11_pripyat", "l12_stancia", "l12_stancia_2", "k01_darkscape_ogse", "l09_deadcity_ogse", "l22_marsh" }
		end
		build_tables()
		iTime = (game_minutes() - iFreq) + 3
		initialized = true
	end
end

function update() -- KZ. Запускается из ogse.on_actor_upade(delta) по ватчдогу
	if (bFlag == false and iTime ~= -1) then
		if (game_minutes() - iTime > iFreq) then
			bFlag = true			
			off_npcs={}	
			items={}
			iCounter = 1
			if full_debug then
				write_log("~~OFFLINE_ALIFE> Updating offline-ALife started")
			end
		end
	end
	if (bFlag == true) then
		if (iCounter >= 65535) then
			bFlag = false
			iTime = game_minutes()
			iCounter = 1
			if full_debug then
				write_log("~~OFFLINE_ALIFE> Updating offline-ALife finished")
			end
		else
			local obj
			obj = alife():object(iCounter)
			add_fresh_meat(obj)
			iCounter = iCounter + 1
		end
	end
end

--on_death - не убиваем!
--on_hit - не обрабатываем!
function add_fresh_meat(obj)
	if obj and obj.m_game_vertex_id and db.actor and db.actor:id() ~= obj.id and not always_keep_item[obj:section_name()] then
		if game_graph():valid_vertex_id(obj.m_game_vertex_id) then
			local map=alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())
			if not off_npcs[map] then off_npcs[map]={monsters={},stalkers={},weapons={},artefacts={},inv_boxes={}} end
			if IsMonster(obj) and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id~=nil and obj.m_story_id==4294967296 then
				local flags = get_flags(obj.id)
				if flags == 0 or flags == 2 then --Уберем тех, у кого on_hit есть.
					table.insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
				end
			elseif IsStalker(obj) and obj.alive and obj:alive() and obj.health and obj:health()>0 and not ogse.is_quest_npc(obj) and not xr_companion.is_companion(obj.id) and not excluded_npcs[obj:name()] then
				local flags = get_flags(obj.id)
				if flags == 0 or flags == 2 then --Уберем тех, у кого on_hit есть.
					if obj:community()~="zombied" then
						table.insert(off_npcs[map].stalkers, {id = obj.id, name = obj:name()})
					else
						table.insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
					end
				end
			elseif isWeapon(obj) then
				if obj.m_story_id~=nil and obj.m_story_id==4294967296 then
					if (obj.parent_id ~= nil) then
						local p_obj = alife():object(obj.parent_id)
						if (p_obj) then
							if p_obj.m_game_vertex_id and game_graph():valid_vertex_id(p_obj.m_game_vertex_id) then
								--if p_obj:section_name()=="inventory_box" and box_is_protected(p_obj)==true then
								if p_obj:section_name()=="inventory_box" then
									-- НПС "не видят" этого
									map = ""
								else
									local p_map = alife():level_name(game_graph():vertex(p_obj.m_game_vertex_id):level_id())
									if (p_map ~= map) then
										if not off_npcs[p_map] then off_npcs[p_map]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}} end
										map = p_map
									end	
								end
							end
						end
					end
					if map ~= "" then table.insert(off_npcs[map].weapons, {id=obj.id, name = obj:name()}) end
				end
			elseif string.find(obj:section_name(),"^af_") then
				if (obj.parent_id ~= nil) then
					local p_obj = alife():object(obj.parent_id)
					if (p_obj) then
						if p_obj.m_game_vertex_id and game_graph():valid_vertex_id(p_obj.m_game_vertex_id) then
							--if p_obj:section_name()=="inventory_box" and box_is_protected(p_obj)==true then
							if p_obj:section_name()=="inventory_box" then
								-- НПС "не видят" этого
								map = ""
							else
								local p_map = alife():level_name(game_graph():vertex(p_obj.m_game_vertex_id):level_id())
								if (p_map ~= map) then
									if not off_npcs[p_map] then off_npcs[p_map]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}} end
									map = p_map
								end	
							end
						end
					end
				end
				if map ~= "" then table.insert(off_npcs[map].artefacts, {id = obj.id, name = obj:name()}) end
			elseif (obj:section_name()=="inventory_box" and box_is_protected(obj)==false) then
				table.insert(off_npcs[map].inv_boxes, {id = obj.id, name = obj:name()})
			end
			
			if (obj.parent_id ~= nil and obj.m_story_id~=nil and obj.m_story_id==4294967296 and IsMonster(obj)==false and IsStalker(obj)==false) then
				local zz = alife():object(obj.parent_id)
				if zz then
					if IsStalker(zz) and zz.m_story_id~=nil and zz.m_story_id==4294967296 then
						if not items[obj.parent_id] then items[obj.parent_id] = {} end
						table.insert(items[obj.parent_id], {id = obj.id, name=obj:name()})
					else
						if not items[obj.parent_id] then items[obj.parent_id] = {} end
						table.insert(items[obj.parent_id], {id = obj.id, name=obj:name()})
					end
				end
			end
		end
	end
end

--строим таблицу неписей, монстров и оружия
function build_tables()
	-- Почистим таблицу
--	off_npcs={}	
--	local obj
--	for a=1,65534 do
--		obj = alife():object(a)
--		add_fresh_meat(obj)
--	end

	rel_enemy,rel_friend = utils.cfg_get_number(sys_ini, "game_relations", "goodwill_enemy", nil, false, -1000), utils.cfg_get_number(sys_ini, "game_relations", "goodwill_friend", nil, false, 1000)
	local s_comm_list = utils.cfg_get_string(sys_ini, "game_relations", "communities", nil, false, "", "")
	local comm_list = {}
	local s_value = str_explode(",", string.trim(s_comm_list), true)
	for a=1, table.getn(s_value), 2 do
		local s_comm = s_value[a]
		table.insert(comm_list, s_comm)
	end
  
	local tmp={}
	local result, id, value = nil, nil, nil
	for a=0,sys_ini:line_count("communities_relations")-1 do
		result, id, value = sys_ini:r_line("communities_relations",a,"","")
		if id~=nil and string.trim(id)~="" and string.trim(id)~=nil then
			relation_matrix[string.trim(id)]={}
			table.insert(tmp, string.trim(id))
		end
	end
	
	for a=1,table.getn(tmp) do
		local value = utils.cfg_get_string(sys_ini, "communities_relations", tmp[a], nil, false, "", "")
		local idx = tmp[a]
		local m_value = str_explode(",", string.trim(value), true)
		for i=1, table.getn(m_value) do
			local idx2 = comm_list[i]
			local v = m_value[i]
			if relation_matrix[idx] and idx2~=nil and v ~= nil then
				relation_matrix[idx][idx2]=tonumber(string.trim(v))
			end
		end
	end
	
	sell_table = {}
	local sini = dsh.cached_ini_file("misc\\trade_generic.ltx")
	local cfg_sell = utils.cfg_get_string(sini, "trader", "sell_condition", npc, false, false, "")
	if sini and sini:section_exist(cfg_sell) then
		local result, id, value = nil, nil, nil
		for a=0,sini:line_count(cfg_sell)-1 do
			result, id, value = sini:r_line(cfg_sell,a,"","")
			if id~=nil and string.trim(id)~="" and string.trim(id)~=nil and string.trim(value)~="" and string.trim(value)~=nil then
				-- Добавим в таблицу, что можно продавать.
				sell_table[id] = true
			end
		end
	end

 	--' Предметы, которые нельзя продавать (квестовые например)
	always_keep_item = {}
    local n = sys_ini:line_count("death_gen_keep_items")
	for i=0,n-1 do
		result, id, value	= sys_ini:r_line("death_gen_keep_items",i,"","")
        if value == "true" then
            always_keep_item[id] = true
        end
    end
	
	tables_ready = true
end

function update_npc_tables() -- KZ. Запускается из ogse.on_game_load()

	off_npcs={}	
	local obj
	for a=1,65534 do
		obj = alife():object(a)
		if obj then
			add_fresh_meat(obj)
		end
	end
	bFlag = false
	iTime = game_minutes()
	iCounter = 1
end

function update_trade() -- KZ. Запускается из ogse.on_game_load() после update_npc_tables()
	for a=1,65534 do
		obj = alife():object(a)
		if obj then
			process_trade(obj)
		end
	end
end

function update_tables(level)
	off_npcs[level]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}}
	local obj
	for a=1,65534 do
		obj = alife():object(a)
		if (obj and alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())==level) then
			add_fresh_meat(obj)
		elseif (obj and obj.parent_id ~= nil) then
			local p_obj = alife():object(obj.parent_id)
			if (p_obj) then
				local p_map = alife():level_name(game_graph():vertex(p_obj.m_game_vertex_id):level_id())
				if (p_map == level) then
					add_fresh_meat(obj)
				end
			end
		end
	end	
end

--генерируем оффлайн события - ПОЧИСТИТЬ, заменить last_debug_message на наш дебуг
function offline_alife()  -- запускается из модуля новостей news_amk_core.on_news 
	
	local lname = maps[math.random(table.getn(maps))]
--	update_tables(lname)
	write_log("~~OFFLINE_ALIFE> Offline_alife - "..lname)
	local st = 0
	last_debug_message="cn offline_alife chp1"
	if off_npcs[lname] then st = table.getn(off_npcs[lname].stalkers) end
	if st>0 then
	last_debug_message="cn offline_alife chp2"
		for search = 1,search_intensivity do
	last_debug_message="cn offline_alife chp3"
			local rnd = math.random(st)
	last_debug_message="cn offline_alife chp4"
			if off_npcs[lname].stalkers[rnd] then 
	last_debug_message="cn offline_alife chp5"
				local victim = alife():object(off_npcs[lname].stalkers[rnd].id)
	last_debug_message="cn offline_alife chp6"
				if victim and not victim.online and victim.health and victim.can_switch_online and victim:health()>0 and victim:can_switch_online() and victim:name() == off_npcs[lname].stalkers[rnd].name then
	last_debug_message="cn offline_alife chp7 "..tostring(victim and victim:name())
					local vdata = collect_info(victim,lname)
	last_debug_message="cn offline_alife chp8 "..tostring(victim and victim:name())
					if table.getn(vdata.enemies)>0 then
					--есть вражина - воюем нах!
	last_debug_message="cn offline_alife chp9 "..tostring(victim and victim:name())
						on_enemies_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.monsters)>0 then
					--есть монстрятина - видели, слышали, убили, сдохли...
	last_debug_message="cn offline_alife chp10 "..tostring(victim and victim:name())
						on_monsters_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.corpses.stalkers)>0 then
					--есть труп сталкера
	last_debug_message="cn offline_alife chp11 "..tostring(victim and victim:name())
						on_npc_corpses_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.corpses.monsters)>0 then
					--есть труп монстра
	last_debug_message="cn offline_alife chp12 "..tostring(victim and victim:name())
						on_monster_corpses_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.weapons.seen)>0 then
					--есть бесхозное оружие
	last_debug_message="cn offline_alife chp13 "..tostring(victim and victim:name())
						on_weapons_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.artefacts)>0 then
					--есть арты
	last_debug_message="cn offline_alife chp14 "..tostring(victim and victim:name())
						on_artifacts_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif table.getn(vdata.inv_boxes)>0 then
					--есть контейнеры. Надо обыскать.
	last_debug_message="cn offline_alife chp18 "..tostring(victim and victim:name())
						on_inv_boxes_found(victim, vdata)
						break	--прерываем цикл - событие отработано
					elseif items[victim.id] and table.getn(items[victim.id]) > 0 then
					--попробуем продать всякого
	last_debug_message="cn offline_alife chp15 "..tostring(victim and victim:name())
						write_log("~~OFFLINE_ALIFE> Offline: lets trade")
	last_debug_message="cn offline_alife chp17 "..tostring(victim and victim:name())
						process_trade(victim)
						write_log("~~OFFLINE_ALIFE> Offline: trade done")
						break
					else
						--write_log("~~OFFLINE_ALIFE> __")
					end
				end
			end
		end
	end
	last_debug_message="cn offline_alife end"
end

--собираем инфу о неписе
function collect_info(victim,map)
	local vdata = {}
	last_debug_message="cn offline_alife collect_info 1"
	vdata.rank = victim:rank() --ранг
	vdata.health = victim:health()  --хелсы
	vdata.community = victim:community()  --группировка
	last_debug_message="cn offline_alife collect_info 2"
	
	--пытаемся определить пушку
	local wp = table.getn(off_npcs[map].weapons)
	--условная огневая мощь
	vdata.fire_power = 0
	last_debug_message="cn offline_alife collect_info 3"
	
	vdata.weapons={own={},seen={}}
	-- если есть пушки в карманах, выбираем лучшую (по условной мощности)
	last_debug_message="cn offline_alife collect_info 4"
	if wp>0 then
		for w=1,wp do
		last_debug_message="cn offline_alife collect_info 5"
			if off_npcs[map].weapons[w] then
				last_debug_message="cn offline_alife collect_info 6"
				local www = alife():object(off_npcs[map].weapons[w].id)
				if www and www:name()==off_npcs[map].weapons[w].name then
					last_debug_message="cn offline_alife collect_info 7"
					if www.parent_id == victim.id then
						last_debug_message="cn offline_alife collect_info 8"
						table.insert(vdata.weapons.own, {id = www.id, name = www:name()})
						last_debug_message="cn offline_alife collect_info 9"
						local fp = get_weapon_firepower(www)
						last_debug_message="cn offline_alife collect_info 10"
						if vdata.fire_power<fp then vdata.fire_power=fp end
						last_debug_message="cn offline_alife collect_info 11"
					elseif www:can_switch_online() and victim.position:distance_to(www.position)<look_radius and sobj_is_far(www, to_actor) then
						last_debug_message="cn offline_alife collect_info 8A"
						if www.parent_id == nil or www.parent_id == 65535 then
							last_debug_message="cn offline_alife collect_info 9A"
							table.insert(vdata.weapons.seen, {id = www.id, name = www:name()})
						end
					end
				end
			end
		end
	end
	last_debug_message="cn offline_alife collect_info 12"
	--составляем списки друзей и врагов в зоне "видимости"
	-- Для тех, у кого смарт в фильтрах - не собираем врагов
	-- Для остальных - не учитываем врагов из смартов
	local npc_peaceful = npc_smart_is_peaceful(victim)
	
	last_debug_message="cn offline_alife collect_info 13"
	
	vdata.friends={}
	vdata.enemies={}
	vdata.corpses={monsters={},stalkers={}}
	
	last_debug_message="cn offline_alife collect_info 14"
	if table.getn(off_npcs[map].stalkers)>0 then
		for a=1,table.getn(off_npcs[map].stalkers) do
			last_debug_message="cn offline_alife collect_info 15"
			if off_npcs[map].stalkers[a] then
				last_debug_message="cn offline_alife collect_info 16"
				local opponent = alife():object(off_npcs[map].stalkers[a].id)
				last_debug_message="cn offline_alife collect_info 17"
				if opponent 
				and opponent.id~=victim.id 
				and opponent.health 
				and opponent.can_switch_online 
				and opponent:can_switch_online() 
				and opponent:name() == off_npcs[map].stalkers[a].name  then
					last_debug_message="cn offline_alife collect_info 18"
					if victim.position:distance_to(opponent.position)<look_radius then
						last_debug_message="cn offline_alife collect_info 19"
						if opponent:health()>0 then
							last_debug_message="cn offline_alife collect_info 20"
							local rel = relation_check(victim,opponent)
							if rel>=rel_friend then
								table.insert(vdata.friends, {id = opponent.id, name = opponent:name()})
							elseif rel<=rel_enemy then
								if npc_peaceful == false and npc_smart_is_peaceful(opponent) == false then
									table.insert(vdata.enemies, {id = opponent.id, name = opponent:name()})
								end
							end
						else
							last_debug_message="cn offline_alife collect_info 19A"
							if (sobj_is_far(opponent, to_actor)) then
								last_debug_message="cn offline_alife collect_info 20A"
								table.insert(vdata.corpses.stalkers, {id = opponent.id, name = opponent:name()})
							end
						end
					end
				end
			end
		end
	end
	
	last_debug_message="cn offline_alife collect_info 21"
	
	--составляем список монстряков в зоне "видимости"
	vdata.monsters={}
	if off_npcs[map].monsters then
		if table.getn(off_npcs[map].monsters)>0 then
			for a=1,table.getn(off_npcs[map].monsters) do
				if off_npcs[map].monsters[a] then
					last_debug_message="cn offline_alife collect_info 22"
					local monster = alife():object(off_npcs[map].monsters[a].id)
					last_debug_message="cn offline_alife collect_info 23"
					if monster 
					and monster.health 
					and monster.can_switch_online 
					and monster:can_switch_online() 
					and monster:name() == off_npcs[map].monsters[a].name 
					and victim.position:distance_to(monster.position)<look_radius then
						last_debug_message="cn offline_alife collect_info 24"
						if monster:health()>0 then
							last_debug_message="cn offline_alife collect_info 25"
							table.insert(vdata.monsters, {id = monster.id, name = monster:name()})
						else
							last_debug_message="cn offline_alife collect_info 25A"
							if (sobj_is_far(monster, to_actor)) then
								table.insert(vdata.corpses.monsters, {id = monster.id, name = monster:name()})
							end
						end
					end
				end
			end
		end
	end
	
	last_debug_message="cn offline_alife collect_info 26"
	
	--составляем список артов в зоне "видимости"
	vdata.artefacts={}
	--поиск артефактов выключен - вносит дисбаланс + вешает алайф
	
	-- if off_npcs[map].artefacts then
		-- last_debug_message="cn offline_alife collect_info 27"
		-- if table.getn(off_npcs[map].artefacts)>0 then
			-- last_debug_message="cn offline_alife collect_info 28"
			-- for a=1,table.getn(off_npcs[map].artefacts) do
				-- last_debug_message="cn offline_alife collect_info 29"
				-- if off_npcs[map].artefacts[a] then
					-- last_debug_message="cn offline_alife collect_info 30"
					-- local artefact = alife():object(off_npcs[map].artefacts[a].id)
					-- last_debug_message="cn offline_alife collect_info 31"
					-- if artefact 
					-- and artefact.can_switch_online 
					-- and artefact:can_switch_online() 
					-- and artefact:name() == off_npcs[map].artefacts[a].name 
					-- and victim.position:distance_to(artefact.position)<look_radius 
					-- and sobj_is_far(artefact, to_actor) then
						-- last_debug_message="cn offline_alife collect_info 32"
						-- if artefact.parent_id==nil or artefact.parent_id == 65535 then
							-- last_debug_message="cn offline_alife collect_info 33"
							-- table.insert(vdata.artefacts, {id = artefact.id, name = artefact:name()})
						-- end
					-- end
				-- end
			-- end
		-- end
	-- end
	
	last_debug_message="cn offline_alife collect_info 34"
	
	--составляем список контейнеров в зоне "видимости"
	vdata.inv_boxes={}
	
	last_debug_message="cn offline_alife collect_info 35"

	return vdata
end

-- получаем отношение группировки к неписю, в оффлайне фактически равно личным отношениям неписей
function relation_check(victim,opponent)
	if relation_matrix[opponent:community()] and relation_matrix[opponent:community()][victim:community()] then
		return relation_matrix[opponent:community()][victim:community()]
	else
		return 0
	end
end

-- Вокруг враги! Что же делать.. -- переделать вызовы news_main
function on_enemies_found(victim, vdata) 
	if (victim == nil or vdata == nil) then return end
	if (full_debug == true) then
		local lname = get_object_levelname(victim)
		local s = "found enemy ("..table.getn(vdata.enemies)..") for "..victim.id.." ["..victim:community().."] on map "..lname
		write_log("~~OFFLINE_ALIFE> "..s)
	end
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	-- Собираем weapons
	-- Учитываем rank, weapon, distance...
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
	table.insert(team_A, player)
	if (vdata.friends and table.getn(vdata.friends) > 0) then
		for i=1, table.getn(vdata.friends) do
			v_obj = vdata.friends[i]
			if v_obj then
				obj = alife():object(v_obj.id)
				if (obj and obj:name()==v_obj.name) then
					wpn = get_npc_weapon(obj)
					rank = obj:rank()
					health = obj:health()
					firepower = get_weapon_firepower(wpn)
					player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
					table.insert(team_A, player)
				end
			end
		end
	end
	for i=1, table.getn(vdata.enemies) do
		v_obj = vdata.enemies[i]
		obj = alife():object(v_obj.id)
		if (obj and obj:name() == v_obj.name) then
			wpn = get_npc_weapon(obj)
			if (wpn == nil) then
				list_npc_items(obj)
			end
			rank = obj:rank()
			health = obj:health()
			firepower = get_weapon_firepower(wpn)
			player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
			table.insert(team_B, player)
		end
	end
	local distances = {}
	for a=1, table.getn(team_A) do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, table.getn(team_B) do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math.floor(from.position:distance_to(to.position))
				local fp_A = math.floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math.floor(team_B[b].firepower / (dist / dist_coeff))
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
	-- Берем тех, у кого самый высокий rank и мин. distance
	table.sort(team_A, function(a,b) return a.rank > b.rank end)
	table.sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = table.getn(team_A)
	local size_B = table.getn(team_B)
	local died_A = 0
	local died_B = 0
	for i=1, max_rounds do
		if (table.getn(team_A) >0 and table.getn(team_B) > 0) then
			local index = table.getn(team_A)
			local attacker
			local defender 
			local attack_info 
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance			
			if (table.getn(team_B) > index) then index = table.getn(team_B) end
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math.random(table.getn(team_B))]
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_A] нападает на "..defender.player:name().." [team_B] ("..defender.health..")")
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					-- master to novice - 30% max
					-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
					rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
					distance_hit_chance = 100 - math.floor((attack_info.distance) / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math.random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
						if (attack_info.fp >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp)
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if (defender.flags >= 2) then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if (IsStalker(attacker.player) and attacker.player.community) then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math.floor(rate_kill_base * coeff))
									end
								end
								write_log("~~OFFLINE_ALIFE> on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
								news_amk_core.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and table.getn(items[defender.player.id]) > 0) then
									write_log("~~OFFLINE_ALIFE> В трупе "..defender.player:name().." "..table.getn(items[defender.player.id]).." вещичек.")
									for a=1,table.getn(items[defender.player.id]) do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = alife():object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
													write_log("~~OFFLINE_ALIFE> В трупе "..defender.player:name().." странная вещичка - "..itA:name().." parent_id="..mm)
												end
											end	
										end
									end
								end
								process_trade(attacker.player)
							end
						end
						write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_A] попал в "..defender.player:name().." [team_B] ("..defender.health..")")
					else
						write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_A] промазал в "..defender.player:name().." [team_B] ("..defender.health..")")
					end
				end
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math.random(table.getn(team_A))]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_B] нападает на "..defender.player:name().." [team_A] ("..defender.health..")")
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Попал или нет? Зависит от: расстояния, рангов
						-- master to novice - 30% max
						-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
						rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
						distance_hit_chance = 100 - math.floor((attack_info.distance) / 1.5)					
						hit_chance = distance_hit_chance + rank_hit_chance
						if math.random() * 100 < hit_chance then
							-- Попал таки, гад. Посмотрим, как сильно.
							if attack_info.fp >= base_fp then
								-- Все, убил.
								defender.health = 0
							else
								defender.health = defender.health - (attack_info.fp / base_fp)
								if (defender.health < 0 ) then defender.health = 0 end
							end
							if (defender.health <= 0) then
								if (defender.flags >= 2) then
									defender.health = health_wound
								else								
									-- Если сталкер - дадим опыт.
									if (IsStalker(attacker.player) and attacker.player.community) then
										local m_comm  = attacker.player:community()
										if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
											-- Будет теперь опытным.
											local coeff = 1
											if (defender.rank < attacker.rank) then coeff = 0.5 end
											if (defender.rank > attacker.rank) then coeff = 2 end
											attacker.player:set_rank(attacker.player:rank() + math.floor(rate_kill_base * coeff))							
										end
									end
									write_log("~~OFFLINE_ALIFE> on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
									news_amk_core.on_offline_death(defender.player, attacker.player, attacker.weapon)
									-- Заберем вещички с трупа
									local itB, v_itB
									local l_objB
									if (items[defender.player.id] and table.getn(items[defender.player.id]) > 0) then
										write_log("~~OFFLINE_ALIFE> В трупе "..defender.player:name().." "..table.getn(items[defender.player.id]).." вещичек.")
										for a=1,table.getn(items[defender.player.id]) do
											v_itB = items[defender.player.id][a]
											if (v_itB) then
												itB = alife():object(v_itB.id)
												if (itB and itB:name() == v_itB.name and itB.parent_id == defender.player.id) then
													l_objB = pick_item(attacker.player, itB)
												else
													if(itB) then
														local mm = itB.parent_id
														if mm == nil then mm = "nil" end
														write_log("~~OFFLINE_ALIFE> В трупе "..defender.player:name().." странная вещичка - "..itB:name().." parent_id="..mm)													
													end
												end
											end
										end
									end
									process_trade(attacker.player)
								end
							end
							write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_B] попал в "..defender.player:name().." [team_A] ("..defender.health..")")
						else
							write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_B] промазал в "..defender.player:name().." [team_A] ("..defender.health..")")
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
		-- Почистим таблицы от трупов
		for kk, vv in pairs(team_A) do
			if (vv.health <=0) then
				write_log("~~OFFLINE_ALIFE> Участник команды А погиб. "..vv.player:name())			
				set_npc_health(vv.player, 0)
				table.remove(team_A, kk)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				write_log("~~OFFLINE_ALIFE> Участник команды А ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_amk_core.on_offline_wound(vv.player)
				table.remove(team_A, kk)
			end
		end
		for kk, vv in pairs(team_B) do
			if (vv.health <=0) then
				write_log("~~OFFLINE_ALIFE> Участник команды B погиб. "..vv.player:name())
				set_npc_health(vv.player, 0)
				table.remove(team_B, kk)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				write_log("~~OFFLINE_ALIFE> Участник команды B ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_amk_core.on_offline_wound(vv.player)
				table.remove(team_B, kk)
			end
		end		
	end
	write_log("~~OFFLINE_ALIFE> Бой закончен. Команда А - было "..size_A.." осталось "..size_A-died_A..". Команда Б - было "..size_B.." осталось "..size_B-died_B..".")
end

-- Вокруг монстры! Что же делать.. -- переделать вызовы news_main, заменить last_debug_message на наш дебуг
function on_monsters_found(victim, vdata)
  last_debug_message="on_monsters_found begin"
	if (victim == nil or vdata == nil) then return end
	if (full_debug == true) then
		local lname = get_object_levelname(victim)
		local s = "found monsters ("..table.getn(vdata.monsters)..") for "..victim.id.." ["..victim:community().."] on map "..lname
		write_log("~~OFFLINE_ALIFE> "..s)
	end
	-- Собираем комманды.
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
	table.insert(team_A, player)
  last_debug_message="on_monsters_found chp1"
	if (vdata.friends and table.getn(vdata.friends) > 0) then
		for i=1, table.getn(vdata.friends) do
			v_obj = vdata.friends[i]
			obj = alife():object(v_obj.id)
			if (obj and obj:name()==v_obj.name) then
				wpn = get_npc_weapon(obj)
				rank = obj:rank()
				health = obj:health()
				firepower = get_weapon_firepower(wpn)
				player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
				table.insert(team_A, player)
			end
		end
	end
  last_debug_message="on_monsters_found chp2"
	local params
	for i=1, table.getn(vdata.monsters) do
  last_debug_message="on_monsters_found chp2.1"
		v_obj = vdata.monsters[i]
		obj = alife():object(v_obj.id)
  last_debug_message="on_monsters_found chp2.2"
		if (obj and obj:name() == v_obj.name) then
  last_debug_message="on_monsters_found chp2.3"
			params = get_monster_params(obj)
  last_debug_message="on_monsters_found chp2.4"
			if (params) then
  last_debug_message="on_monsters_found chp2.5"
				rank = obj:rank()
  last_debug_message="on_monsters_found chp2.6"
				health = obj:health()
  last_debug_message="on_monsters_found chp2.7"
				firepower = params.attack * base_fp
  last_debug_message="on_monsters_found chp2.8"
				player = {player = obj, speed = params.speed, attack_dist = params.dist, immunity = params.immunity, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id) }
  last_debug_message="on_monsters_found chp2.9"
				table.insert(team_B, player)
  last_debug_message="on_monsters_found chp2.10"
			else
  last_debug_message="on_monsters_found chp2.11"
				write_log("~~OFFLINE_ALIFE> get_monster_params returns nil for "..obj:name())
  last_debug_message="on_monsters_found chp2.12"
		end
	end
	end
  last_debug_message="on_monsters_found chp3"
	local distances = {}
	for a=1, table.getn(team_A) do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, table.getn(team_B) do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math.floor(from.position:distance_to(to.position))
				local fp_A = math.floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math.floor(team_B[b].firepower)
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
  last_debug_message="on_monsters_found chp4"
	-- Берем тех, у кого самый высокий rank и мин. distance
	table.sort(team_A, function(a,b) return a.rank > b.rank end)
	table.sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = table.getn(team_A)
	local size_B = table.getn(team_B)
	local died_A = 0
	local died_B = 0
  last_debug_message="on_monsters_found chp5"
	for i=1, max_rounds do
		if (table.getn(team_A) >0 and table.getn(team_B) > 0) then
			local index = table.getn(team_A)
			local attacker
			local defender
			local attack_info
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance
			if (table.getn(team_B) > index) then index = table.getn(team_B) end
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math.random(table.getn(team_B))]
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_A] нападает на "..defender.player:name().." [team_B] ("..defender.health..")")
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
					local dii = math.floor(attack_info.distance - defender.speed * i * 5)
					if (dii <=8) then dii = 45 end -- Вблизи еще и фиг попадешь...
					distance_hit_chance = 100 - math.floor(dii / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math.random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
						if ( math.floor(attack_info.fp * defender.immunity) >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp) * defender.immunity
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if defender.flags >= 2 then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if (IsStalker(attacker.player) and attacker.player.community) then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math.floor(rate_kill_base * coeff))
									end
								end
								write_log("~~OFFLINE_ALIFE> on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
								news_amk_core.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and table.getn(items[defender.player.id]) > 0) then
									write_log("~~OFFLINE_ALIFE> В трупе "..defender.player:name().." "..table.getn(items[defender.player.id]).." вещичек.")
									for a=1,table.getn(items[defender.player.id]) do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = alife():object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
													write_log("~~OFFLINE_ALIFE> В трупе "..defender.player:name().." странная вещичка - "..itA:name().." parent_id="..mm)
												end											
											end			
										end
									end
								end
								process_trade(attacker.player)
							end
						end
						write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_A] попал в "..defender.player:name().." [team_B] ("..defender.health..")")
					else
						write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_A] промазал в "..defender.player:name().." [team_B] ("..defender.health..")")
					end
				end
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math.random(table.getn(team_A))]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_B] нападает на "..defender.player:name().." [team_A] ("..defender.health..")")
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Для начала неплохо бы узнать, добежал ли монстрик до дистанции атаки.
						if (attack_info.distance - attacker.speed * i * 5 < attacker.attack_dist) then
							rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
							distance_hit_chance = 100
							hit_chance = distance_hit_chance + rank_hit_chance
							if math.random() * 100 < hit_chance then
								-- Попал таки, гад. Посмотрим, как сильно.
								if attack_info.fp >= base_fp then
									-- Все, убил.
									defender.health = 0
								else
									defender.health = defender.health - (attack_info.fp / base_fp)
									if (defender.health < 0 ) then defender.health = 0 end
								end
								if (defender.health == 0) then
									if defender.flags >= 2 then
										defender.health = health_wound
									else
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										write_log("~~OFFLINE_ALIFE> on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", nil")
										news_amk_core.on_offline_death(defender.player, attacker.player, nil)
										-- Забитрать вещички с трупа не будем. Хотя, может некоторые клептоманы...
										-- А вот труп грохнуть... Надо подумать :)
									end
								end
								--write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_B] попал в "..defender.player:name().." [team_A] ("..defender.health..")")
							else
								--write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_B] промазал в "..defender.player:name().." [team_A] ("..defender.health..")")
							end
						else
							write_log("~~OFFLINE_ALIFE> "..attacker.player:name().." [team_B] еще не добежал "..(attack_info.distance - attacker.speed * i * 5).." метров до "..defender.player:name().." [team_A] ("..defender.health..")")
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
		-- Почистим таблицы от трупов
		for kk, vv in pairs(team_A) do
			if (vv.health <=0) then
				write_log("~~OFFLINE_ALIFE> Участник команды А погиб. "..vv.player:name())			
				set_npc_health(vv.player, 0)
				table.remove(team_A, kk)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				write_log("~~OFFLINE_ALIFE> Участник команды А ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_amk_core.on_offline_wound(vv.player)
				table.remove(team_A, kk)
			end
		end
		for kk, vv in pairs(team_B) do
			if (vv.health <=0) then
				write_log("~~OFFLINE_ALIFE> Участник команды B погиб. "..vv.player:name())
				set_npc_health(vv.player, 0)
				table.remove(team_B, kk)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				write_log("~~OFFLINE_ALIFE> Участник команды B ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_amk_core.on_offline_wound(vv.player)
				table.remove(team_B, kk)
			end
		end		
	end	
  last_debug_message="on_monsters_found end"
	write_log("~~OFFLINE_ALIFE> Бой с монстрами закончен. Команда А - было "..size_A.." осталось "..size_A-died_A..". Команда Б - было "..size_B.." осталось "..size_B-died_B..".")
end

-- О, трупик. Щас шмонать будем. -- переделать вызовы news_main
function on_npc_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.stalkers == nil) then return end
	if (full_debug == true) then
		local lname = get_object_levelname(victim)
		local s = "found stalker's corpse ("..table.getn(vdata.corpses.stalkers)..") for "..victim.id.." ["..victim:community().."] on map "..lname
		write_log("~~OFFLINE_ALIFE> "..s)
	end
	local obj, v_obj
	local id
	local v_id = victim.id
	for i=1, table.getn(vdata.corpses.stalkers) do
		v_obj = vdata.corpses.stalkers[i]
		local corpse = alife():object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_amk_core.on_offline_corpse_found(victim, corpse)
			id = corpse.id
			if (id and items[id]) then
				for a=1, table.getn(items[id]) do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = alife():object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end			
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- О, трупик монстра. Будем шмонать?
function on_monster_corpses_found(victim, vdata) -- переделать вызовы news_main
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.monsters == nil) then return end
	if (full_debug == true) then
		local lname = get_object_levelname(victim)
		local s = "found monster's corpse ("..table.getn(vdata.corpses.monsters)..") for "..victim.id.." ["..victim:community().."] on map "..lname
		write_log("~~OFFLINE_ALIFE> "..s)
	end
	local obj, v_obj
	local object
	local id
	local v_id = victim.id
	for i=1, table.getn(vdata.corpses.monsters) do
		v_obj = vdata.corpses.monsters[i]
		local corpse = alife():object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_amk_core.on_offline_corpse_found(victim, corpse)		
			id = corpse.id
			if (id and items[id]) then
				for a=1, table.getn(items[id]) do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = alife():object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end			
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- Хорошая пушка - не помешает.
function on_weapons_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (full_debug == true) then
		local lname = get_object_levelname(victim)
		local s = "found weapons ("..table.getn(vdata.weapons.seen)..") for "..victim.id.." on map "..lname
		write_log("~~OFFLINE_ALIFE> "..s)
	end
	local obj, v_obj
	local object
	local v_id = victim.id
	for i=1, table.getn(vdata.weapons.seen) do
		v_obj = vdata.weapons.seen[i]
		if (v_obj) then
			object = alife():object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
			end
		end
	end
	process_trade(victim)
end

-- Моя прелесссть
function on_artifacts_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if (IsStalker(victim) and victim.community) then
		local m_comm  = victim:community()
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
			b_stalker = true
		end
	end
	for i=1, table.getn(vdata.artefacts) do
		v_obj = vdata.artefacts[i]
		if (v_obj) then
			object = alife():object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
				if (obj) then
					if (b_stalker == true) then
						victim:set_rank(victim:rank() + rate_art_found)
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- О, нычка - это гуд.
function on_inv_boxes_found(victim, vdata)
-- не ищем ящики
end

function pick_item(npc, obj)
	local new = nil
	if (npc and obj and db.actor and obj.id ~= db.actor:id()) then
		local section = obj:section_name()
		new = alife():create(section, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id)
		if (new) then
			if (new.parent_id) then
				if not items[new.parent_id] then items[new.parent_id] = {} end
				table.insert(items[new.parent_id], {id = new.id, name = new:name()})
			end
			if (obj.parent_id and items[obj.parent_id] and table.getn(items[obj.parent_id])>0) then
				for z=1, table.getn(items[obj.parent_id]) do
					if (items[obj.parent_id][z] and items[obj.parent_id][z].id == obj.id) then
						table.remove(items[obj.parent_id], z)
						break
					end
				end
			end
			alife():release(alife():object(obj.id), true)
		end
	end
	return new
end

function get_npc_weapon(npc)
	local obj = nil
	local fp = 0
	if (npc) then
		for k,v in pairs(items[npc.id]) do
			local wpn = alife():object(v.id)
			if wpn and isWeapon(wpn) and wpn:name() == v.name and wpn.parent_id == npc.id then
				local cur_fp = get_weapon_firepower(wpn)
				if cur_fp > fp then
					fp = cur_fp
					obj = wpn
				end			
			end
		end
	end
	return obj
--[[
		local map = get_object_levelname(npc)
		if (map and off_npcs[map]) then
			local wp = table.getn(off_npcs[map].weapons)
			if wp>0 then
				for w=1,wp do
					if off_npcs[map].weapons[w] then
						local www = alife():object(off_npcs[map].weapons[w].id)
						if www and www.parent_id == npc.id and isWeapon(www) then
							local cur_fp = get_weapon_firepower(www)
							if cur_fp > fp then
								fp = cur_fp
								obj = www
							end
						end
					end
				end
			end
		end
	end
	return obj
]]	
end

function get_weapon_firepower(wpn)
	local result = 0
	if (wpn and isWeapon(wpn)) then
		local sect = wpn:section_name()
		if not grenades_types[sect] then
			--local fd = utils.cfg_get_number(sys_ini, wpn:section_name(), "fire_distance", wpn, false, 1)
			--local bs = utils.cfg_get_number(sys_ini, wpn:section_name(), "bullet_speed", wpn, false, 1)
			--local rpm = utils.cfg_get_number(sys_ini, wpn:section_name(), "rpm", wpn, false, 1)
			local priority = utils.cfg_get_number(sys_ini, wpn:section_name(), "ef_weapon_type", wpn, false, 1)
			local priority2 = utils.cfg_get_number(sys_ini, wpn:section_name(), "ef_main_weapon_type", wpn, false, 0)
			local GetRPM = ui_wpn_params.GetRPM(wpn:section_name())
			local GetDamage = ui_wpn_params.GetDamage(wpn:section_name())
			local GetHandling = ui_wpn_params.GetHandling(wpn:section_name())
			local GetAccuracy = ui_wpn_params.GetAccuracy(wpn:section_name())
			local fp = 1
			if priority>1 and priority2>0 then
				priority = priority + priority2
			end
			--fp = priority*1000 + math.sqrt(fd*bs*rpm)		
			fp = math.ceil(priority * 1000 + GetAccuracy * 100 + GetRPM * 3 + GetDamage * 8) - 5000
			if GetHandling >= 99 then
				fp = fp + 1500
			end
			result = fp
			if wpn_fp[wpn:section_name()] == nil then
				wpn_fp[wpn:section_name()] = {frp = fp, p = priority, rpm = GetRPM, dam = GetDamage, acc = GetAccuracy, han = GetHandling}
			end
		end
	end
	return result
end

function get_weapon_cost(weapon)
	local result = 0
	if (weapon and isWeapon(weapon)) then
		result = utils.cfg_get_number(sys_ini, weapon:section_name(), "cost", weapon, false, 0)
	end
	return result
end

function get_item_cost(item)
	local result = 0
	if (item and item.section_name) then
		result = utils.cfg_get_number(sys_ini, item:section_name(), "cost", item, false, 0)
	end
	return result
end

function set_npc_health(obj, health)
	if (obj and health >=0 and health <=2) then
	
		write_log("SET_HEALTH "..obj:name().." "..health)
		
		local pk = xs_netpk.monster(obj)
		if not pk:isOk() then
			pk = xs_netpk.stalker(obj)
		end
		
		local data = pk:get()
		data.health = health
		data.updhealth = health
		pk:set(data)

		write_log("SET_HEALTH_SET")	
		
		if health == 0 then
			obj.offline_dead = 1
			on_death(obj.id)
			obj:on_death(obj)
		end
	else	
		write_log("!!TRY_SET_1_FAIL "..tostring(obj:name()).." HEA "..tostring(health))
	end
end

function list_npc_items(obj)
	if (obj) then
		write_log("~~OFFLINE_ALIFE> list_npc_items - "..obj:name()..":")
		local it
		local find = 0
		for a=1,65534 do
			it = alife():object(a)
			if (it and it.parent_id == obj.id) then
				write_log("~~OFFLINE_ALIFE> list_npc_items - "..it:name().." "..it:section_name())
				if isWeapon(it) then
					find = it.id
				end
			end			
		end
	end
end

function dbg_show_team(team)
	if(team) then
		for k, player in pairs(team) do
			if (player.weapon) then
				write_log("~~OFFLINE_ALIFE> Team: "..player.player:name().." health="..player.health.." rank="..player.rank.." community="..player.player:community().." weapon="..player.weapon:name().." firepower="..player.firepower)
			else
				write_log("~~OFFLINE_ALIFE> Team: "..player.player:name().." health="..player.health.." rank="..player.rank.." community="..player.player:community().." weapon=none firepower="..player.firepower)
			end
		end
	end
end

--[[
	Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.	
	Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
	Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class
	Оставили одно, которое лучше (а), но патронов нет (б) (%)
	Одно, которое лучше (а), но хуже (б) - в новости на продажу
	Остальное на продажу
	Патроны оставили только те, что подходят к (а), остальные на продажу
	Для вояк - только родной калаш надо бы... Не продавать вобще?
	Оставляем не более 2 аптечек и бинтов, антирада
	Оставляем 1-2 гранаты (%)
	Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
	Еда, водка - не более 1-2 шт (%)	
	Броники наверное продаем...
	Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
]]

function process_trade(npc)	
	local item_list = {}
	local sell_list = {}
	-- Имеет смысл проверять на наличие trade в секции [logic]...
	if npc and IsStalker(npc) and npc:alive() and not ogse.is_quest_npc(npc) and not xr_companion.is_companion(npc.id) and not excluded_npcs[npc:name()] and items[npc.id] and table.getn(items[npc.id])>0 then
		local m_comm = npc:community()
		local b_stalker = false
		if m_comm[stalkers_comm] then
			if (npc.name and npc:name() ~= "agr_ratcatcher") then
				b_stalker = true
			end
		elseif m_comm == "zombied" then
			return
		end
			
		--Фильтруем квестовые items - always_keep_item, sell_table	
		local obj, v_obj
		for ok,ov in pairs(items[npc.id]) do
			obj = alife():object(ov.id)
			if obj and obj:name()==ov.name then
				if always_keep_item[obj:section_name()] or sell_table[obj:section_name()] == nil then
					-- Это нам не надо.
					--news_amk_core.trace("Process_trade: "..npc:name().." ["..m_comm.."] filtered "..obj:section_name().." ["..obj:name().."]")
				else
					table.insert(item_list, obj)
					--item_list[v.id] = obj
					--news_amk_core.trace("Process_trade: "..npc:name().." ["..m_comm.."] have "..obj:section_name().." ["..obj:name().."]")
				end
			end
		end
		if item_list and table.getn(item_list)>0 then
			--news_amk_core.trace("Process_trade: "..npc:name().." ["..m_comm.."] have "..tostring(table.getn(item_list)).." items.")
			table.sort(item_list, function(a,b) return get_item_cost(a) > get_item_cost(b) end)		
			-- Выберем, что за оружие оставит себе NPC.
			local cnt_medkit = 0
			local cnt_antirad = 0
			local cnt_bandage = 0
			local cnt_grenade = 0
			local cnt_food = 0
			local cnt_drink = 0
			local cnt_torch = 0
			local cnt_pda = 0
			local cnt_radio = 0
			local cnt_guitar = 0
			local cnt_harmonica = 0
			local cnt_binocular = 0
			local cnt_knife = 0
			local cnt_arts = 0
			local cnt_detector = 0
			local cnt_addons = 0
			local cnt_mparts = 0
			
			local weapons = {}
			local ammo = {}
			for k,v in pairs(item_list) do			
				local sect = v:section_name()
				--news_amk_core.trace("Process_trade: first pass - "..npc:name().." ["..m_comm.."] have "..sect.." ["..v:name().."]")
				if isWeapon(v) and not grenades_types[sect] and not sect == "wpn_knife" then
					local bOk = false
					if m_comm == "military" then
						if weapons_military[sect] then
							bOk = true
						else
							for k,v in pairs(weapons_military) do
								if string.find(sect, k) then
									bOk = true
									break
								end
							end
						end
					else
						bOk = true
					end
					if bOk == true then
						local ac = utils.cfg_get_string(sys_ini, sect, "ammo_class", v, false, "")
						if ac and ac ~= "" then
							local vvv = str_explode(",", ac, true)
							local ammo_classes = {}
							for ak,av in pairs(vvv) do
								table.insert(ammo_classes, av)
							end
							table.insert(weapons, {obj = v, ammo = ammo_classes})
						else
							table.insert(weapons, {obj = v, ammo = nil})
						end
					end
				elseif string.find(sect, "^ammo_") then
					if ammo[sect] == nil then 
						ammo[sect] = 1
					else
						ammo[sect] = ammo[sect] + 1
						if ammo[sect] > 2 then
							table.insert(sell_list, v)
						end
					end
				elseif string.find(sect, "^af_") then
					-- 3 самых хороших арта оставили себе (+здоровье), остальные на продажу (фильтруем булыжник)				
					if sect ~= "af_buliz" then
						cnt_arts = cnt_arts + 1
						if cnt_arts > 3 then
							table.insert(sell_list, v)
						end				
					end
				elseif sect == "device_torch" then
					cnt_torch = cnt_torch + 1
					if cnt_torch > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "device_pda" then
					cnt_pda = cnt_pda + 1
					if cnt_pda > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "hand_radio" then
					cnt_radio = cnt_radio + 1
					if cnt_radio > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "harmonica_a" then
					cnt_harmonica = cnt_harmonica + 1
					if cnt_harmonica > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "guitar_a" then
					cnt_guitar = cnt_guitar + 1
					if cnt_guitar > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "binocular_a" or string.find(sect, "wpn_binoc") then
					cnt_binocular = cnt_binocular + 1
					if cnt_binocular > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "wpn_knife" then
					cnt_knife = cnt_knife + 1
					if cnt_knife > 1 then
						table.insert(sell_list, v)
					end
				elseif medkit_types[sect] then
					cnt_medkit = cnt_medkit + 1
					if cnt_medkit > 4 then
						table.insert(sell_list, v)
					end
				elseif sect == "antirad" then
					cnt_antirad = cnt_antirad + 1
					if cnt_antirad > 3 then
						table.insert(sell_list, v)
					end
				elseif sect == "bandage" then
					cnt_bandage = cnt_bandage + 1
					if cnt_bandage > 3 then
						table.insert(sell_list, v)
					end
				elseif grenades_types[sect] then
					cnt_grenade = cnt_grenade + 1
					if cnt_grenade > 2 then
						table.insert(sell_list, v)
					end
				elseif food_types[sect] then
					cnt_food = cnt_food + 1
					if cnt_food > 4 then
						table.insert(sell_list, v)
					end
				elseif drink_types[sect] then
					cnt_drink = cnt_drink + 1
					if cnt_drink > 3 then
						table.insert(sell_list, v)
					end
				elseif detector_types[sect] then
					cnt_detector = cnt_detector + 1
					if cnt_detector > 1 then
						table.insert(sell_list, v)
					end
				elseif monster_parts_types[sect] then
					cnt_mparts = cnt_mparts + 1
					if cnt_mparts > 2 then
						table.insert(sell_list, v)
					end
				else
					-- news_amk_core.trace("Process trade - unknown - "..sect.." "..v:name())
				end			
			end
			table.sort(weapons, function(a,b) return get_weapon_firepower(a.obj) > get_weapon_firepower(b.obj) end)
			-- Так, теперь у нас отсортированны все пушки НПС. Найдем ту, для которой есть патроны...
			local b_self = false
			local b_best = false
			local s_self = ""
			for k, v in pairs(weapons) do
				--news_amk_core.trace("Process_trade: second pass - "..npc:name().." ["..m_comm.."] weapons "..v.obj:section_name().." ["..v.obj:name().."] "..get_weapon_firepower(v.obj))
				local b_ammo = false
				local vac = v.ammo
				if vac and table.getn(vac)>0 then
					for kk, vv in pairs(vac) do
						if ammo[vv] and ammo[vv] > 0 then -- Так, патроны есть.
							b_ammo = true
							break
						end
					end
				end
				if b_self == false and b_ammo == true then
					b_self = true
					--news_amk_core.trace("Process_trade: second pass - "..npc:name().." ["..m_comm.."] SELF weapon is  "..v.obj:section_name().." ["..v.obj:name().."]")
					s_self = v.obj:section_name()
				elseif b_best == false then
					if s_self ~= "" then
						if v.obj:section_name() ~= s_self then
							b_best = true
							--news_amk_core.trace("Process_trade: second pass - "..npc:name().." ["..m_comm.."] BEST weapon is  "..v.obj:section_name().." ["..v.obj:name().."]")
						else
							table.insert(sell_list, v.obj)
						end
					else
						b_best = true
						--news_amk_core.trace("Process_trade: second pass - "..npc:name().." ["..m_comm.."] BEST weapon is  "..v.obj:section_name().." ["..v.obj:name().."]")
					end
				else
					table.insert(sell_list, v.obj)
				end
			end
			-- Так, с оружием закончили...
			-- Все, что осталось - надо продать.
			-- 1 самое дорогое можно попробовать через новости...
			item_list = nil
			local money = 0
			if sell_list and table.getn(sell_list)>0 then
				table.sort(sell_list, function(a,b) return get_item_cost(a) > get_item_cost(b) end)		
				local zz = sell_list[1]
				if zz and b_stalker == true and (get_item_cost(zz) >= sell_limit) then
					-- Продадим через новости.
					--news_amk_core.trace("Offline: "..npc:name().." собирается продать через новости "..zz:name())
					--write_log("~~OFFLINE_ALIFE> Offline: "..npc:name().." собирается продать через новости "..vv:name())
					news_amk_core.on_offline_trade(npc, zz)
					table.remove(sell_list, 1)
				end
			end
			for kk,vv in pairs(sell_list) do
				--news_amk_core.trace("Process_trade: final pass - "..npc:name().." ["..m_comm.."] sells "..vv:section_name().." ["..vv:name().."]")
				local cost = get_item_cost(vv)
				if (cost > 0) then
					s_name = utils.cfg_get_string(sys_ini, vv:section_name(), "inv_name", vv, false, "", "")
					if (s_name == nil) then s_name = "" end
					s_name = game.translate_string(s_name)
					local coeff = math.random(30,50) / 100
					local price = math.floor(cost * coeff)
					money = money + price
					--news_amk_core.trace("Offline: "..npc:name().." продает "..s_name.." ["..vv:name().."] торговцу за "..price)
					--write_log("~~OFFLINE_ALIFE> Offline: "..npc:name().." продает "..s_name.." ["..vv:name().."] торговцу за "..price)
					-- Почистим items
					if (items[npc.id] and table.getn(items[npc.id])>0) then
						for z=1, table.getn(items[npc.id]) do
							if (items[npc.id][z] and items[npc.id][z].id == vv.id) then
								table.remove(items[npc.id], z)
								break
							end
						end
					end
					alife():release(alife():object(vv.id), true)
				end				
			end
			if (money > 0) then
				local pk = xs_netpk.stalker(npc)
				if pk and pk:isOk() then
					local data = pk:get()
					data.money = data.money + money
					pk:set(data)
				end
				--write_log("~~OFFLINE_ALIFE> Offline: "..npc:name().." было денег - "..old_money..", стало - "..old_money + money)
				--news_amk_core.trace("Offline: "..npc:name().." было денег - "..old_money..", стало - "..old_money + money)
			end
		end
		--news_amk_core.flushlog()
	end
end

-- Строим таблицы, если надо.
-- В них - макс. скорость, сила атаки, дистанция атаки.
-- Не забываем про иммунитеты.
-- Поучаем immunities_sect
-- В immunities_sect читаем fire_wound_immunity. Все повреждения множим на него.
function get_monster_params(obj) -- заменить last_debug_message на наш дебуг
  last_debug_message="get_monster_params chp1"
	if (obj and IsMonster(obj)) or (obj and obj.community and obj:community()=="zombied") then
  last_debug_message="get_monster_params chp2"
		if (monster_params and monster_params[obj:section_name()]) then
  last_debug_message="get_monster_params chp3"
			return monster_params[obj:section_name()]
		else
  last_debug_message="get_monster_params chp4"
			local speed 	= utils.cfg_get_number(sys_ini, obj:section_name(), "MaxSpeed", obj, false, 5)
  last_debug_message="get_monster_params chp5"
			local dist 		= utils.cfg_get_number(sys_ini, obj:section_name(), "MaxAttackDist", obj, false, 3)
  last_debug_message="get_monster_params chp6"
			local imm_sect 	= utils.cfg_get_string(sys_ini, obj:section_name(), "immunities_sect", obj, false, "", "")
  last_debug_message="get_monster_params chp7"
			local immunity 	= utils.cfg_get_number(sys_ini, imm_sect, "fire_wound_immunity", obj, false, 1)
  last_debug_message="get_monster_params chp8"
			local att_sect 	= utils.cfg_get_string(sys_ini, obj:section_name(), "attack_params", obj, false, "", "") 
  last_debug_message="get_monster_params chp9"
			local attack	= 0
  last_debug_message="get_monster_params chp10 "..tostring(att_sect)
			if (sys_ini:section_exist(att_sect)) then
  last_debug_message="get_monster_params chp11"
				local result, id, value = nil, nil, nil
				local max_attack = 0
  last_debug_message="get_monster_params chp12"
				for a=0, sys_ini:line_count(att_sect)-1 do
  last_debug_message="get_monster_params chp13"
					result, id, value = sys_ini:r_line(att_sect,a,"","")
  last_debug_message="get_monster_params chp14"
					if id~=nil and string.trim(id)~="" and string.trim(id)~=nil and value~=nil then
  last_debug_message="get_monster_params chp15"
						local m_value = str_explode(",", string.trim(value), true)
  last_debug_message="get_monster_params chp16"
						if (m_value and table.getn(m_value)>2) then
  last_debug_message="get_monster_params chp17"
							local v = tonumber(m_value[2])
  last_debug_message="get_monster_params chp18"
							if (v and v > max_attack) then					
  last_debug_message="get_monster_params chp19"
								max_attack = v
							end
						end
					end
				end
  last_debug_message="get_monster_params chp20"
				attack = max_attack
			end
      write_log("~~OFFLINE_ALIFE> speed for "..obj:section_name().." is "..tostring(speed))
			monster_params[obj:section_name()] = {speed = speed, dist = dist, immunity = immunity, attack = attack}
			return monster_params[obj:section_name()]			
		end
	else
		return nil
	end
end

function sobj_is_far(obj, distance)
	if db.actor and obj and distance then
		local dist = obj.position:distance_to(db.actor:position())
		if dist < distance then
			return false
		else	
			return true
		end
   end
   return true
end

function game_minutes()
	local gtime = level.get_time_days()*60*24+level.get_time_hours()*60+level.get_time_minutes()  --time in game minutes
	return gtime
end

function have_ammo(npc, weapon)
	local result = false
	if npc and weapon and IsStalker(npc) and isWeapon(weapon) then
		local ammo_str = utils.cfg_get_number(sys_ini, weapon:section_name(), "ammo_class", weapon, false, "")
		if ammo_str=="" then -- Болт или граната
			return false
		end
		local ammo_list = parse_names(ammo_str)
		for k, v in items[npc.id] do
			if string.find(obj:section_name(),"^ammo_") then
			end
			--if v:section_name() == 
		end
	end
	return result
end

function box_is_protected(v)
	return true -- ящики НЕ грабить
end

function npc_smart_is_peaceful(sobj)
	local result = false
	if (sobj and smart_filters and table.getn(smart_filters)>0) then
		if (sobj.smart_terrain_id and sobj:smart_terrain_id() and sobj:smart_terrain_id()~=65535) then
			local sm = alife():object(sobj:smart_terrain_id())
			if (sm and sm.name and sm:name()) then
				local sn = sm:name()
				for ks, vs in pairs(smart_filters) do
					if (vs == sn) then
						-- Ага, он у нас мирный.
						result = true
						break
					end
				end
			end
		end
	end
	return result
end

function on_death(npc_id)
	smart_terrain.on_death( npc_id )
end

function get_flags(npc_id)
	local flags = 0
	local obj = alife():object(npc_id)
	if obj then
		if IsMonster(obj) or IsStalker(obj) then
			local char_ini = xr_logic.get_customdata_or_ini_file(obj, "<customdata>")
			if char_ini:section_exist("logic") then
				local from = ""
				local items = ""
				if char_ini:line_exist("logic", "on_hit") then
					flags = 1
				end
				if char_ini:line_exist("logic", "on_death") then
					flags = flags + 2
				end
			end
		end
	end
	return flags
end

function is_valuable(item)
	local result = false
	if item and not (IsMonster(item) or IsStalker(item)) then
		-- Уники не подбираем (пока?)
		if always_keep_item[item:section_name()] or sell_table[item:section_name()] == nil then
			return false
		end
		local cost = get_item_cost(item)
		if isWeapon(item) and cost >= 1000 then
			result = true
		elseif cost >= 800 then
			result = true
		end
	end
	return result
end

function str_explode(div,str,clear)
	local t={}
	local cpt = string.find (str, div, 1, true)
	if cpt then
		repeat
			if clear then
				table.insert( t, string.trim(string.sub(str, 1, cpt-1)) )
			else
				table.insert( t, string.sub(str, 1, cpt-1) )
			end
			str = string.sub( str, cpt+string.len(div) )
			cpt = string.find (str, div, 1, true)
		until cpt==nil
	end
	if clear then
		table.insert(t, string.trim(str))
	else
		table.insert(t, str)
	end
	return t
end

function isGameObject(obj)
	local bResult = false
	if (obj and obj.fov) then
		bResult = true
	end
	return bResult
end

function get_object_levelname(obj)
	local mlevel = "null"	
	if (obj) then
		local m_game_vertex
		local nm = "nil"
		if (obj.name) then nm = obj:name() end
		if (isGameObject(obj)) then
			m_game_vertex = obj:game_vertex_id()
		else
			m_game_vertex = obj.m_game_vertex_id
		end
		if (m_game_vertex and game_graph():valid_vertex_id(m_game_vertex)) then
			local lvert = game_graph():vertex(m_game_vertex)
			if (lvert ~= nil and lvert.level_id) then
				local lid = lvert:level_id()
				if (lid ~= nil) then
					mlevel = alife():level_name(lid)
				else
					write_log("!!get_object_levelname - level id is null "..nm)
				end
			else
				write_log("!!get_object_levelname - vertex is null "..nm)
			end
			if mlevel == nil then mlevel = "nil" end
		else
			write_log("!!get_object_levelname - vertex_id is null "..nm)
		end
	else
		write_log("!!get_object_levelname - no obj")
	end
	return mlevel
end
