-----------------------------------------------------------------------
--- ogse_anomaly_evader.script
--- Модуль обхода аномалий
--- KamikaZze, OGS Evolution Team 2011
--- version 1.3 (20/08/2012)
-----------------------------------------------------------------------
--- Настройки схемы
-----------------------------------------------------------------------
local monsters_too = false --Включить монстрам обход аномалий?
local freq = 1000 --Как часто выполнять апдейт обхода аномалий (в мс)

local added_restrictions = {}
last_position = {}


local excluded_npc = { --Запретные профили/имена/story_id
	["bar_ecolog_professor"] = true,
	["dik_the_drifter"] = true,
	["zona_brother1"] = true,
	["zona_brother2"] = true,
	["val_escort_captive"] = true,
	["val_escort_nap1"] = true,
	["bandit_trader"] =	true,
	["bandit_trader_spawn"]	= true,		
}
local excluded_sect = { --Запретные аномалии
	["burning_fuzz"] = true,
	["zone_rad"] = true,
}
local excluded_comms = { --Запретные коммунити
	["zombied"] = true,
	["trader"] = true,
	["gunsmith"] = true,
	["guider"] = true,
}
local excluded_locations = { --Запретные локации
	--["l03u_agr_underground"] = true,
}


function attach( sm )
	sm:subscribe({ signal = "on_npc_death",			fun = this.on_death })
	sm:subscribe({ signal = "on_npc_net_destroy",	fun = this.cleanup })
	sm:subscribe({ signal = "on_npc_spawn",			fun = this.on_npc_spawn })
	if monsters_too then
		sm:subscribe({ signal = "on_monster_death",			fun = this.on_death })
		sm:subscribe({ signal = "on_monster_net_destroy",	fun = this.cleanup })
		sm:subscribe({ signal = "on_monster_spawn",			fun = this.on_monster_spawn })
	end
end

function can_evade(npc)
  if
    excluded_locations[ level.name() ]
    or not npc:alive()
    or (
      IsStalker( npc )
      and (
        excluded_comms[ npc:character_community() ]
        or excluded_npc[ npc:profile_name() ]
        or excluded_npc[ npc:name() ]
        or excluded_npc[ npc:story_id() ]
      )
    )
  then
  	return false
  end
  return true
end

function on_monster_spawn( obj, binder )
  added_restrictions[ obj:id() ] = {}

  if not can_evade(obj) then return end
  local s = {
    [ "signal" ] = "on_monster_update." .. obj:id(),
    [ "fun"    ] = this.update_norm,
    [ "queued" ] = true,
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end

function on_npc_spawn( obj, binder )
  added_restrictions[ obj:id() ] = {}

  if not can_evade(obj) then return end
  local s = {
    [ "signal" ] = "on_npc_update." .. obj:id(),
    [ "fun"    ] = this.update_norm,
    [ "queued" ] = true,
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end

function on_death( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ script_name() .. ".subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
	binder[ script_name() .. ".subscribed" ] = nil
  end
  cleanup( obj )
end

function cleanup( obj )
	local nid   = obj:id()
	local anoms = added_restrictions[nid]
	if anoms and next(anoms) then
		local restrs = {}
		for k, v in pairs(anoms) do
			local sobj = alife():object(k)
			if sobj then
				table.insert(restrs, sobj:name())
			end
		end
		if table.getn(restrs) > 0 then
			--log3("[ANOMALY EVADER] REMOVING IN RESTRICTIONS FOR [%s]: %s", obj:name(), restrs)
			local s = table.concat( restrs, "," )
			ASSERT( s:len() < 4096, "too long: %s", s:len() )
			obj:remove_restrictions( "", s )
		end
	end
	added_restrictions[nid] = nil
	last_position[nid]      = nil
end

function update_norm(npc)
  ogse_signals.get_mgr():reschedule( freq )

  local curr_pos = npc:position()
  local prev_pos = last_position[ npc:id() ]
  if prev_pos then
    if prev_pos:distance_to( curr_pos ) < 15 then --ранее было 20
      return
    else
      last_position[ npc:id() ] = curr_pos
    end
  else
    last_position[ npc:id() ] = curr_pos
  end

  local restr = {}
  for a, b in pairs(ogse_anomaly.get_all_nearest_anomalies_by_point_in_radius( npc:position(), 30 )) do
    local obj = level.object_by_id( a )
    if obj then
      local ignore = false
      for k, v in pairs( excluded_sect ) do
        if string.find( b.sect, k ) then
          ignore = true
          break
        end
      end
      if not ignore then
        restr[ obj:name() ] = true
      end
    end
  end

  local del = {}
  for k, _ in pairs( added_restrictions[ npc:id() ] ) do
    if restr[ k ] then
      restr[ k ] = nil -- уже установлен
    else
      table.insert( del, k ) -- удалить старый
    end
  end
  if table.getn( del ) > 0 then
    for _, k in ipairs( del ) do
      added_restrictions[ npc:id() ][ k ] = nil
    end
    --log3("[ANOMALY EVADER] REMOVING IN RESTRICTIONS FOR [%s]: %s", npc:name(), del)
    local s = table.concat( del, "," )
    ASSERT( s:len() < 4096, "too long: %s", s:len() )
    npc:remove_restrictions( "", s )
  end

  local add = {}
  for k, _ in pairs( restr ) do
    table.insert( add, k ) -- добавить новый
    added_restrictions[ npc:id() ][ k ] = true
  end
  if table.getn( add ) > 0 then
    --log3("[ANOMALY EVADER] ADDING IN RESTRICTIONS FOR [%s]: %s", npc:name(), add)
    local s = table.concat( add, "," )
    ASSERT( s:len() < 4096, "too long: %s", s:len() )
    npc:add_restrictions( "", s )
   end
end
