-----------------------------------------------------------------------
--- ogse_anomaly_evader.script
--- Модуль обхода аномалий
--- KamikaZze, OGS Evolution Team 2011
--- version 1.3 (20/08/2012)
-----------------------------------------------------------------------
--- Настройки схемы
-----------------------------------------------------------------------
local monsters_too = false --Включить монстрам обход аномалий?
freq = 1000 --Как часто выполнять апдейт обхода аномалий (в мс)
local detect_radius = 30

local added_restrictions = {}
last_position = {}


local excluded_npc = { --Запретные профили/имена/story_id
}
local excluded_sect = { --Запретные аномалии
	["burning_fuzz"] = true,
	["zone_rad"] = true,
}
local excluded_comms = { --Запретные коммунити
	["zombied"] = true,
}
local excluded_locations = { --Запретные локации
	--["l03u_agr_underground"] = true,
}


function attach( sm )
	sm:subscribe({ signal = "on_npc_death",			fun = this.on_death })
	sm:subscribe({ signal = "on_npc_net_destroy",	fun = this.cleanup })
	sm:subscribe({ signal = "on_npc_spawn",			fun = this.on_npc_spawn })
	if monsters_too then
		sm:subscribe({ signal = "on_monster_death",			fun = this.on_death })
		sm:subscribe({ signal = "on_monster_net_destroy",	fun = this.cleanup })
		sm:subscribe({ signal = "on_monster_spawn",			fun = this.on_monster_spawn })
	end
end

function can_evade(npc)
  if
    excluded_locations[ level.name() ]
    or not npc:alive()
    or (
      npc:is_stalker()
      and (
        excluded_comms[ npc:character_community() ]
        or excluded_npc[ npc:profile_name() ]
        or excluded_npc[ npc:name() ]
        or excluded_npc[ npc:story_id() ]
      )
    )
  then
  	return false
  end
  return true
end

function on_monster_spawn( obj, binder )
  if not can_evade(obj) then return end
  --
  added_restrictions[ obj:id() ] = {}
  --
  local s = {
    [ "signal" ] = "on_monster_update." .. obj:id(),
    [ "fun"    ] = this.update_norm,
    [ "queued" ] = true,
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end

function on_npc_spawn( obj, binder )
  if not can_evade(obj) then return end
  --
  added_restrictions[ obj:id() ] = {}
  --
  if obj:relation( db.actor ) ~= game_object.enemy then
    set_anomaly_invisibility( obj, true )
  end
  --
  local s = {
    [ "signal" ] = "on_npc_update." .. obj:id(),
    [ "fun"    ] = this.update_norm,
    [ "queued" ] = true,
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end

function on_death( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ script_name() .. ".subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
	binder[ script_name() .. ".subscribed" ] = nil
  end
  cleanup( obj )
end

function cleanup( obj )
	local nid   = obj:id()
	local anoms = added_restrictions[nid]
	if anoms and next(anoms) then
		local restrs = {}
		for k, v in pairs(anoms) do
			local sobj = alife():object(k)
			if sobj then
				table.insert(restrs, sobj:name())
			end
		end
		if table.getn(restrs) > 0 then
			--log3("[ANOMALY EVADER] REMOVING IN RESTRICTIONS FOR [%s]: %s", obj:name(), restrs)
			local s = table.concat( restrs, "," )
			ASSERT( s:len() < 3072, "too long: %s", s:len() )
			obj:remove_restrictions( "", s )
		end
	end
	added_restrictions[nid] = nil
	last_position[nid]      = nil
	if get_anomaly_invisibility( obj ) then
      set_anomaly_invisibility( obj, false )
    end
end

function update_norm(npc)
  local curr_pos = npc:position()
  local prev_pos = last_position[ npc:id() ]
  if prev_pos then
    if prev_pos:distance_to( curr_pos ) < detect_radius / 2 then
      return
    else
      last_position[ npc:id() ] = curr_pos
    end
  else
    last_position[ npc:id() ] = curr_pos
  end

  local restr = {}
  for a, b in pairs(ogse_anomaly.get_all_nearest_anomalies_by_point_in_radius( npc:position(), detect_radius )) do
    local obj = level.object_by_id( a )
    if obj then
      local ignore = false
      for k, v in pairs( excluded_sect ) do
        if string.find( b.sect, k ) then
          ignore = true
          break
        end
      end
      if not ignore then
        restr[ obj:name() ] = true
      end
    end
  end

  local del = {}
  for k, _ in pairs( added_restrictions[ npc:id() ] ) do
    if restr[ k ] then
      restr[ k ] = nil -- уже установлен
    else
      table.insert( del, k ) -- удалить старый
    end
  end
  if #del > 0 then
    for _, k in ipairs( del ) do
      added_restrictions[ npc:id() ][ k ] = nil
    end
    --log3("[ANOMALY EVADER] REMOVING IN RESTRICTIONS FOR [%s]: %s", npc:name(), del)
    local s = table.concat( del, "," )
    ASSERT( s:len() < 3072, "too long: %s", s:len() )
    npc:remove_restrictions( "", s )
  end

  local add = {}
  for k, _ in pairs( restr ) do
    table.insert( add, k ) -- добавить новый
  end
  if #add > 0 then
    local s = table.concat( add, "," )
    if npc:in_restrictions():len() + 1 + s:len() < 3072 then
      --log3("[ANOMALY EVADER] ADDING IN RESTRICTIONS FOR [%s]: %s", npc:name(), add)
      npc:add_restrictions( "", s )
      for _, k in ipairs( add ) do
        added_restrictions[ npc:id() ][ k ] = true
      end
      ogse_signals.get_mgr():reschedule( freq )
    else
      log3(
        "!![%s]: %s: in_restrictions is too long: %s, %s",
        script_name(), npc:name(), npc:in_restrictions():len(), s:len()
      )
      log3(
        "~~[%s]: %s: in_restrictions() = %s",
        script_name(), npc:name(), npc:in_restrictions()
      )
      log3(
        "~~[%s]: change detect radius: %s -> %s",
        script_name(), detect_radius, detect_radius * 0.75
      )
      detect_radius = detect_radius * 0.75
      log3(
        "~~[%s]: change detect freq:   %s -> %s",
        script_name(), freq, freq * 0.75
      )
      freq = freq * 0.75
    end
  else
    ogse_signals.get_mgr():reschedule( freq )
  end
end
