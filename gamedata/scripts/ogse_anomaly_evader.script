-----------------------------------------------------------------------
--- ogse_anomaly_evader.script
--- Модуль обхода аномалий
--- KamikaZze, OGS Evolution Team 2011
--- version 1.3 (20/08/2012)
-----------------------------------------------------------------------
--- Настройки схемы
-----------------------------------------------------------------------
local monsters_too = false --Включить монстрам обход аномалий?
local freq = 1000 --Как часто выполнять апдейт обхода аномалий (в мс)

local excluded_npc = { --Запретные профили/имена/story_id
	["bar_ecolog_professor"] = true,
	["dik_the_drifter"] = true,
	["zona_brother1"] = true,
	["zona_brother2"] = true,
	["val_escort_captive"] = true,
	["val_escort_nap1"] = true,
	["bandit_trader"] =	true,
	["bandit_trader_spawn"]	= true,		
}
local excluded_sect = { --Запретные аномалии
	["burning_fuzz"] = true,
	["zone_rad"] = true,
}
local excluded_comms = { --Запретные коммунити
	["zombied"] = true,
	["trader"] = true,
	["gunsmith"] = true,
	["guider"] = true,
}
local excluded_locations = { --Запретные локации
	--["l03u_agr_underground"] = true,
}


function attach( sm )
	sm:subscribe({ signal = "on_after_blowout",		fun = this.on_after_blowout })
	sm:subscribe({ signal = "on_npc_death",			fun = this.on_death })
	sm:subscribe({ signal = "on_npc_net_destroy",	fun = this.on_destroy })
	sm:subscribe({ signal = "on_npc_spawn",			fun = this.on_npc_spawn })
	if monsters_too then
		sm:subscribe({ signal = "on_monster_death",			fun = this.on_death })
		sm:subscribe({ signal = "on_monster_net_destroy",	fun = this.on_destroy })
		sm:subscribe({ signal = "on_monster_spawn",			fun = this.on_monster_spawn })
	end
end

function can_evade(npc)
  if
    excluded_locations[ level.name() ]
    or not npc:alive()
    or (
      IsStalker( npc )
      and (
        excluded_comms[ npc:character_community() ]
        or excluded_npc[ npc:profile_name() ]
        or excluded_npc[ npc:name() ]
        or excluded_npc[ npc:story_id() ]
      )
    )
  then
  	return false
  end
  return true
end

local added_restrictions = {}
local last_position      = {}

function on_after_blowout()
  last_position = {}
end

function on_monster_spawn( obj, binder )
  added_restrictions[ obj:id() ] = nil
  last_position[ obj:id()      ] = nil

  if not can_evade(obj) then return end
  local s = {
    [ "signal" ] = "on_monster_update." .. obj:id(),
    [ "fun"    ] = this.update_norm,
    [ "queued" ] = true,
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end

function on_npc_spawn( obj, binder )
  added_restrictions[ obj:id() ] = nil
  last_position[ obj:id()      ] = nil

  if not can_evade(obj) then return end
  local s = {
    [ "signal" ] = "on_npc_update." .. obj:id(),
    [ "fun"    ] = this.update_norm,
    [ "queued" ] = true,
  }
  binder[ script_name() .. ".subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end

function on_death( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ script_name() .. ".subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
  end
  cleanup( obj )
end

function on_destroy( obj )
  cleanup( obj )
end

function remove_restriction(npc, anomid)
	if
	  not npc
	  or not anomid
	  or isIndoor(level.name())
	then
	  return
	end

	local obj = level.object_by_id(anomid)
	local anom_sect = ""
	if obj then
		anom_sect = obj:section()
		if ogse_anomaly.chek_exclusion_anomaly(anomid) and not string.find(anom_sect, "handmade_") then
			obj:disable_anomaly()
		end
	else
		obj = alife():object(anomid)
		if obj then
			anom_sect = obj:section_name()
		end
	end
	if anom_sect == "" then return end -- вообще нет объекта аномалии - ничего не поделать. Рестрикторы такого непися будут очищены на первом апдейте актора.
	local npc_id = npc:id()
	if ogse_anomaly.chek_exclusion_anomaly(anomid) and not string.find(anom_sect, "handmade_") then
		ogse_anomaly.set_anomaly_mode(anomid, "anom_off")
		ogse_anomaly.remove_anomaly(anomid)	
		ogse_anomaly.delete_anom(level.name(), anomid)
	end
	if added_restrictions[npc_id] and added_restrictions[npc_id][anomid] then
		added_restrictions[npc_id][anomid] = nil
		log3("~~[ANOMALY EVADER] REMOVING IN RESTRICTION FOR [%s]: [%s]", npc:name(), obj:name())
		npc:remove_restrictions("",obj:name())
	end
end

function cleanup( obj )
	local nid   = obj:id()
	local anoms = added_restrictions[nid]
	if anoms then
		local restrs = {}
		for k, v in pairs(anoms) do
			local sobj = alife():object(k)
			if sobj then
				table.insert(restrs, sobj:name())
			end
		end
		if table.getn(restrs) > 0 then
			log3("~~[ANOMALY EVADER] REMOVING IN RESTRICTIONS FOR [%s]: %s", obj:name(), restrs)
			obj:remove_restrictions("", table.concat( restrs, "," ))
		end
		added_restrictions[nid] = nil
		last_position[nid]      = nil
	end
end

function update_norm(npc)
  ogse_signals.get_mgr():reschedule( freq )

  local curr_pos = npc:position()
  local prev_pos = last_position[ npc:id() ]
  if prev_pos then
    if prev_pos:distance_to( curr_pos ) < 15 then --ранее было 20
      return
    else
      last_position[ npc:id() ] = curr_pos
    end
  else
    last_position[ npc:id() ] = curr_pos
  end

  if not added_restrictions[ npc:id() ] then
    added_restrictions[ npc:id() ] = {}
  end
  local restr = {}
  for a, b in pairs(ogse_anomaly.get_all_nearest_anomalies_by_point_in_radius( npc:position(), 30 )) do
    local obj = level.object_by_id( a )
    if obj and ogse_anomaly.get_anomaly_mode( a ) ~= "anom_off" then
      local ignore    = false
      for k, v in pairs( excluded_sect ) do
        if string.find( b.sect, k ) then
          ignore = true
          break
        end
      end
      if not ignore then
        restr[ obj:name() ] = true
      end
    end
  end

  local del = {}
  for k, _ in pairs( added_restrictions[ npc:id() ] ) do
    if restr[ k ] then
      restr[ k ] = nil -- уже установлен
    else
      table.insert( del, k ) -- удалить старый
    end
  end
  if table.getn( del ) > 0 then
    for _, k in ipairs( del ) do
      added_restrictions[ npc:id() ][ k ] = nil
    end
    log3("~~[ANOMALY EVADER] REMOVING IN RESTRICTIONS FOR [%s]: %s", npc:name(), del)
    npc:remove_restrictions( "", table.concat( del, "," ) )
  end

  local add = {}
  for k, _ in pairs( restr ) do
    table.insert( add, k ) -- добавить новый
    added_restrictions[ npc:id() ][ k ] = true
  end
  if table.getn( add ) > 0 then
    log3("--[ANOMALY EVADER] ADDING IN RESTRICTIONS FOR [%s]: %s", npc:name(), add)
    npc:add_restrictions( "", table.concat( add, "," ) )
  end
end
