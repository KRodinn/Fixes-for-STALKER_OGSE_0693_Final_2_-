
function init(obj)
--	log1("ogse_dbg_anomaly_binder.init")
	local new_binder = anomaly_binder(obj)
	obj:bind_object(new_binder)
end

---------------------------------------------------------------------------------------------
class "anomaly_binder" (object_binder)
function anomaly_binder:__init(obj) super(obj)
end 

function anomaly_binder:reload(section)
--	log1("anomaly_binder:reload")
end

function anomaly_binder:reinit()
--	log1("anomaly_binder:reinit")
end

function anomaly_binder:net_spawn(data)
--	log1("anomaly_binder:net_spawn")
	local anom = self.object
	if anom then
		local srv_obj = alife():object(anom:id())
		if srv_obj then
			ogse_anomaly.get_anom(srv_obj)
--			log1("anomaly_binder:net_spawn_register")
		end	
	end
	return true
end

local radzone_sect = {
	["zone_radioactive"] = { warn = 1, last_warn = 4,  alarm = 8 },
	["zone_radioactive_weak"] = { warn = 1, last_warn = 3,  alarm = 5 },
	["zone_radioactive_average"] = { warn = 1, last_warn = 3,  alarm = 6 },
	["zone_radioactive_strong"] = { warn = 1, last_warn = 4,  alarm = 7 },
	["zone_radioactive_killing"] = { warn = 1, last_warn = 4,  alarm = 8 },
	["handmade_zone_radioactive"] = { warn = 1, last_warn = 4,  alarm = 8 },
}

local radzone_deeps = {}

local geiger_warn = ogse_detectors.geiger_radius
local actor_radlevel = 0
local estimate_size = {}

function get_rad_intensity(obj)
	local intencity = radzone_sect[obj:section()]
	if not intencity then return end
	local actor_pos = db.actor:position()
	local dist_to_actor = obj:position():distance_to(actor_pos)
	local o_id = obj:id()
	if obj:inside(actor_pos) and dist_to_actor > geiger_warn then	
		--- актор внутри радзоны, но дальше радиуса предупреждения - большая зона, считаем по крайним значениям
		local low = intencity.warn
		local high = intencity.alarm
		if not estimate_size[o_id] then
			estimate_size[o_id] = dist_to_actor
		end
		local radius = estimate_size[o_id]
		local step = radius/high
		local rad_level = math.ceil(radius/step)
		if rad_level > high then
			rad_level = high
		end		
		radzone_deeps[o_id] = rad_level
	elseif obj:inside(actor_pos) and dist_to_actor < geiger_warn then	
		--- актор внутри радзоны, и меньше радиуса предупреждения - актор вошел внутрь, считаем по верхним значениям
		local low = intencity.last_warn
		local high = intencity.alarm
		if not estimate_size[o_id] then
			estimate_size[o_id] = dist_to_actor
		end
		local radius = estimate_size[o_id]
		local div = high - low
		local step = radius/div
		local deep = high - (dist_to_actor/step)
		local rad_level = math.ceil(deep)
		if rad_level > high then
			rad_level = high
		end		
		radzone_deeps[o_id] = rad_level
	elseif dist_to_actor < geiger_warn then
		--- актор снаружи радзоны, и меньше радиуса предупреждения - актор рядом, считаем по нижним значениям
		local low = intencity.warn
		local high = intencity.last_warn
		local radius = geiger_warn
		local div = high - low
		local step = radius/div
		local deep = high - (dist_to_actor/step)
		local rad_level = math.ceil(deep)
		if rad_level > high then
			rad_level = high
		end		
		radzone_deeps[o_id] = rad_level
	elseif dist_to_actor > geiger_warn then	
		if radzone_deeps[o_id] then
			radzone_deeps[o_id] = nil
		end
	end
end

function get_max_radlevel()
	local radlevel = 0
	for k, v in pairs(radzone_deeps) do
		if v > radlevel then
			radlevel = v
		end	
	end
	return radlevel
end

local anoms_to_show = {}
local spots = {
	"anomaly_bald_location",
	"anomaly_minc_location",
	"anomaly_grav_location",
	"anomaly_rad_location",
	"anomaly_elec_location",
	"anomaly_burn_location",
	"anomaly_hvat_location",
	"anomaly_hvat_location",
	"anomaly_liana_location",
	"anomaly_hvat_location",
	"anomaly_buzz_location",
}

function anomaly_binder:update()
	get_rad_intensity(self.object)

	local sid = self.object:id()
	if not anoms_to_show[sid] then
		anoms_to_show[sid] = false
	end
	local mark_text = ogse_detectors.marks_on_minimap(self.object)
	if mark_text ~= "none" then
		if level_tasks.is_map_spot_present_by_id(sid, mark_text) then
			anoms_to_show[sid] = true
		elseif anoms_to_show[sid] == false then
			--log3("Called adding location by id for [%s], Spot: [%s]", sid, mark_text)
			level_tasks.add_location_by_id(sid, mark_text, "DANGER")
			anoms_to_show[sid] = true
		end
	elseif anoms_to_show[sid] == true then
		for _, n in ipairs( spots ) do
			if level_tasks.is_map_spot_present_by_id(sid, n) then
				--log3("Called removing location by id for [%s], Spot: [%s]", sid, n)
				level_tasks.remove_location_by_id(sid,n,"DANGER")
				break
			end
		end
		anoms_to_show[sid] = false
	end
end

function anomaly_binder:net_destroy()
	local sid = self.object:id()
	if radzone_deeps[sid] then
		radzone_deeps[sid] = nil
	end
	if anoms_to_show[sid] == true then
		for _, n in ipairs( spots ) do
			if level_tasks.is_map_spot_present_by_id(sid, n) then
				--log3("Called removing location by id for [%s], Spot: [%s]", sid, n)
				level_tasks.remove_location_by_id(sid,n,"DANGER")
				break
			end
		end
		anoms_to_show[sid] = false
	end	
end
