-- -*- mode: lua; coding: windows-1251-dos -*-
--************************************************* Инициализация расширений движка ************************************************
log1("--LUA version: ["..(jit.version or _VERSION).."]")
log1("--...Initializing X-Ray Extensions - start...")

if RvP then RvP() end

if SetLog then SetLog(getFS():update_path("$logs$", "_ogse.log")) end

if init_external_libs then init_external_libs() end

package.cpath = package.cpath..";"..getFS():update_path("$fs_root$", "bin\\extensions\\?.dll")
xpcall(function() require("ogse") end, log1)

if set_static_rescale_factor then set_static_rescale_factor(device().height / device().width / 0.75) end

math.randomseed(os.time())

os.setlocale("", "ctype") --Включает поддержку русских букв в string.lower/upper. Такой костыль работает только в версиях LuaJIT ниже 2.0.

--=================================[Функции из xrLuaFix]========================================
--Срезать пробелы слева
if not string.trim_l then
	string.trim_l = function(s) return s:gsub("^%s+",'') end
end
--Срезать пробелы справа
if not string.trim_r then
	string.trim_r = function(s) return s:gsub("%s*$",'') end
end
--Срезать все пробелы слева и справа
if not string.trim then
	string.trim = function(s) return s:gsub('^%s*(.-)%s*$', '%1') end
end
--==============================================================================================
-- Взято из аддона Naxac'a
local to_ptrn = {
	[' '] = '%s',
	['.'] = '%.',
	['%'] = '%%',
	['*'] = '%*',
	['-'] = '%-'
}
string.explode = function ( div,		-- разделитель
							str,		-- строка
							clear )		-- обрезать ли пробелы по краям строк (false/true)
	local ret = {}
	div = to_ptrn[div] or div
	for s in str:gmatch("([^"..div.."]+)") do
		ret[#ret+1] = (clear and s:trim() or s)
	end
	return ret
end
--==============================================================================================
-- Форматирование текста по ширине
-- http://www.amk-team.ru/forum/topic/13216-sborochnyy-ceh/?do=findComment&comment=959286
function string.width(str, width, return_table, indent, paragrapf)
    indent    = indent    or 0
    paragrapf = paragrapf or 0
    width     = (width or 80) - indent
    
    local i = string.rep(' ', indent)
    local t = {}
    local line = string.rep(' ', paragrapf)
    
    for exp, word in str:gmatch('(%s-(%S+))') do
        if line == '' and #t ~= 0 then
            exp = word
        end

        local l_len = #line
        local len = l_len + #exp
        
        if len > width then
            t[#t+1], line = line, word
        else
            line = line .. exp
            if l_len == width then
                t[#t+1], line = line, ''
            end
        end
    end

    t[#t+1] = line

	if return_table then
		return t
	else
		return i .. table.concat(t, '\n' .. i)
	end
end
--==============================================================================================
-- поверхностное (простое) клонирование таблицы: 
-- создаётся копия таблицы и копии всех элементов без их клонирования,
-- т.е. для ссылочных типов обе таблицы будут содержать ссылки на одни и те же данные
-- метатаблицы не копируются
function table.clone_simple(tbl)
	local res = {}
	for k,v in pairs(tbl) do
		res[k] = v
	end
	return res
end
--==============================================================================================
function table.copy(tbl) --Возвращает копию таблицы.
	local mt = getmetatable(tbl)
	local res = {}
	for k, v in pairs(tbl) do
		if type(k) == "table" then
			k = table.copy(k)
		end
		if type(v) == "table" then
			v = table.copy(v)
		end
		res[k] = v
	end
	setmetatable(res, mt)
	return res
end
--=================================[CUIScriptWnd Extension]=====================================
-- Вызов обычный, как и в AddCallback, но после последнего аргумента можно передавать множество дополнительных.
-- KRodin: из-за особенностей этого метода, у функции func, если она не является членом класса, первый аргумент не должен использоваться, например:
-- local function func(_, ...) end
function CUIScriptWnd:Connect(name, event, func, ...)
	local args = {...}
	return self:AddCallback( name, event, function() func(unpack(args)) end )
end
--=======================================[LuaXML]===============================================
xpcall(function() dofile(getFS():update_path("$game_scripts$", "_luaxml.lua")) end, log1)
DYN_XML_SAVE_PATH = getFS():update_path('$game_config$', 'ui\\ui_dynamic.xml') --Путь к динамическому XML файлу
--==============================================================================================
-- жуткая затычка для проблемы с большими целыми числами при сложении в Lua
-- родное сложение начинает округлять и терять часть суммы, а функция sum_args
-- при тривиальном использовании в ряде случаев отсекает аргументы со значения 0x80000000
-- здесь сделано так, что этот эффект не происходит. Функция очень медленная,
-- использовать только в связке с функцией получения значения по абсолютному адресу
-- и по возможности вообще избегать.
function sum_args_ex(base, offs)
	local base_s = string.format("%08x", base)
	local b1_s = base_s:sub(1,4)
	--log1(b1_s)
	local b2_s = base_s:sub(5,8)
	--log1(b2_s)
	local b1 = tonumber(b1_s, 16)
	local b2 = tonumber(b2_s, 16)
	local res = sum_args(bit.lshift(b1, 16), sum_args(b2, offs)) --KRodin: думал, что res = первое значение, а второе вообще не используется. Но как оказалось, res = сумма этих двух значений. Я и не знал, что так можно делать.
	--log2("~~sum_args_ex: %s, %x, %x", base_s, offs, res) --Действительно, этот результат
	--log2("~~lua + : %x", base + offs) --и этот результат - отличаются. При переезде на исходники надо будет городить функцию в движке, или попробовать использовать ffi
	return res
end
--==============================================================================================
--Некоторые недостающие DIK_keys:
DIK_keys["DIK_MOUSE1"] = 337
DIK_keys["DIK_MOUSE2"] = 338
DIK_keys["DIK_MOUSE3"] = 339
DIK_keys["DIK_MOUSE4"] = 340
DIK_keys["DIK_MOUSE5"] = 341
DIK_keys["DIK_MOUSE6"] = 342
DIK_keys["DIK_MOUSE7"] = 343
DIK_keys["DIK_MOUSE8"] = 344

--Некоторые недостающие key_bindings:
key_bindings["kSPRINT_TOGGLE"] = 8
key_bindings["kENGINE"] = 15
key_bindings["kARTEFACT"] = 30
key_bindings["kWPN_FIREMODE_PREV"] = 38
key_bindings["kWPN_FIREMODE_NEXT"] = 39
key_bindings["kPAUSE"] = 40
key_bindings["kCHAT_TEAM"] = 45
key_bindings["kACTIVE_JOBS"] = 53
key_bindings["kMAP"] = 54
key_bindings["kCONTACTS"] = 55
key_bindings["kVOTE_BEGIN"] = 57
key_bindings["kVOTE"] = 58
key_bindings["kVOTEYES"] = 59
key_bindings["kVOTENO"] = 60
key_bindings["kSPEECH_MENU_0"] = 63
key_bindings["kSPEECH_MENU_1"] = 64
key_bindings["kUSE_BANDAGE"] = 73
key_bindings["kUSE_MEDKIT"] = 74
key_bindings["kQUICK_SAVE"] = 75
key_bindings["kQUICK_LOAD"] = 76
--==============================================================================================
local _advance_game_time = level.advance_game_time
level.advance_game_time = function(game_ms) --KRodin: универсальная функция для перевода часов. Вынесена из менеджера сна.
	_advance_game_time(game_ms) --Прокручивает игровое время вперед на заданное кол-во ИГРОВЫХ миллисекунд.
	--
	db.actor:update_condition() --Обновляем движковые эффекты здоровья
	--
	ogse_signals.get_mgr():call("after_time_change") --KRodin: Добавил специальный сигнал для обновления погодного менеджера, таймеров и прочих систем, зависящих от игрового времени.
	--
	ogse_signals.get_mgr():call("on_update", 0) --Учитываем все возможные скриптовые эффекты
	--
	--Malandrinus: Эта функция идёт как затычка к механизму прокрутки времени, который в ОГСЕ используется для сна.
	--Я обнаружил, что после прокрутки времени происходят косяки с пересчётом состояний актора.
	--Подробностей уже не помню, но лечилось это разовым игнорированием соответствующего обновления сразу после приращения времени.
	--Для установки этого разового игнора и предназначена эта функция.
	--Вполне допускаю, хотя уже и не помню точно, что вместе с актором пропускается обновление чего-то ещё.
	-- http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/page-50#entry975972
	set_ignore_game_state_update()
end
--==============================================================================================
log1("--Initializing X-Ray Extensions - end")
--******************************************** Инициализация расширений движка закончена ********************************************

-- FIX Nazgool ------------------------------------------------------------------
-- Возможно подобные функции уже где-то и есть, но я пока не нашёл.
-- Проверки
function isTable   (obj) return type(obj) == 'table'    end
function isBoolean (obj) return type(obj) == 'boolean'  end
function isNumber  (obj) return type(obj) == 'number'   end
function isFunction(obj) return type(obj) == 'function' end
function isString  (obj) return type(obj) == 'string'   end
function isUserdata(obj) return type(obj) == 'userdata' end
function isThread  (obj) return type(obj) == 'thread'   end
function isNil     (obj) return       obj == nil        end -- не false, а именно nil
-- Проверка - пуста ли таблица или строка
-- Если параметр 'space' не nil/false, то строка, состоящая только из пробельных символов и(или) неразрывного пробела будет считаться пустой.
function isEmpty(obj, space)
    if isString(obj) then
        if space then return not obj:match('[^%s\160]+') end
        return #obj == 0
    end
    if isTable(obj) then return next(obj) == nil end
    return false
end
-- является ли таблица массивом
function isArray(tbl)
	local n=0
	for _ in pairs(tbl) do n=n+1 end
    return n <= #tbl
end

-- Приведение значения переменной 'val' к булевому значению
function toBoolean(val)
    return not not val
end
-- END FIX  Nazgool -------------------------------------------------------------

----------------------------------------------------------------------
schemes = {} -- соответствие схем модулям
stypes = {} -- типы схем

--/ Загружает схему из файла на диске и активирует в мотиваторе.
--/ Здесь:
--/  filename - имя файла, в котором реализована схема, без расширения
--/  scheme - имя схемы
function load_scheme(filename, scheme, stype)
	schemes[scheme] = filename
	stypes[scheme] = stype
end

----------------------------------------------------------------------

--TODO: Поотрывать вызовы и удалить!
function printf(fmt,...)
end
--TODO: Поотрывать вызовы и удалить!
function dbglog(fmt,...)
end


function validate_enemy_object( enemy )
  if not ( enemy and enemy.clsid ) then return false, nil end
  if enemy.health == nil or enemy.health <= 0 then 
    return false, nil
  end
  if enemy.m_story_id ~= nil then -- это грязный хак чтобы выяснить не попался ли нам серверный объект
    if not ( IsStalker( enemy ) or IsMonster( enemy) ) then
      return false, nil
    end
    local id = enemy.id
    local enemy_gameobj = level.object_by_id( id )
    if not enemy_gameobj then
      return false, nil
    else	
      return true, enemy_gameobj
    end
  else	
    if not ( enemy:is_stalker() or enemy:is_actor() or enemy:is_monster() ) then
      return false, nil
    end
    return true, enemy
  end
end

----------------------------------------------------------------------
function action(obj, ...) --Пример использования можно увидеть в ogse_hitfx. Ещё используется в mob_walker.script и mob_camp.script, может ещё где-то.
	local args = {...}
	local act = entity_action()
	for i=1, #args do
		if args[i] ~= nil then
			act:set_action(args[i])
		--else
		--	break
		end
    end
    if obj ~= nil then
        obj:command(act, false)
    end
    return entity_action(act)
end
----------------------------------------------------------------------

if not time_global then
	time_global = function() return device():time_global() end
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

--/ Если один объект nil, например нет актера, то считаем, что он далеко
function distance_between_safe(obj1, obj2)
    if(obj1 == nil or obj2 == nil) then return 100000 end
	return obj1:position():distance_to(obj2:position())
end

--/ Проверка на инфопоршны, даже если игрока не существует
function has_alife_info(info_id)
	return alife():has_info(0, info_id)
end

function if_then_else(cond, if_true, if_false)
	return cond and if_true or if_false
end

-------------------------------------------------------------------------------------------------------
--Отличается от split_comma_separated_list тем, что кроме запятых обрабатывает ещё и пробелы.
function parse_names( s )
	return string.explode(",", s, true)
end

--Конвертирует строку вида "actor, 0, actor_dolg, 1, actor_freedom, 2, ..."
--В таблицу вида { ["actor"] = "0", ["actor_dolg"] = "1", ["actor_freedom"] = "2", ... }
function parse_key_value( s )
	if s == nil then return nil end --бывает и такое

    local t = {}
	local t0 = parse_names( s )
    for i=1, #t0, 2 do
		local key, nam = t0[i], t0[i+1]
		ASSERT(nam, "parse_key_value: stopped at %s: [%s] - [%s]", i, key or "nil", nam or "nil")
		t[key] = nam
    end
    return t
end

--Парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - числа
function parse_nums( s )
    local t = {}
    for i,entry in ipairs(parse_names( s )) do
		local v = tonumber( entry )
		ASSERT(v, "parse_nums: [%s], stopped at [%s]: [%s]", s, i, entry)
		table.insert(t,  v)
    end
    return t
end
-------------------------------------------------------------------------------------------------------

function get_clsid(npc)
	--Надо бы изучить, в каких случаях сюда попадают несуществующие объекты,
	--Исправить это, и тогда можно будет убрать эти нагромождения отсюда.
	if not npc then return nil end
	if npc and npc.id then
		if type(npc.id) == "function" then
			local id = npc:id()
			local sobj = alife():object(id)
			if sobj then
				return npc:clsid()
			else
				--log3(debug.traceback())
				--log3("!!DEBUG_GETCLSID NO_SRVOBJ [%s, %s]", id, npc:name() )
				return nil
			end
		elseif type(npc.id) == "number" then
			return npc:clsid()
		else
			log3(debug.traceback())
			log1("!!DEBUG_GETCLSID GET_SOMETHING_STRANGE")
			return nil
		end
	else
		log3(debug.traceback())
		log1("!!DEBUG_GETCLSID DEAD_ON_ARRIVAL")
		return nil
	end
	--
	--if npc then return npc:clsid() end
	--return nil
end

--/ Вычисляет yaw в радианах
function yaw(v1, v2)
	if v1 and v2 then
		return math.abs(v2:getH()-v1:getH())
	else return 1 end
end
function yaw_degree(v1, v2)
	return yaw(v1, v2) * 57.295779513
end
function yaw_degree3d(v1, v2)
	if v1 and v2 then
		return math.acos(v1:dotproduct(v2))*57.295779513
	else return 1 end
end
function vector_cross(v1, v2)
	if v1 and v2 then
		return vector():crossproduct(v1, v2)
	else return vector():set(0, 0, 0) end
end

--/ Вращает вектор вокруг оси y против часовой стрелки
function vector_rotate_y(v, angle)
    angle = angle * 0.017453292519943295769236907684886
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

--/ очистка таблицы
function clear_table(t)
	for k, _ in pairs(t) do
		t[k] = nil
	end
end

function stop_play_sound(obj)
	if obj:alive() == true then
		obj:set_sound_mask(-1)
		obj:set_sound_mask(0)
	end
end


--TODO: ПООТРЫВАТЬ ВЫЗОВЫ И УДАЛИТЬ!
function print_table_inlog_v2(table, subs)
end

--TODO: ПООТРЫВАТЬ ВЫЗОВЫ И УДАЛИТЬ!
function print_table(table, subs)
end

--TODO: ПООТРЫВАТЬ ВЫЗОВЫ И УДАЛИТЬ!
function print_table_inlog(table, subs)
end


-------------------------------------------------------------------------------------------
function switch_online(id)
	alife():set_switch_online (id, true)
	alife():set_switch_offline(id, false)
end
-------------------------------------------------------------------------------------------
function switch_offline(id)
	alife():set_switch_online (id, false)
	alife():set_switch_offline(id, true)
end
-------------------------------------------------------------------------------------------
local monster_classes = {}
-------------------------------------------------------------------------------------------	
local anomaly_classes = {}
-------------------------------------------------------------------------------------------	
local stalker_classes = {}
-------------------------------------------------------------------------------------------
local weapon_classes = {}
-------------------------------------------------------------------------------------------
local outfit_classes = {}
-------------------------------------------------------------------------------------------
function IsMonster(object, class_id)
	local id = class_id or get_clsid(object)
	return id and monster_classes[id]
end
-------------------------------------------------------------------------------------------
function IsActor(object, class_id)
	local id = class_id or get_clsid(object)
	return id == clsid.actor
end
-------------------------------------------------------------------------------------------
function IsStalker(object, class_id)
	local id = class_id or get_clsid(object)
	return id and stalker_classes[id]
end
-------------------------------------------------------------------------------------------
function IsAnomaly(object, class_id)
	local id = class_id or get_clsid(object)
	return id and anomaly_classes[id]
end
-------------------------------------------------------------------------------------------
function isWeapon(object, class_id)
	--[[if object and string.find(object:name(), "wpn_binoc") then
		return false
	end]]
	local id = class_id or get_clsid(object)
	return id and weapon_classes[id]
end
-------------------------------------------------------------------------------------------
function isOutfit(object, class_id)
	local id = class_id or get_clsid(object)
	return id and outfit_classes[id]
end
-------------------------------------------------------------------------------------------
function isLc(object, class_id)
	local id = class_id or get_clsid(object)
	return id == clsid.level_changer
end
-------------------------------------------------------------------------------------------
function isKnife(object, class_id)
	local id = class_id or get_clsid(object)
	return id == clsid.wpn_knife or id == clsid.wpn_knife_s
end
-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------
function isIndoor(level_name) --KRodin: всем подземным уровням прописывается НЕ default погода. По этому признаку и будем проверять.
	return get_string(level_name, "weathers", nil, game_ini()) ~= "default"
end
-------------------------------------------------------------------------------------------

function id_by_sid( sid )
	local sim = alife()

	if sim then
		local se_obj = sim:story_object( sid )
		if se_obj then
			return se_obj.id
		end
	end
	return nil
end

function level_object_by_sid( sid )
	local id = id_by_sid( sid )
	if id then
		return level.object_by_id(id)
	end
	return nil
end

local msg_crash = {
	[0] = game.translate_string("msg_crash_1_text"),
	[1] = game.translate_string("msg_crash_2_text"),
	[2] = game.translate_string("msg_crash_3_text"),
	[3] = game.translate_string("msg_crash_4_text"),
	[4] = game.translate_string("msg_crash_5_text"),
	[5] = game.translate_string("msg_crash_6_text"),
	[6] = game.translate_string("msg_crash_7_text"),
	[7] = game.translate_string("msg_crash_8_text"),
	[8] = game.translate_string("msg_crash_9_text"),
	[9] = game.translate_string("msg_crash_1_text"),
}

local crash_counter = 0
local crash_text = game.translate_string("msg_crash_text")

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)
	for i = 0,9 do
		log1(msg_crash[i])
	end

	log3(debug.traceback())
	log3(fmt, ...)
	cmd("flush")

	if ogse.check_game() then
		local hud = get_hud()
		local critical = hud:GetCustomStatic("btr_critical")
		if not critical then
			hud:AddCustomStatic("btr_critical", true)
			critical = hud:GetCustomStatic("btr_critical"):wnd()
			critical:SetText(crash_text)
		end
	end

	if crash_counter == 0 then
		crash_counter = crash_counter + 1	
		fail(""..fmt)
	elseif crash_counter == 1 then
		crash_counter = crash_counter + 1
		log1("ABORT: 1/crash")	
		local crash
		local ooops = 1/crash
	elseif crash_counter == 2 then
		crash_counter = crash_counter + 1
		log1("ABORT: string.format")	
		string.format("%s")		
	else
		crash_counter = crash_counter + 1
		log1("get_console():execute quit")
		cmd("quit")
	end
end

--/ проверяет целую часть числа на нечётность
function odd( x )
	return math.floor( x * 0.5 ) * 2 == math.floor( x )
end

--/ Усталость
function on_actor_critical_power()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_11_weakness")
--/	end
	if not has_alife_info("encyclopedy_tutorial_weakness") then
		game.start_tutorial("part_11_weakness")
		db.actor:give_info_portion("encyclopedy_tutorial_weakness")
	end
end


function on_actor_critical_max_power()
end

--/ Кровотечение
function on_actor_bleeding()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_8_wound")
--/	end
	if not has_alife_info("encyclopedy_tutorial_wound") then
		game.start_tutorial("part_8_wound")
		db.actor:give_info_portion("encyclopedy_tutorial_wound")
	end
end
--/ Голод
function on_actor_satiety()
	if not ogse_sleep_mgr.is_sleep_active() then
		if not has_alife_info("encyclopedy_tutorial_satiety") then
			game.start_tutorial("part_13_satiety")
			db.actor:give_info_portion("encyclopedy_tutorial_satiety")
		end
	end
end

--/ Радиация
function on_actor_radiation()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_6_radiation")
--/	end
	if not has_alife_info("encyclopedy_tutorial_radiation") then
		game.start_tutorial("part_6_radiation")
		db.actor:give_info_portion("encyclopedy_tutorial_radiation")
	end
end

--/ Заклинило оружие
function on_actor_weapon_jammed()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_9_weapon")
--/	end
	if not has_alife_info("encyclopedy_tutorial_weapon") then
		game.start_tutorial("part_9_weapon")
		db.actor:give_info_portion("encyclopedy_tutorial_weapon")
	end
end

--/ не может ходить изза веса
function on_actor_cant_walk_weight()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_14_overload")
--/	end
	if not has_alife_info("encyclopedy_tutorial_psy") then
		game.start_tutorial("part_7_psy")
		db.actor:give_info_portion("encyclopedy_tutorial_psy")
	end
end

--/ пси воздействие
function on_actor_psy()	
end

function set_actor_rank(rank)
	if rank == "novice" then
		db.actor:set_character_rank(0)
	elseif rank == "stalker" then
		db.actor:set_character_rank(300)
	elseif rank == "veteran" then
		db.actor:set_character_rank(600)
	elseif rank == "master" then
		db.actor:set_character_rank(900)
	end
end

function get_texture_info(id_name, id_default)
	if id_default == nil then id_default = id_name end

	local task_info = GetTextureInfo(id_name, id_default)
	local r = task_info:get_rect()

	r.x2 = r.x2 - r.x1
	r.y2 = r.y2 - r.y1
	return task_info:get_file_name(), r
end

function start_game_callback()
	monster_classes = {
		[clsid.bloodsucker] 			= true,
		[clsid.boar] 					= true,
		[clsid.dog_red] 				= true,
		[clsid.dog_black] 				= true,
		[clsid.flesh] 					= true,
		[clsid.burer] 					= true,
		[clsid.cat] 					= true,
		[clsid.chimera] 				= true,
		[clsid.controller] 				= true,
		[clsid.fracture] 				= true,
		[clsid.poltergeist] 			= true,
		[clsid.zombie] 					= true,
		[clsid.snork] 					= true,
		[clsid.tushkano] 				= true,
		[clsid.psy_dog] 				= true,
		[clsid.psy_dog_phantom] 		= true,	
		[clsid.pseudo_gigant] 			= true,	
		[clsid.bloodsucker_s] 			= true,
		[clsid.boar_s] 					= true,
		[clsid.dog_s] 					= true,
		[clsid.flesh_s] 				= true,
		[clsid.pseudodog_s] 			= true,
		[clsid.burer_s] 				= true,
		[clsid.cat_s] 					= true,
		[clsid.chimera_s] 				= true,
		[clsid.controller_s] 			= true,
		[clsid.fracture_s] 				= true,
		[clsid.poltergeist_s] 			= true,
		[clsid.gigant_s] 				= true,
		[clsid.zombie_s] 				= true,
		[clsid.snork_s] 				= true,
		[clsid.tushkano_s] 				= true,
		[clsid.psy_dog_s] 				= true,
		[clsid.psy_dog_phantom_s] 		= true
		}
	anomaly_classes = {
		[clsid.zone_acid_fog] = true,
		[clsid.zone_bfuzz] = true,
		[clsid.zone_bfuzz_s] = true,
		[clsid.zone_dead] = true,
		[clsid.zone_galant_s] = true,
		[clsid.zone_galantine] = true,
		[clsid.zone_mbald_s] = true,
		[clsid.zone_mincer] = true,
		[clsid.zone_mincer_s] = true,
		[clsid.zone_mosquito_bald] = true,
		[clsid.ameba_zone] = true,
		[clsid.zone_rusty_hair] = true,
		[clsid.torrid_zone] = true,
		[clsid.zone_radioactive] = true
		}
	stalker_classes = {
		[clsid.actor] 					= true,
		[clsid.script_stalker] 			= true
		}	
	weapon_classes = {
		[clsid.wpn_ak74] 				= true,
		[clsid.wpn_ak74_s] 				= true,
		[clsid.wpn_binocular] 			= true,
		[clsid.wpn_binocular_s] 		= true,
		[clsid.wpn_bm16] 				= true,
		[clsid.wpn_bm16_s] 				= true,
		[clsid.wpn_fn2000] 				= true,
		[clsid.wpn_fort]				= true,
		[clsid.wpn_grenade_f1] 			= true,
		[clsid.wpn_grenade_fake] 		= true,
		[clsid.wpn_grenade_launcher] 	= true,
		[clsid.wpn_grenade_rgd5] 		= true,
		[clsid.wpn_grenade_rpg7]		= true,
		[clsid.wpn_groza] 				= true,
		[clsid.wpn_groza_s] 			= true,
		[clsid.wpn_hpsa] 				= true,
		[clsid.wpn_hpsa_s] 				= true,
		[clsid.wpn_knife] 				= true,
		[clsid.wpn_knife_s] 			= true,
		[clsid.wpn_lr300] 				= true,
		[clsid.wpn_lr300_s] 			= true,
		[clsid.wpn_mounted] 			= true,
		[clsid.wpn_pm] 					= true,
		[clsid.wpn_pm_s] 				= true,
		[clsid.wpn_rg6] 				= true,
		[clsid.wpn_rg6_s] 				= true,
		[clsid.wpn_rpg7] 				= true,
		[clsid.wpn_rpg7_s] 				= true,
		[clsid.wpn_shotgun] 			= true,
		[clsid.wpn_shotgun_s] 			= true,
		[clsid.wpn_stat_mgun] 			= true,
		[clsid.wpn_svd] 				= true,
		[clsid.wpn_svd_s] 				= true,
		[clsid.wpn_svu] 				= true,
		[clsid.wpn_svu_s] 				= true,
		[clsid.wpn_usp45] 				= true,
		[clsid.wpn_usp45_s] 			= true,
		[clsid.wpn_val] 				= true,
		[clsid.wpn_val_s] 				= true,
		[clsid.wpn_vintorez] 			= true,
		[clsid.wpn_vintorez_s] 			= true
	}
	outfit_classes = {
		[clsid.equ_exo] 				= true,
		[clsid.equ_military]			= true,
		[clsid.equ_scientific] 			= true,
		[clsid.equ_stalker] 			= true,
		[clsid.equ_stalker_s] 			= true	
	}

	m_netpk.attach()

	dialog_manager.fill_phrase_table()	
end


-------------------------------------------------------------------------------
--                            Добавлено в OGSE                               --
-------------------------------------------------------------------------------
function ASSERT(cond, msg, ...)
	if not cond then
		abort(msg, ...)
	end
end

----------------------------------------------------------------------------
local orig_sys_ini = system_ini()
class "dbg_sys_ini"
function dbg_sys_ini:__init()
	log1("dbg_sys_ini:__init")
end
function dbg_sys_ini:line_count(sec)
	log3("dbg_sys_ini:line_count: %s", sec)
	log3(debug.traceback())
	return orig_sys_ini:line_count(sec)
end
function dbg_sys_ini:section_exist(sec)
	log3("dbg_sys_ini:section_exist: %s", sec)
	log3(debug.traceback())
	return orig_sys_ini:section_exist(sec)
end
function dbg_sys_ini:line_exist(sec, param)
	log3("dbg_sys_ini:line_exist: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:line_exist(sec, param)
end
function dbg_sys_ini:r_bool(sec, param)
	log3("dbg_sys_ini:r_bool: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_bool(sec, param)
end
function dbg_sys_ini:r_float(sec, param)
	log3("dbg_sys_ini:r_float: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_float(sec, param)
end
function dbg_sys_ini:r_clsid(sec, param)
	log3("dbg_sys_ini:r_clsid: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_clsid(sec, param)
end
function dbg_sys_ini:r_s32(sec, param)
	log3("dbg_sys_ini:r_s32: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_s32(sec, param)
end
function dbg_sys_ini:r_u32(sec, param)
	log3("dbg_sys_ini:r_u32: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_u32(sec, param)
end
function dbg_sys_ini:r_vector(sec, param)
	log3("dbg_sys_ini:r_vector: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_vector(sec, param)
end
function dbg_sys_ini:r_string_wq(sec, param)
	log3("dbg_sys_ini:r_string_wq: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_string_wq(sec, param)
end
function dbg_sys_ini:r_string(sec, param)
	log3("dbg_sys_ini:r_string: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_string(sec, param)
end
function dbg_sys_ini:r_token(sec, param)
	log3("dbg_sys_ini:r_token: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_token(sec, param)
end
function dbg_sys_ini:r_line(sec, line_num)
	log3("dbg_sys_ini:r_line: %s - %s", sec, line_num)
	log3(debug.traceback())
	return orig_sys_ini:r_line(sec, line_num)
end

--system_ini = function() return dbg_sys_ini() end
----------------------------------------------------------------------------

sys_ini = system_ini() --Из скриптов вызывать только sys_ini!!!!

-- служебные функции для чтения параметров из секций объектов

function get_string(section, param, def_val, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_string: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_string(section, param)
	else
		return def_val
	end
end

function get_string_wq(section, param, def_val, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_string: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_string_wq(section, param)
	else
		return def_val
	end
end

function get_u32(section, param, def_val, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_u32: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_u32(section, param)
	else
		return def_val
	end
end

function get_bool(section, param, def_val, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_bool: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_bool(section, param)
	else
		return not (not def_val)
	end
end

function get_float(section, param, def_val, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_float: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_float(section, param)
	else
		return def_val
	end
end

-- получить класс из секции, полезно в том случае, если нет объекта (и недоступен метод clsid), а есть только имя секции
function get_class(section)
	ASSERT(sys_ini:section_exist(section), "get_class: section '"..section.."' doesn't exist")
	ASSERT(sys_ini:line_exist(section, "class"), "get_class: there is no 'class' parameter in the section '"..section.."'")
	return sys_ini:r_clsid(section, "class")
end

-- делит строку в виде "aaa,bbb,ccc" на строки "aaa", "bbb", "ccc" и возвращает их в виде массива
function split_comma_separated_list(s)
	return string.explode(",", s)
end

-- читает время, сохранённое в виде строки со значениями, разделёнными запятой, и конвертирует в значение класса CTime
function unpack_time_from_string(str_time)
	local time_values = {}
	for i,s in ipairs(split_comma_separated_list(str_time)) do
		local value = tonumber(s)
		ASSERT(value, "unpack_time_from_string: problem with unpacking saved time '%s', value #%d (%s)", str_time, i, s)
		table.insert(time_values, value)
	end
	ASSERT(#time_values == 7, "unpack_time_from_string: packed time '%s' has wrong number of components. Must be equal to seven.")
	local res = game.CTime()
	res:set(unpack(time_values))
	return res
end

-- упаковать время в виде объекта CTime в строку значений, разделённых запятой
function pack_time_to_string(t)
	ASSERT(t, "pack_time_to_string: t is a nil reference")
	return table.concat({t:get()}, ',')
end

-- читает строку вида "s1,s2,s3" и парсит на строковые значения, разделённые запятой, в таблицу вида {s1, s2, s3}
function get_names(section, param, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_names: section '"..section.."' doesn't exist")
	local s = ini:r_string(section, param)
	return split_comma_separated_list(s)
end

-- читает строку вида "s1,s2,s3" и парсит на численные значения, разделённые запятой, в таблицу вида {n1, n2, n3}
function get_numbers(section, param, ini_file)
	local t = {}
	for i,sv in ipairs(get_names(section, param, ini_file)) do
		local v = tonumber(sv)
		ASSERT(v, "get_numbers: can not convert to number item ["..i.."]: "..sv)
		table.insert(t, v)
	end
	return t
end

function get_section_keys(section, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_section_keys: section '"..section.."' doesn't exist")
	local t = {}
	for i=0,ini:line_count(section)-1 do
		local _, key, v = ini:r_line(section, i)
		t[i+1] = key
	end
	return t
end

function get_section_keys_and_values( section, ini_file )
  local ini = ini_file or sys_ini
  ASSERT( ini:section_exist( section ), "get_section_keys: section '" .. section .. "' doesn't exist" )
  local t = {}
  for i = 0, ini:line_count( section ) - 1 do
  local _, key, v = ini:r_line( section, i, "", "" )
    t[ key ] = v
  end
  return t
end

function get_vector(section, param, def_val, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_vector: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		local pos = get_names(section, param, ini)
		return vector():set(tonumber(pos[1]), tonumber(pos[2]), tonumber(pos[3]))
	else 
		if def_val then
			return def_val
		else
			return vector():set(0,0,0)
		end
	end
end

-- значение по умолчанию должно задаваться таблицей {num1, num2}
function get_vector2(section, param, def_val, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_vector2: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		local pos = get_names(section, param, ini)
		return tonumber(pos[1]), tonumber(pos[2])
	else
		return def_val and unpack(def_val)
	end
end

-- Берём параметры иконки из конфигов
function get_inventory_icon_rect(sect)
	return 50*sys_ini:r_u32(sect, "inv_grid_x"), 50*sys_ini:r_u32(sect, "inv_grid_y"), 50*sys_ini:r_u32(sect, "inv_grid_width"), 50*sys_ini:r_u32(sect, "inv_grid_height")
end
-- получить номер локации по номеру глобального вертекса
function location_id_by_gvid(gvid)
	if gvid and game_graph():valid_vertex_id( gvid ) then
		return game_graph():vertex( gvid ):level_id()
	end
end
-- получить номер локации для клиентского объекта
function object_location_id(obj)
	local gvid = obj.game_vertex_id and obj:game_vertex_id() or obj.m_game_vertex_id
	return location_id_by_gvid(gvid)
end
function object_level_name(obj)
	local lid = object_location_id( obj )
	if lid then
		return level_system_name_by_lid( lid )
	end
end
function level_system_name_by_lid(lid)
	if lid then
		return alife():level_name( lid )
	end
end
function level_name_by_level_system_name(lname)
	return game.translate_string(lname)
end
--системное имя уровня
function level_system_name_by_gvid(gvid)
	return level_system_name_by_lid(location_id_by_gvid(gvid))
end
--Внятное имя уровня (не системное, а то, которое изображается на карте):
function level_name_by_gvid(gvid)
	return level_name_by_level_system_name(level_system_name_by_gvid(gvid))
end

--***********************************[Функции для вывода в лог]****************************************
-----------------------------------------------------------------------------------------
local tostring_all_tbl = {
	["table"] =		function(table, ind) --Распечатка таблиц
						local res = "{" --Начало
						local end_res = ind and "\n"..ind.."}" or "\n}" --Конец
						local def_ind = "  " --Отступ от начала строки
						ind = ind and ind..def_ind or def_ind --Для каждой "таблицы внутри таблицы" отступ увеличивается в 2 раза
						if isArray(table) then --Если это массив, обрабатываем только значения:
							for i=1, #table do --Это актуально только для отслеживания nil-аргументов в таблицах. В будущем, при переезде на новый jit, это надо бы убрать.
								res = res.."\n"..ind..tostring_all(table[i], ind)..","
							end
						else --Если НЕ массив, обрабатываем и ключи, и значения:
							for k, v in pairs(table) do
								res = res.."\n"..ind.."["..tostring_all(k, ind).."] = "..tostring_all(v, ind)..","
							end
						end
						return res..end_res
					end,
	["string"] =	function(v) return "'"..v.."'" end, --Строки берём в кавычки. Это нужно, чтобы можно было отличить строку "123" от числа 123, "nil" от nil и тд...
	["number"] =	function(v) return tostring(v) end,
	["boolean"] =	function(v) return tostring(v) end,
	["nil"] =		function(v) return tostring(v) end,
	["function"] =	function() return "[[FUNCTION]]" end, --Function, Userdata и Thread распечатать нельзя, просто заменим на строки
	["userdata"] =	function() return "[[USERDATA]]" end,
	["thread"] =	function() return "[[THREAD]]" end,
}
--Конвертирование чего угодно в строку. Использовать только для вывода в лог!
function tostring_all(obj, ind) --ind - служебный аргумент для распечатки "таблиц в таблицах". НЕ ТРОГАТЬ ЕГО!!!
	return tostring_all_tbl[type(obj)](obj, ind)
end

--В связи с добавлением функции вывода произвольного текста в лог, стала доступна возможность выделять этот текст различными цветами.
--После спец-символа цвета обязательно должен быть один пробел (или любой другой символ), иначе строка будет выведена обрезанной.
local subs_tbl = { --Спец-символы цветов:
	["-"] = true, --Зелёный
	["~"] = true, --Жёлтый
	["!"] = true, --Красный
	["*"] = true, --Серый
	["#"] = true, --Бирюзовый
}
--Функциональная обёртка для log1.
--Делает дополнительную работу по конвертации параметров, которые не воспринимаются родной функцией string.format.
--Параметры можно передавать ЛЮБОГО ТИПА! В строке формата они должны стоять как %s (потому, что будут сконвертированы в строки).
function log3(fmt, ...)
	local args = {...}
	for i=1, #args do --Для корректной обработки nil-аргументов (циклы pairs и ipairs останавливаются на первом _значении_ nil)
		args[i] = tostring_all(args[i])
	end
	local res, msg = pcall(string.format, fmt, unpack(args))
	--
	--if res then msg = msg.."\nlog3 called from: "..debug.traceback() end
	--
	if not res then --Если произошла ошибка
		msg = "!!log3 failed: "..msg.."\n"..debug.traceback()
	end
	local subs = msg:sub(1, 1)
	local color = subs_tbl[subs] and subs.." " or false
	local not_first_line = false
	for s in msg:gmatch("([^\n]+)") do --Разбиваем текст на разделённые строки. Нужно для того, чтобы избежать ограничения в 1024 символа, после которых log1 просто обрезает текст.
		log1((not_first_line and color) and color..s or s) --Если надо, перед каждой строкой вставляем спец-символ цвета, чтобы цветными были все строки текста, а не только первая.
		not_first_line = true
	end
end
-----------------------------------------------------------------------------------------
log3("%s", debug.traceback()) --Помогает определить, из за чего в некоторых случаях перезагружается _G
-----------------------------------------------------------------------------------------
local logs_cach = {}
--Функция создаёт новый лог-файл и выводит текст в него.
--fname - название лог-файла, например "Anomaly_Evader". Он будет создан в папке logs, к названию добавится дата и время создания.
--fmt, ... - строка формата с параметрами как и в функции log3
function log4(fname, fmt, ...)
	local f = logs_cach[fname]
	if not f then
		local dt = os.date("*t")
		local fpath = getFS():update_path("$logs$", string.format("%s_%02d.%02d.%02d_%02d.%02d.%02d.log",fname,dt.day,dt.month,dt.year,dt.hour,dt.min,dt.sec))
		f = io.open(fpath, "w")
		logs_cach[fname] = f
	end
	local args = {...}
	for i=1, #args do
		args[i] = tostring_all(args[i])
	end
	local res, msg = pcall(string.format, fmt, unpack(args))
	if not res then
		msg = "!!log4 failed: "..msg.."\n"..debug.traceback()
	end
	f:write(msg..'\n')
	f:flush()
end
-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------
function log2(fmt, ...) --Простая обёртка для log1.
	log1(fmt:format(...))
end
-----------------------------------------------------------------------------------------
function clear_log() --Очистить лог
	cmd("clear_log")	
end
-----------------------------------------------------------------------------------------
--*****************************************************************************************************

--[=[ --KRodin: не используется. Да и вообще лучше использовать метод get_weight() у инвентарных объектов.
function get_item_weight_by_section(section)
	local res = get_float(section, "inv_weight")
	ASSERT(res, "get_item_weight_by_section: there is no 'inv_weight' parameters in section '"..section.."'")
	return res
end

function get_ammo_weight_by_section(section, count)
	local box_weight = get_item_weight_by_section(section)
	local box_size = get_int(section, "box_size", 0)
	ASSERT(box_size > 0, "get_ammo_weight_by_section: 'box_size' parameters in section '"..section.."' is zero or missed")
	return box_weight * count / box_size
end
--]=]

function print_vector(name, v)
	log2("%s: %9.3f, %9.3f, %9.3f", name, v.x, v.y, v.z)
end
function print_matrix(name, m)
	log1(name..":")
	log2("[%9.3f, %9.3f, %9.3f, %9.3f]", m.i.x, m.i.y, m.i.z, m._14_)
	log2("[%9.3f, %9.3f, %9.3f, %9.3f]", m.j.x, m.j.y, m.j.z, m._24_)
	log2("[%9.3f, %9.3f, %9.3f, %9.3f]", m.k.x, m.k.y, m.k.z, m._34_)
	log2("[%9.3f, %9.3f, %9.3f, %9.3f]", m.c.x, m.c.y, m.c.z, m._44_)
end
function time2string(time, fmt, order)
	ASSERT(time, "[_g.time2string] 'time' is a nil reference")
	local a,b = time:get_value()
	if not fmt then
		return time:timeToString(game.CTime.TimeToMilisecs).." "..time:dateToString(game.CTime.DateToDay)..string.format(" [%04x %04x]", a,b)
	else
		local y,m,d,h,min,s,ms = time:get()
		local args = {y=y,m=m,d=d,h=h,min=min,s=s,ms=ms,a=a,b=b}
		if order then
			args = {args[order[1]], args[order[2]], args[order[3]], args[order[4]], args[order[5]], args[order[6]], args[order[7]], args[order[8]], args[order[9]]}
		end
		return fmt:format(unpack(args))
	end
end
function print_time(title, time)
	log1(title..": "..time2string(time))
end


function hit_object(obj, dir, imp, dr, pow, t)
	local h = hit()
	h.direction = dir
	h.impulse = imp
    h.draftsman = dr
	h.power = pow
	h.type = t
	obj:hit(h)
end

function hit_object_ex(hit_params)
	local h = hit()
	ASSERT(hit_params.obj, "hit_object_ex: target is not defined! 'obj' field is a nil reference")
	h.direction = hit_params.dir or vector():set(1,0,0)
	h.impulse = hit_params.imp or 0
    h.draftsman = hit_params.dr or hit_params.obj
	h.power = hit_params.pow or 0
	h.type = hit_params.t or 0
	h.bone = hit_params.bone or ""
	hit_params.obj:hit(h)
end

--/Нанести хит

function hit_obj_by_id_simple(ObjId, Pwr, iImpulse)
	local obj2hit = level.object_by_id(ObjId)
	ASSERT(obj2hit, "[hit_obj_by_id_simple] no object found for id = %d", ObjId)
	local hit_params = {
		["t"] = hit.explosion, 
		["dir"] = vector():set(0, 0, 0),
		["dr"] = obj2hit,
		["obj"] = obj2hit,
		["imp"] = iImpulse,
		["pow"] = Pwr,
	}
	hit_object_ex(hit_params)
end


function seconds2ctime(time_sec)
	local s,ms = math.modf(time_sec)
	local t = game.CTime()
	t:setHMSms(0,0,s,ms*1000)
	return t
end

-- надёжнее, чем device().aspect_ratio, поскольку не зависит от инициализированности рендера
-- однако медленная. Не рекомендуется использовать часто
function get_aspect_ratio()
	local s =  get_con_string("vid_mode")
	local sw,sh = string.match(s, "(%d+)x(%d+)")
	return tonumber(sh)/tonumber(sw)
end
----------------------------------------------------------------------
-- Работа с актором
----------------------------------------------------------------------
-- константы для функций get_actor_flags и set_actor_flags
actor_flags = {
	invincible     =  1,
	invisible      =  2, -- useless
	always_run     =  4,
	unlimited_ammo =  8,
	run_backward   = 16,
	autopickup     = 32,
	psp            = 64, -- вид от третьего лица
}
function set_actor_invincible(invincible)
	local flags = get_actor_flags()
	local mask = actor_flags.invincible
	set_actor_flags(invincible and bit_or(flags, mask) or bit_and(flags, bit_not(mask)))
end

-- получение некоторых значений с плавающей запятой
-- параметры бега
function get_walk_accel()         return db.actor:get_actor_float(1440) end
function get_jump_speed()         return db.actor:get_actor_float(1444) end
function get_run_factor()         return db.actor:get_actor_float(1448) end
function get_run_back_factor()    return db.actor:get_actor_float(1452) end
function get_walk_back_factor()   return db.actor:get_actor_float(1456) end
function get_crouch_factor()      return db.actor:get_actor_float(1460) end
function get_climb_factor()       return db.actor:get_actor_float(1464) end
function get_sprint_factor()      return db.actor:get_actor_float(1468) end
function get_walk_strafe_factor() return db.actor:get_actor_float(1472) end
function get_run_strafe_factor()  return db.actor:get_actor_float(1476) end
-- параметры стрельбы
function get_disp_base()          return db.actor:get_actor_float(1484) end -- в радианах
function get_disp_aim()           return db.actor:get_actor_float(1488) end -- в радианах
function get_disp_vel_factor()    return db.actor:get_actor_float(1492) end
function get_disp_accel_factor()  return db.actor:get_actor_float(1496) end
function get_disp_crouch_factor() return db.actor:get_actor_float(1500) end
function get_disp_crouch_no_accel_factor()  return db.actor:get_actor_float(1504) end
-- получение некоторых целых и логических значений
-- режим прицеливания
function zoom_mode() return bit_and(db.actor:get_actor_int(nil, 1480), 1) ~= 0 end -- возвращает true/false

-- установка некоторых значений
-- параметры бега
function set_sprint_factor(v)      db.actor:set_actor_float(nil, v, 1468) end
function set_jump_speed(v)         db.actor:set_actor_float(nil, v, 1444) end
function set_walk_accel(v)         db.actor:set_actor_float(nil, v, 1440) end
function set_run_factor(v)         db.actor:set_actor_float(nil, v, 1448) end
function set_run_back_factor(v)    db.actor:set_actor_float(nil, v, 1452) end
function set_walk_back_factor(v)   db.actor:set_actor_float(nil, v, 1456) end
function set_crouch_factor(v)      db.actor:set_actor_float(nil, v, 1460) end
function set_climb_factor(v)       db.actor:set_actor_float(nil, v, 1464) end
function set_walk_strafe_factor(v) db.actor:set_actor_float(nil, v, 1472) end
function set_run_strafe_factor(v)  db.actor:set_actor_float(nil, v, 1476) end
-- параметры стрельбы
function set_disp_base(v)          db.actor:set_actor_float(nil, v, 1484) end -- в радианах

function set_jump_power( v ) db.actor:set_actor_condition_float( nil, v, 276 ) end

function set_stand_power( v ) db.actor:set_actor_condition_float( nil, v, 280 ) end -- скорость восстановления выносливости

local body_states = { -- флажки состояния тела актора
[1]		= "fwd",
[2]		= "back",
[4]		= "l_strafe",
[8]		= "r_strafe",
[16]	= "crouch",
[32]	= "accel",
[64]	= "turn",
[128]	= "jump",
[256]	= "fall",
[512]	= "landing",
[1024]	= "landing2",
[2048]	= "climb",
[4096]	= "sprint",
[8192]	= "l_lookout",
[16384]	= "r_lookout"
}
-- получения флагов состояния тела актора
function actor_body_state()
	local body_state = body_states[db.actor:get_actor_int(nil, 1432)]
	if body_state ~= nil then
		return body_state
	else
		return ""
	end
end
-- установка флагов состояния тела актора
function set_actor_body_state(flags_to_set, value)
	local current_flags = db.actor:get_actor_int(nil, 1432)
	local new_flags = value and bit_or(current_flags, flags_to_set) or bit_and(current_flags, bit_not(flags_to_set))
	db.actor:set_actor_int(1432, new_flags)
end
local anomaly_invisibility_flag = tonumber("80000000", 16)
-- установка невидимости сталкера со стороны аномалий
function set_anomaly_invisibility(npc, vis)
	local fl = npc:get_actor_relation_flags()
	fl:set(anomaly_invisibility_flag, vis)
	npc:set_actor_relation_flags(fl)
end
-- получение статуса невидимости сталкера со стороны аномалий
function get_anomaly_invisibility(npc)
	local fl = npc:get_actor_relation_flags()
	return fl:test(anomaly_invisibility_flag)
end


function get_day_time_sec(t)
	local y,m,d,h,min,s,ms = t:get()
	return h * 3600.0 + min * 60.0 + s + ms * 1e-3
end

-- получить текушее игровое время от начала суток, измеренное в часах (значение в пределах [0, 24) )
function get_game_day_time_h()
	local gt = game.get_game_time()
	local y,m,d,h,min,sec,ms = gt:get()
	return math.fmod(h + min/60.0 + (sec + 0.001*ms)/3600.0, 24.0)
end

function relation_registry.get_goodwill(who_id, to_whom_id)
	return GetGoodwill(who_id, to_whom_id)
end

function relation_registry.set_goodwill(who_id, to_whom_id, goodwill)
	ASSERT(db.actor, "relation_registry.set_goodwill: cannot call function")
	return db.actor:set_goodwill_ex(who_id, to_whom_id, goodwill)
end

function relation_registry.change_goodwill(who_id, to_whom_id, goodwill_change)
	ASSERT(db.actor, "relation_registry.change_goodwill: cannot call function")
	return db.actor:change_goodwill_ex(who_id, to_whom_id, goodwill_change)
end

-- флаги трассировки
rq_target = {
	rqtNone,
	rqtObject   = 1,
	rqtStatic   = 2,
	rqtShape    = 4,
	rqtObstacle = 8,
	rqtBoth     = 3, -- rqtObject + rqtStatic
	rqtDyn      = 13, -- rqtObject + rqtShape + rqtObstacle
}

ray_pick = {}
-- устанавливает базовые параметры трассировки
function ray_pick.init(pos_from, dir, range, flags, ignore_obj)
	ray_pick.set_pos(pos_from)
	ray_pick.set_dir(dir)
	ray_pick.set_range(range)
	ray_pick.set_flags(flags)
	ray_pick.set_object_to_ignore(ignore_obj)
end

-- устанавливает стартовую точку трассировки
function ray_pick.set_pos(pos)
	--print_vector("pos", pos)
	db.actor:set_vector_global_arg_2(pos)
end
-- устанавливает направление трассировки
function ray_pick.set_dir(dir)
	--print_vector("dir", dir)
	db.actor:set_vector_global_arg_1(dir)
end
-- устанавливает диапазон трассировки
function ray_pick.set_range(range)
	--log2("range: %7.2f", range)
	set_float_args_12(range, 0)
end
-- устанавливает флаги трассировки (rq_target)
function ray_pick.set_flags(flags)
	--log2("flags: %x", flags)
	set_int_arg1(flags)
end
-- устанавливает игнорируемый игровой объект для трассировки
function ray_pick.set_object_to_ignore(obj)
	db.actor:set_object_arg_1(obj)
end
-- выполняет запрос на трассировку и возвращает true, если она была успешна
function ray_pick.check()
	return level.perform_ray_pick_query()
end

-- если трассировка была успешна, возвращает дистанцию до точки, иначе возвращает ранее заданный диапазон трассировки
function ray_pick.get_dist()
	return level.get_ray_pick_dist()	
end

-- если трассировка была успешна, возвращает игровой объект
function ray_pick.get_obj()
	return level.get_ray_pick_obj()
end
-- если луч пересек игровой объект, то возвращает номер кости, иначе возвращает номер полигона статической геометрии (при неудачной трассировке возвращает -1)
function ray_pick.get_element()
	return level.get_ray_pick_element()
end


function is_16_9_mode()
	local dev = device()
	return dev.width / dev.height > 1.34
end

-- выравнивание значения n в пределы от min до max
math.clamp = function( n, min, max )
	if min>max then min,max=max,min end
	return (n>max and max) or (n<min and min) or n
end

-- округление к ближайшему
function math.round(v)
	return math.floor(v + 0.5)
end

function math.lerp(x1, x2, y1, y2, x)
	return (x - x1) * (y2 - y1) / (x2 - x1)
end

function math.similar(a1, a2, tol)
	return math.abs(a1 - a2) <= tol
end

-- смещения полей в структуре SHit, т.е. параметры хита
hit_offset = {
  Time              = 0,  -- 4, insigned int
  PACKET_TYPE       = 4,  -- 2, insigned short
  DestID            = 6,  -- 2, insigned short
  power             = 8,  -- 4, float 
  dir_x             = 12, -- 4, float
  dir_y             = 16, -- 4, float
  dir_z             = 20, -- 4, float
  who               = 24, -- 4, pointer
  whoID             = 28, -- 2, insigned short
  weaponID          = 30, -- 2, insigned short
  boneID            = 32, -- 2, insigned short
  -- 2 байта на выравнивание
  p_in_bone_space_x = 36, -- 4, float
  p_in_bone_space_y = 40, -- 4, float
  p_in_bone_space_z = 44, -- 4, float
  impulse           = 48, -- 4, float
  hit_type          = 52, -- 4, unsigned int (ALife::EHitType)
  ap                = 56, -- 4, float
  aim_bullet        = 60, -- 1, bool
  -- 3 байта на выравнивание
  BulletID          = 64, -- 2, unsigned int
  SenderID          = 66, -- 2, unsigned int
}

-- коды дополнительных колбеков
callback_ex = {
	["on_key_press"]				= 123,
	["on_key_release"]				= 124,
	["on_key_hold"]					= 125,
	["on_mouse_wheel"]				= 126,
	["on_mouse_move"]				= 127,

	["on_belt"]						= 130,
	["on_ruck"]						= 131,
	["on_slot"]						= 132,
	["on_select_item"]				= 133,
	["on_create_cell_item"]			= 136,

	["attach_vehicle"]				= 137,
	["use_vehicle"]					= 138,
	["detach_vehicle"]				= 139,

	["on_after_save"]				= 140,

	["on_goodwill_change"]			= 145,
	["on_release_npc"]				= 146,

	["on_inv_box_put_item"]			= 151,
	["entity_alive_before_hit"]		= 152,
	["dbg_gg_distance_failed"]		= 153,
	["update_addons_visibility"]	= 154,
	["update_hud_addons_visibility"]= 155,
	["on_before_use_item"]			= 156;
	["on_hud_animation_end"]		= 157,
	["init_addons"]					= 158,

	["pda_contact"]					= 180,
}

inventory_item_offsets = {
	["health_influence"]	= 220,
	["power_influence"]		= 224,
	["satiety_influence"]	= 228,
	["radiation_influence"]	= 232,
	["power_max_influence"]	= 236,
	["wound_heal"]			= 240,
	["alcohol_influence"]	= 688,
}
-- обнуление всех эффектов съедаемого предмета
-- изменённые значения в сейве не сохраняются
-- функция предназначена в основном для использования в событии предиспользования,
-- когда эффекты предмета ещё не применены и их можно изменить, что повлияет на собственно эффект от 
-- предмета на параметры здоровья, радиации и т.п.. При этом подразумевается,
-- что предмет после использования будет удалён, поэтому вопрос о сохранении этих свойств не стоит
-- если используется подход с eat_portions_num > 1 (обычно задаётся "бесконечное" значение, типа 10000),
-- то эту функцию либо использовать нельзя, либо надо таким же образом восстанавливать свойства предмета
-- в событии использования (стандартный колбек callback.use, который в сущности является колбеком на 
-- "послеиспользование", когда эффекты предмета уже применены)
function zero_all_item_effects(item)
	ASSERT(item:is_eatable_item(), "")
	for param, offset in pairs(inventory_item_offsets) do
		-- параметр влияния алкоголя годится только для объекта-бутылки
		if param ~= "alcohol_influence" or item:is_bottle_item() then
			item:set_inventory_item_float(nil, 0.0, offset)
		end
	end
end
-- набор констант для использования в колбеках на использование и предиспользование инвентарных предметов
-- константы сигналят, что надо делать с предметом после его обработки: 
--     удалить, создать его дубликат, не делать ничего
-- это надо для упорядочения работы с инвентарными предметами при разных подходах использования eat_portions_num
-- если eat_portions_num = 1 или -1, то предмет одноразовый. В этом случае, если мы хотим "сохранить" предмет
-- в инвентаре, то возвращаем post_use_action.create_new_item, в противном случае возвращаем post_use_action.do_nothing
-- если же используем подход с eat_portions_num = "бесконечность", то как раз при использовании сигналим
-- вызвавшему коду, что предмет надо удалить, т.е. возвращаем post_use_action.delete_item, в противном случае просто оставляем
-- предмет в покое (возвращаем post_use_action.do_nothing).
-- P.S.: Этот подход архитектурно не навязан. Используется по желанию. Константы вынесены сюда на тот случай,
-- если кто-то захочет использовать такую же организацию кода
post_use_action = {
	do_nothing = 0,
	delete_item = 1,
	create_new_item = 2,
}

-- установка направления взгляда актора в заданную точку
function actor_look_at_point(target_point)
	ASSERT(target_point, "actor_look_at_point: target point vector is a nil reference!")
	local look_dir = vector():sub(target_point, device().cam_pos)
	local h = look_dir:getH()
	local p = look_dir:getP()
	db.actor:set_camera_direction(vector():set(-h,-p,0))
end

local con = get_console()

function cmd(scmd, ...)
	ASSERT(scmd, "[cmd] scmd is a nil reference")
	local args = {...}
	if #args > 0 then
		scmd = scmd..' '..table.concat(args, ' ')
	end
	con:execute(scmd)
end

function get_con_float(param)
	return con:get_float(param)
end
function get_con_string(param)
	return con:get_string(param)
end
function get_con_bool(param)
	return con:get_bool(param)
end

-- проверка сушествования файла на диске
-- примечания: 
-- 1. это  для проверки существования реального файла, не в архиве
-- 2. способ неуклюжий, но другого в чистом Lua нет
function file_exists(name)
	local f = io.open(name,"r")
	if f then
		f:close()
		return true
	end
	return false
end


-- Управление торгуемостью и группировкой предметов в инвентаре
ii_flags = {
	drop_manual         = 1,
	can_take            = 2,
	can_trade           = 4,
	belt                = 8,
	ruck                = 16,
	ruck_default        = 32,
	using_condition     = 64,
	allow_sprint        = 128,
	useful_for_npc      = 256,
	in_interpolation    = 512,
	in_interpolate      = 1024,
	is_quest_item       = 2048,
	-- extra flags added in x-ray extensions
	always_tradable     = 4096,
	always_untradable   = 8192,
	ungroupable         = 16384,
	manual_highlighting = 32768,
}

ext_ii_flags = {
	actor_can_take         = 1,
}

function set_ext_ii_flags(item, mask, value)
	item:set_inventory_item_int16(134, flags16():assign(item:get_inventory_item_int16(nil, 134)):set(mask, value):get())
end

function set_item_forbidden_to_actor(item)
	set_ext_ii_flags(item, ext_ii_flags.actor_can_take, true)
end

function mark_grenade_non_pickable(id, item)
	set_item_forbidden_to_actor(item)
end

-- вспомогательная функция для установки флагов в классе CInventoryItem
function set_ii_flags(item, mask, value)
	item:set_inventory_item_int16(132, flags16():assign(item:get_inventory_item_int16(nil, 132)):set(mask, value):get())
end
-- вспомогательная функция для установки флагов в классе CInventoryItem
function set_ii_custom_color_ids(item, col_idx)
	ASSERT(col_idx >=0 and col_idx <=15, "[set_ii_custom_color_ids] col_idx must be in the range [0-15]")
	local fl = bit_or(bit_and(item:get_inventory_item_int16(nil, 134), 65520), col_idx)
	item:set_inventory_item_int16(134, fl)
end
-- сделать предмет безусловно негруппируемым в окнах инвентаря
function set_item_ungroupable(item)
	set_ii_flags(item, ii_flags.ungroupable, true)
end
-- включить движковую группировку для предмета
function set_item_default_grouping(item)
	set_ii_flags(item, ii_flags.ungroupable, false)
end
-- сделать предмет безусловно продаваемым
function set_item_always_tradable(item)
	set_ii_flags(item, ii_flags.always_tradable, true)
end
-- сделать предмет безусловно непродаваемым, будет показан красным. Для избежания глюков надо также
-- выключать группируемость для этого предмета
function set_item_always_untradable(item)
	set_ii_flags(item, ii_flags.always_tradable, false)
	set_ii_flags(item, ii_flags.always_untradable, true)
end
-- включить движковую торгуемость для предмета
function set_item_tradable(item, value)
	set_ii_flags(item, ii_flags.can_trade, true)
end
-- выключить движковую торгуемость для предмета
function set_item_untradable(item, value)
	set_ii_flags(item, ii_flags.can_trade, false)
end
-- убрать принудительную тогумеость или неторгуемость и оставить только двидковый алгоритм
function set_item_default_tradability(item)
	set_ii_flags(item, ii_flags.always_tradable + ii_flags.always_untradable, false)
end
-- включить для предмета явную раскраску кастомным цветом
function set_item_always_highlighted(item)
	set_ii_flags(item, ii_flags.manual_highlighting, true)
end
-- использовать только движковую раскраску
function set_item_default_highlighting(item)
	set_ii_flags(item, ii_flags.manual_highlighting, false)
end

-- сбросить торгуемость для всех предметов в инвентаре актора
function reset_actor_items_tradability()
	for i = 0, db.actor:object_count() - 1 do
		set_item_default_tradability(db.actor:object(i)) 
	end
end


-- возвращает колличество патрон в пачке
-- http://www.amk-team.ru/forum/index.php?showtopic=10538&p=713968
function get_ammo_size(obj)
	return obj:get_go_int16( "", 476 )
end
--Задать кол-во патронов в пачке
function set_ammo_size(item, size)
	item:set_go_int16(476, size)
end


function get_inv_item_slot( obj )
	return obj:get_inventory_item_int( nil, 156 )
end
function set_inv_item_slot( obj, slot )
	obj:set_inventory_item_int( 156, slot )
end


-- http://www.amk-team.ru/forum/index.php?showtopic=6185&p=945289
weapon_states = {
  idle      = 0,
  fire      = 1,
  fire2     = 2,
  reload    = 3,
  showing   = 4,
  hiding    = 5,
  hidden    = 6,
  misfire   = 7,
  mag_empty = 8,
  switch    = 9
}
--[[ --Пример использования:
local state = db.actor:active_item():get_hud_item_state()
if state == weapon_states.reload then
...
end
--]]


-- http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=1002890
function normal_triangle( element ) -- возвращает нормаль треугольника, аргументом передавать элемент геометрии (который можно получить, например, функцией level.get_target_element() или ray_pick.get_element())
  local n = vector()
  local a = level.get_tri_vertex1( element ) --возвращает первую вершину статического треугольника.
  local b = level.get_tri_vertex2( element ) --возвращает вторую вершину статического треугольника.
  local c = level.get_tri_vertex3( element ) --возвращает третью вершину статического треугольника.
  n.x = ( ( b.z - a.z ) * ( c.y - a.y ) ) - ( ( b.y - a.y ) * ( c.z -a.z ) )
  n.y = ( ( b.x - a.x ) * ( c.z - a.z ) ) - ( ( b.z - a.z ) * ( c.x -a.x ) )
  n.z = ( ( b.y - a.y ) * ( c.x - a.x ) ) - ( ( b.x - a.x ) * ( c.y -a.y ) )
  return n:normalize()
end


--[=[
От Malandrinus отсюда: http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=1006978

Проиграть произвольную анимацию худовой модели:

db.actor:set_hud_animation_channel(2)
db.actor:set_use_hud_animation_callback(true)
db.actor:set_hud_animation_callback_param(12345)
wpn:play_hud_animation("reload", true)

Колбек на окончание анимации вызывается для актора, код колбека 157.
В колбек передаётся один целый аргумент - то число, которое было установлено
вызовом db.actor:set_hud_animation_callback_param(<целое число>).
Так можно в колбеке различать, какая именно анимация закончилась.

uint<remaining_time> get_hud_animation_remaining_time() - возвращает время в миллисекундах, оставшееся до окончания текущей анимации.
int<length> get_hud_animation_length(string<anim_name>) - оставшееся время до окончания НЕ зацикленной анимации, меняется в реальном времени. Т.е. в начале, например твоей перезарядки метод вернет 2541, а в конце 0 (анимация закончена). Для зацикленных анимаций, НЕимеющих флаг Stop At End (idle, sprint и т.п.), всегда возвращает 0, т.к. они не имеют конца.
bool<is_cyclic> is_cyclic_hud_animation() - возвратит true, если текущая анимация зациклена.
bool<has_anim> has_hud_animation(string<anim_name>) - возвратит true, если анимация есть в модели.
--]=]

--[=[
http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=701404
Вот пример получения/записи значений для объекта актора.

db.actor:set_actor_shared_str("test", 1392)
local sss = {
    1392,
    1396,
    1400,
    1404,
    1408,
    1412,
}
for _, s1 in ipairs(sss) do
    set_int_arg0(s1)
    local s = db.actor:get_actor_shared_str()
    log1(""..s1.." "..s)
end
--]=]


-- возвращает имя кости по ее индексу
-- http://xray-engine.org/index.php?title=X-Ray_extensions
function get_bone_name_by_id( obj, bone_id )
  set_int_arg0( bone_id )
  return obj:get_bone_name()
end


-- возвращает level_vertex_id по позиции на уровне
function level.vertex_id_by_pos( position )
  db.actor:set_vector_global_arg_1( position )
  return level.vertex_id( position )
end


-- запускает эффектор шатания камеры с заданными параметрами
function level.add_cam_effector3( total_time, amplitude, period_number, power )
  level.set_ce_time( total_time )
  level.set_ce_amplitude( amplitude )
  level.set_ce_period_number( period_number )
  level.set_ce_power( power )
  level.add_ce()
end
