--************************************************* Инициализация расширений движка ************************************************
log1("--...Инициализация расширений движка...")

RvP()

--[[
pairs_old = pairs
pairs = function(t)
     if not t or type(t)~="table" then
          log1("!! error, try to call 'pairs' with " .. tostring(t) .. " param")
          log3(debug.traceback())
          return
     end
     return pairs_old(t)
end
]]


if type(SetLog) == "function" and os and os.clock() < 30 then
	local name = getFS():update_path("$logs$", "_ogse.log")
	SetLog(name)
	log1("--SetLogCallback to file " .. name)
end

local dir 		= "$fs_root$"
local ext_path 	= "bin\\extensions"
local path  	= getFS():update_path(dir, ext_path)

package.cpath = package.cpath..";"..path.."\\?.dll"

local function IsDll(fname)
	return fname:sub(-4) == ".dll"
end

if type(init_external_libs) == "function" then
	init_external_libs()
end

--лучше наверное оставить в главном модуле lfs и грузить им.
if not lfs then
	fail("check lfs namespace")
end
for file in lfs.dir(path) do
	log1("file: "..file)
	if file ~= "." and file ~= ".." then
		if IsDll(file) then
			local mod = file:sub(1, -5)
			log1("--try to load " .. file)
			log1("fname: "..mod)
			local rez, msg = pcall(require, mod)
			if (not(not rez)) then
				log1("~~    loaded")
			else
				log1("!!    error, msg : " .. tostring(msg))
			end
		end
	end
end

if os and os.clock() < 30 then
	log1("~~        _G : os.clock() = " .. tostring(os.clock()) .. "    math.randomseed()")
	math.randomseed(os.time())
end

set_static_rescale_factor(device().height / device().width / 0.75)

-- жуткая затычка для проблемы с большими целыми числами при сложении в Lua
-- родное сложение начинает округлять и терять часть суммы, а функция sum_args
-- при тривиальном использовании в ряде случаев отсекает аргументы со значения 0x80000000
-- здесь сделано так, что этот эффект не происходит. Функция очень медленная,
-- использовать только в связке с функцией получения значения по абсолютному адресу
-- и по возможности вообще избегать.
function sum_args_ex(base, offs)
	local base_s = string.format("%08x", base)
	local b1_s = base_s:sub(1,4)
	--log1(b1_s)
	local b2_s = base_s:sub(5,8)
	--log1(b2_s)
	local b1 = tonumber(b1_s, 16)
	local b2 = tonumber(b2_s, 16)
	local res = sum_args(bit.lshift(b1, 16), sum_args(b2, offs))
	--log2("sum_args_ex: %s, %x, %x", base_s, offs, res)
	return res
end

--Некоторые недостающие DIK_keys:
DIK_keys["DIK_MOUSE1"] = 337
DIK_keys["DIK_MOUSE2"] = 338
DIK_keys["DIK_MOUSE3"] = 339
DIK_keys["DIK_MOUSE4"] = 340
DIK_keys["DIK_MOUSE5"] = 341
DIK_keys["DIK_MOUSE6"] = 342
DIK_keys["DIK_MOUSE7"] = 343
DIK_keys["DIK_MOUSE8"] = 344

--Некоторые недостающие key_bindings:
key_bindings["kSPRINT_TOGGLE"] = 8
key_bindings["kENGINE"] = 15
key_bindings["kARTEFACT"] = 30
key_bindings["kWPN_FIREMODE_PREV"] = 38
key_bindings["kWPN_FIREMODE_NEXT"] = 39
key_bindings["kPAUSE"] = 40
key_bindings["kCHAT_TEAM"] = 45
key_bindings["kACTIVE_JOBS"] = 53
key_bindings["kMAP"] = 54
key_bindings["kCONTACTS"] = 55
key_bindings["kVOTE_BEGIN"] = 57
key_bindings["kVOTE"] = 58
key_bindings["kVOTEYES"] = 59
key_bindings["kVOTENO"] = 60
key_bindings["kSPEECH_MENU_0"] = 63
key_bindings["kSPEECH_MENU_1"] = 64
key_bindings["kUSE_BANDAGE"] = 73
key_bindings["kUSE_MEDKIT"] = 74
key_bindings["kQUICK_SAVE"] = 75
key_bindings["kQUICK_LOAD"] = 76

if not SString_loaded then
	dofile(getFS():update_path("$game_data$","scripts\\_s.script"))
	log1("--SString loaded!")
end
if not luaXML_loaded then
	dofile(getFS():update_path("$game_data$","scripts\\_luaxml.script"))
	log1("--luaXML loaded!")
end

log1("--Инициализация расширений движка закончена!")
--******************************************** Инициализация расширений движка закончена ********************************************

-- FIX Nazgool ------------------------------------------------------------------
-- Возможно подобные функции уже где-то и есть, но я пока не нашёл.

-- Проверки
function isTable   (obj) return type(obj) == 'table'    end
function isBoolean (obj) return type(obj) == 'boolean'  end
function isNumber  (obj) return type(obj) == 'number'   end
function isFunction(obj) return type(obj) == 'function' end
function isString  (obj) return type(obj) == 'string'   end
function isUserdata(obj) return type(obj) == 'userdata' end
function isThread  (obj) return type(obj) == 'thread'   end
function isNil     (obj) return       obj == nil        end -- не false, а именно nil
-- Проверка - пуста ли таблица или строка
-- Если параметр 'space' не nil/false, то строка, состоящая только из пробельных символов и(или) неразрывного пробела будет считаться пустой.
function isEmpty(obj, space)
    if isString(obj) then
        if space then return not obj:match('[^%s\160]+') end
        return #obj == 0
    end
    if isTable(obj) then return next(obj) == nil end
    return false
end
-- является ли таблица массивом
function isArray(tbl)
	local n=0
	for _ in pairs(tbl) do n=n+1 end
    return n <= #tbl
end

-- Приведение значения переменной 'val' к булевому значению
function toBoolean(val)
    return not not val
end

-- CUIScriptWnd Extension ----------------------------------------
local function connect_action(func, ...)
    local arg = {...}
    return  function (obj) func(obj, unpack(arg)) end
end

-- Что бы не оборачивать в функцию для передачи аргументов.
-- Вызов обычный, как и в AddCallback, но после последнего аргумента можно передавать множество дополнительных
function CUIScriptWnd:Connect(name, event, func, obj, ...)
    self:AddCallback(name, event, connect_action(func, ...), obj)
end
------------------------------------------------------------------
-- путь к динамическому XML файлу
DYN_XML_SAVE_PATH = getFS():update_path('$game_config$', 'ui\\')..'ui_dynamic.xml'

-- END FIX  Nazgool --------------------------------------------------------------

excluded_restrictors = {
		["agr_factory_skirmish_defence"] = true,
		["pri_followers_wave1_out_restr"] = true,
		["pri_followers_wave2_out_restr"] = true,
		["pri_followers_wave3_out_restr"] = true,
		["pri_followers_wave4_out_restr"] = true,
		["pri_followers_wave5_out_restr"] = true,
		["pri_followers_wave6_out_restr"] = true,
		["pri_followers_wave7_out_restr"] = true,
		["agr_nii_sr_building"] = true,
		["agr_nii_3_floor"] = true,
		["agr_nii_space_restrictor"] = true,
		["agr_factory_skirmish"] = true,
		["mil_freedom_gulag_defense_res"] = true,
		["yantar_bunker_space_restrictor"] = true,
		["val_lager_bandits_nedostroyka_restrictor"] = true,
		["val_lager_bandits_main_side_restrictor"] = true,
		["val_lager_bandits_main_building_restrictor"] = true,
		["pri_monolith_kolos_restr"] = true,
		["pri_monolith_base_restr"] = true,
		["sar_patrol_restrictor"] = true,
		["rad_tramplin_sniper_restrictor"] = true,
		["bar_arena_restrictor"] = true
	}

----------------------------------------------------------------------

schemes = {} -- соответствие схем модулям
stypes = {} -- типы схем

--/ Загружает схему из файла на диске и активирует в мотиваторе.
--/ Здесь:
--/  filename - имя файла, в котором реализована схема, без расширения
--/  scheme - имя схемы
function load_scheme(filename, scheme, stype)
	schemes[scheme] = filename
	stypes[scheme] = stype
end

----------------------------------------------------------------------

--TODO: Поотрывать вызовы и удалить!
function printf(fmt,...)
end
--TODO: Поотрывать вызовы и удалить!
function dbglog(fmt,...)
end


function validate_enemy_object( enemy )
  if not ( enemy and enemy.clsid ) then return false, nil end
  if not ( IsStalker( enemy ) or IsMonster( enemy) ) then 
    return false, nil
  end
  if enemy.health == nil or enemy.health <= 0 then 
    return false, nil
  end
  if enemy.m_story_id ~= nil then -- это грязный хак чтобы выяснить не попался ли нам серверный объект
    local id = enemy.id
    local enemy_gameobj = level.object_by_id( id )
    if not enemy_gameobj then
      return false, nil
    else	
      return true, enemy_gameobj
    end
  else	
    return true, enemy
  end
end


function parse_data(str)
	local string_parts = {}
	if str == nil then
		string_parts[1] = nil
		return string_parts
	end
	local str_beg,str_end
	str_end = str
	local split_pos = find_split_pos(str_end)
	while split_pos ~= nil do
		str_beg, str_end = split_string(str_end,split_pos)
		table.insert(string_parts,str_beg)
		split_pos = find_split_pos(str_end)
	end
	table.insert(string_parts,str_end)
	return string_parts
end

function find_split_pos(str)
	local split_pos = string.find(str,",")
	if split_pos == nil then
		return nil
	end
	local br1_pos = string.find(str,"(",1,true)
	local br2_pos = string.find(str,")",1,true)
	if br1_pos ~= nil and br2_pos ~= nil and br1_pos < br2_pos and split_pos > br1_pos then
		local str_end1 = string.sub(str,(br2_pos +1),string.len(str))
		if string.find(str_end1,",") ~= nil then
			split_pos = br2_pos + string.find(str_end1,",")
		else
			split_pos = nil
		end
	end
	return split_pos
end

function split_string(str,split_pos)
	local str_beg = (string.sub(str,1,split_pos-1))
	local str_end = string.sub(str,(split_pos+1),string.len(str))
	return str_beg,str_end
end

----------------------------------------------------------------------
if nil == time_global then
	time_global = function () return device():time_global() end
end

function action(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

function action_first(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,true)
    end
    return  entity_action(act)
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

--/ Если один объект nil, например нет актера, то считаем, что он далеко
function distance_between_safe(obj1, obj2)
    if(obj1 == nil or obj2 == nil) then return 100000 end
	return obj1:position():distance_to(obj2:position())
end


--/ Проверка на инфопоршны, даже если игрока не существует
function has_alife_info(info_id)
	return alife():has_info(0, info_id)
end

function reset_action (npc, script_name)
    if npc:get_script () then
       npc:script (false, script_name)
    end
    npc:script (true, script_name)
end

--------------------------------------------------
--/ Functions and variables added by Zmey
--------------------------------------------------

--/ константа, которую использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

--/ если в данный момент выполняется какое-то действие, прерывает его и отключает скриптовый режим
function interrupt_action(who, script_name)
  if who:get_script() then
    who:script(false, script_name)
  end
end

function random_choice(...)
    local arg = {...}
    local r = math.random(1, table.getn(arg))
    return arg[r]
end

function new_action(...)
    local arg = {...}
    local act = entity_action()
    for i = 1, table.getn(arg) do
        act:set_action(arg[i])
    end
    return act;
end

obj_last_actions = {};

function perform_action(obj, action_name, action)
    if (obj ~= nil) then
        obj_last_actions[obj] = action_name
        obj:command(act, false)
    end
end

function last_action(obj)
  return obj_last_actions[obj]
end

function if_then_else(cond, if_true, if_false)
    if cond then
        return if_true
    end
    return if_false
end

function update_action (npc, script, ...)
    local arg = {...}
    if npc == nil then return end
    local act = npc:action ()
    if arg.n == 0 then return end

    if act == nil then act = entity_action () end

    for a = 1, arg.n, 1 do
        if arg[a] ~= nil then act:set_action (arg[a]) end
    end
    reset_action (npc, script)
    npc:command (act, false)
end


--/ парсит строку вида "ааа, ббб, ввв ..." в таблицу { "ааа", "ббб", "ввв", ... }
function parse_names( s )
	local t = {}
	for name in s:gmatch("[^,%s]+" ) do
		table.insert( t, name )
	end
    return t
end

function parse_key_value( s )
	if s == nil then
		return nil
	end
    local t = {}
	local t0 = parse_names( s )
    for i=1,#t0,2 do
		local key, nam = t0[i], t0[i+1]
		ASSERT(nam, "parse_key_value: %s, stopped at %d: '%s' - '%s'", s or "nil", i or "nil", tostring(key) or "nil", tostring(nam) or "nil")
		t[key] = nam
    end
    return t
end

--/ парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - дробные числа
function parse_nums( s )
    local t = {}
    for i,entry in ipairs(parse_names( s )) do
		local v = tonumber( entry )
		ASSERT(v, "parse_nums: '%s', stopped at %d:'%s'", tostring(s) or "nil", i or "nil", tostring(entry) or "nil")
		table.insert(t,  v)
    end
    return t
end


--/ проверяет, есть ли объект в онлайне
function is_object_online(obj_id)
	return level.object_by_id(obj_id) ~= nil
end

function get_clsid(npc)
    if not npc then return nil end
	if npc and npc.id then
		if type(npc.id) == "function" then
			local id = npc:id()
			local sobj = alife():object(id)
			if sobj then
				return npc:clsid()
			else
				--log3(debug.traceback())
				--log3("!!DEBUG_GETCLSID NO_SRVOBJ [%s, %s]", id, npc:name() )
				return nil
			end
		elseif type(npc.id) == "number" then
			return npc:clsid()
		else
			log3(debug.traceback())
			log1("!!DEBUG_GETCLSID GET_SOMETHING_STRANGE")
			return nil
		end
	else
		log3(debug.traceback())
		log1("!!DEBUG_GETCLSID DEAD_ON_ARRIVAL")
		return nil
	end
end

--/ Вычисляет yaw в радианах
function yaw(v1, v2)
	if v1 and v2 then
		return math.abs(v2:getH()-v1:getH())
	else return 1 end
end
function yaw_degree(v1, v2)
	return yaw(v1, v2) * 57.295779513
end
function yaw_degree3d(v1, v2)
	if v1 and v2 then
		return math.acos(v1:dotproduct(v2))*57.295779513
	else return 1 end
end
function vector_cross(v1, v2)
	if v1 and v2 then
		return vector():crossproduct(v1, v2)
	else return vector():set(0, 0, 0) end
end

--/ Вращает вектор вокруг оси y против часовой стрелки
function vector_rotate_y(v, angle)
    angle = angle * 0.017453292519943295769236907684886
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

--/ очистка таблицы
function clear_table(t)
	for k, _ in pairs(t) do
		t[k] = nil
	end
end

function stop_play_sound(obj)
	if obj:alive() == true then
		obj:set_sound_mask(-1)
		obj:set_sound_mask(0)
	end
end


--TODO: ПООТРЫВАТЬ ВЫЗОВЫ И УДАЛИТЬ!
function print_table_inlog_v2(table, subs)
end

--TODO: ПООТРЫВАТЬ ВЫЗОВЫ И УДАЛИТЬ!
function print_table(table, subs)
end

--TODO: ПООТРЫВАТЬ ВЫЗОВЫ И УДАЛИТЬ!
function print_table_inlog(table, subs)
end


-------------------------------------------------------------------------------------------
function switch_online(id)
    if id == -1 then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (id, true)
       sim:set_switch_offline (id, false)
    end
end
-------------------------------------------------------------------------------------------
function switch_offline(npc)
    if npc == nil or npc:alive () == false then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (npc:id (), false)
       sim:set_switch_offline (npc:id (), true)
    end
end
-------------------------------------------------------------------------------------------
local monster_classes = {}
-------------------------------------------------------------------------------------------	
local anomaly_classes = {}
-------------------------------------------------------------------------------------------	
local stalker_classes = {}
-------------------------------------------------------------------------------------------
local weapon_classes = {}
-------------------------------------------------------------------------------------------
local outfit_classes = {}
-------------------------------------------------------------------------------------------
local indoor_levels = {}
-------------------------------------------------------------------------------------------
function IsMonster (object, class_id)
	local id = class_id or get_clsid(object)
	return id and monster_classes[id]
end
-------------------------------------------------------------------------------------------
function IsActor (object, class_id)
	local id = class_id or get_clsid(object)
	return id and id == clsid.actor
end
-------------------------------------------------------------------------------------------
function IsStalker (object, class_id)
	local id = class_id or get_clsid(object)
	return id and stalker_classes[id]
end
-------------------------------------------------------------------------------------------
function IsAnomaly (object, class_id)
	local id = class_id or get_clsid(object)
	return id and anomaly_classes[id]
end
-------------------------------------------------------------------------------------------
function isWeapon (object, class_id)
	--[[if object and string.find(object:name(), "wpn_binoc") then
		return false
	end]]
	local id = class_id or get_clsid(object)
	return id and weapon_classes[id]
end
-------------------------------------------------------------------------------------------
function isOutfit(object, class_id)
	local id = class_id or get_clsid(object)
	return id and outfit_classes[id]
end
-------------------------------------------------------------------------------------------
function isKnife(object, class_id)
	local id = class_id or get_clsid(object)
	return id and (id == clsid.wpn_knife or id == clsid.wpn_knife_s)
end
-------------------------------------------------------------------------------------------
function isIndoor(level_name)
	return indoor_levels[level_name]
end
-------------------------------------------------------------------------------------------
function isRegisteredLevel(game_vertex_id)
	local level_id = game_graph():vertex(game_vertex_id):level_id()
	return (level_id > 0 and level_id < 24) -- при добавлении новых локаций увеличить счетчик
end
-------------------------------------------------------------------------------------------
function id_by_sid( sid )
	local sim = alife()

	if sim then
		local se_obj = sim:story_object( sid )
		if se_obj then
			return se_obj.id
		end
	end
	return nil
end

function level_object_by_sid( sid )
	local id = id_by_sid( sid )
	if id then
		return level.object_by_id(id)
	end
	return nil
end

local msg_crash = {
	[0] = game.translate_string("msg_crash_1_text"),
	[1] = game.translate_string("msg_crash_2_text"),
	[2] = game.translate_string("msg_crash_3_text"),
	[3] = game.translate_string("msg_crash_4_text"),
	[4] = game.translate_string("msg_crash_5_text"),
	[5] = game.translate_string("msg_crash_6_text"),
	[6] = game.translate_string("msg_crash_7_text"),
	[7] = game.translate_string("msg_crash_8_text"),
	[8] = game.translate_string("msg_crash_9_text"),
	[9] = game.translate_string("msg_crash_1_text"),
}

local crash_counter = 0
local crash_text = game.translate_string("msg_crash_text")

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)
	for i = 0,9 do
		log1(msg_crash[i])
	end

	ogse_debug.dump_actor_codes()

	log3(debug.traceback())
	--log1("КРАТКОЕ ОПИСАНИЕ ОШИБКИ: "..fmt)
	log1("ПОЛНОЕ ОПИСАНИЕ ОШИБКИ:")
	log3(fmt, ...)
	cmd("flush")

	local hud = get_hud()
	local critical = hud:GetCustomStatic("btr_critical")
	if not critical then
		hud:AddCustomStatic("btr_critical", true)
		critical = hud:GetCustomStatic("btr_critical"):wnd()
		critical:SetText(crash_text)
	end

	if crash_counter == 0 then
		crash_counter = crash_counter + 1	
		fail("КРАТКОЕ ОПИСАНИЕ ОШИБКИ: "..fmt)
	elseif crash_counter == 1 then
		crash_counter = crash_counter + 1
		log1("ABORT: 1/crash")	
		local crash
		local ooops = 1/crash
	elseif crash_counter == 2 then
		crash_counter = crash_counter + 1
		log1("ABORT: string.format")	
		string.format("%s")		
	else
		crash_counter = crash_counter + 1
		log1("get_console():execute quit")
		cmd("quit")
	end
end

--/ проверяет целую часть числа на нечётность
function odd( x )
	return math.floor( x * 0.5 ) * 2 == math.floor( x )
end

--/ Усталость
function on_actor_critical_power()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_11_weakness")
--/	end
	if not has_alife_info("encyclopedy_tutorial_weakness") then
		game.start_tutorial("part_11_weakness")
		db.actor:give_info_portion("encyclopedy_tutorial_weakness")
	end
end


function on_actor_critical_max_power()
end

--/ Кровотечение
function on_actor_bleeding()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_8_wound")
--/	end
	if not has_alife_info("encyclopedy_tutorial_wound") then
		game.start_tutorial("part_8_wound")
		db.actor:give_info_portion("encyclopedy_tutorial_wound")
	end
end
--/ Голод
function on_actor_satiety()
	if not ogse_sleep_mgr.is_sleep_active() then
		if not has_alife_info("encyclopedy_tutorial_satiety") then
			game.start_tutorial("part_13_satiety")
			db.actor:give_info_portion("encyclopedy_tutorial_satiety")
		end
	end
end

--/ Радиация
function on_actor_radiation()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_6_radiation")
--/	end
	if not has_alife_info("encyclopedy_tutorial_radiation") then
		game.start_tutorial("part_6_radiation")
		db.actor:give_info_portion("encyclopedy_tutorial_radiation")
	end
end

--/ Заклинило оружие
function on_actor_weapon_jammed()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_9_weapon")
--/	end
	if not has_alife_info("encyclopedy_tutorial_weapon") then
		game.start_tutorial("part_9_weapon")
		db.actor:give_info_portion("encyclopedy_tutorial_weapon")
	end
end

--/ не может ходить изза веса
function on_actor_cant_walk_weight()
--/	if has_alife_info("esc_trader_newbie") then
--/		game.start_tutorial("part_14_overload")
--/	end
	if not has_alife_info("encyclopedy_tutorial_psy") then
		game.start_tutorial("part_7_psy")
		db.actor:give_info_portion("encyclopedy_tutorial_psy")
	end
end

--/ пси воздействие
function on_actor_psy()	
end

function set_actor_rank(rank)
	if rank == "novice" then
		db.actor:set_character_rank(0)
	elseif rank == "stalker" then
		db.actor:set_character_rank(300)
	elseif rank == "veteran" then
		db.actor:set_character_rank(600)
	elseif rank == "master" then
		db.actor:set_character_rank(900)
	end
end

function get_texture_info(id_name, id_default)
	if id_default == nil then id_default = id_name end

	local task_info = GetTextureInfo(id_name, id_default)
	local r = task_info:get_rect()

	r.x2 = r.x2 - r.x1
	r.y2 = r.y2 - r.y1
	return task_info:get_file_name(), r
end

function start_game_callback()
	monster_classes = {
		[clsid.bloodsucker] 			= true,
		[clsid.boar] 					= true,
		[clsid.dog_red] 				= true,
		[clsid.dog_black] 				= true,
		[clsid.flesh] 					= true,
		[clsid.burer] 					= true,
		[clsid.cat] 					= true,
		[clsid.chimera] 				= true,
		[clsid.controller] 				= true,
		[clsid.fracture] 				= true,
		[clsid.poltergeist] 			= true,
		[clsid.zombie] 					= true,
		[clsid.snork] 					= true,
		[clsid.tushkano] 				= true,
		[clsid.psy_dog] 				= true,
		[clsid.psy_dog_phantom] 		= true,	
		[clsid.pseudo_gigant] 			= true,	
		[clsid.bloodsucker_s] 			= true,
		[clsid.boar_s] 					= true,
		[clsid.dog_s] 					= true,
		[clsid.flesh_s] 				= true,
		[clsid.pseudodog_s] 			= true,
		[clsid.burer_s] 				= true,
		[clsid.cat_s] 					= true,
		[clsid.chimera_s] 				= true,
		[clsid.controller_s] 			= true,
		[clsid.fracture_s] 				= true,
		[clsid.poltergeist_s] 			= true,
		[clsid.gigant_s] 				= true,
		[clsid.zombie_s] 				= true,
		[clsid.snork_s] 				= true,
		[clsid.tushkano_s] 				= true,
		[clsid.psy_dog_s] 				= true,
		[clsid.psy_dog_phantom_s] 		= true
		}
	anomaly_classes = {
		[clsid.zone_acid_fog] = true,
		[clsid.zone_bfuzz] = true,
		[clsid.zone_bfuzz_s] = true,
		[clsid.zone_dead] = true,
		[clsid.zone_galant_s] = true,
		[clsid.zone_galantine] = true,
		[clsid.zone_mbald_s] = true,
		[clsid.zone_mincer] = true,
		[clsid.zone_mincer_s] = true,
		[clsid.zone_mosquito_bald] = true,
		[clsid.ameba_zone] = true,
		[clsid.zone_rusty_hair] = true,
		[clsid.torrid_zone] = true,
		[clsid.zone_radioactive] = true
		}
	stalker_classes = {
		[clsid.actor] 					= true,
		[clsid.script_stalker] 			= true
		}	
	weapon_classes = {
		[clsid.wpn_ak74] 				= true,
		[clsid.wpn_ak74_s] 				= true,
		[clsid.wpn_binocular] 			= true,
		[clsid.wpn_binocular_s] 		= true,
		[clsid.wpn_bm16] 				= true,
		[clsid.wpn_bm16_s] 				= true,
		[clsid.wpn_fn2000] 				= true,
		[clsid.wpn_fort]				= true,
		[clsid.wpn_grenade_f1] 			= true,
		[clsid.wpn_grenade_fake] 		= true,
		[clsid.wpn_grenade_launcher] 	= true,
		[clsid.wpn_grenade_rgd5] 		= true,
		[clsid.wpn_grenade_rpg7]		= true,
		[clsid.wpn_groza] 				= true,
		[clsid.wpn_groza_s] 			= true,
		[clsid.wpn_hpsa] 				= true,
		[clsid.wpn_hpsa_s] 				= true,
		[clsid.wpn_knife] 				= true,
		[clsid.wpn_knife_s] 			= true,
		[clsid.wpn_lr300] 				= true,
		[clsid.wpn_lr300_s] 			= true,
		[clsid.wpn_mounted] 			= true,
		[clsid.wpn_pm] 					= true,
		[clsid.wpn_pm_s] 				= true,
		[clsid.wpn_rg6] 				= true,
		[clsid.wpn_rg6_s] 				= true,
		[clsid.wpn_rpg7] 				= true,
		[clsid.wpn_rpg7_s] 				= true,
		[clsid.wpn_shotgun] 			= true,
		[clsid.wpn_shotgun_s] 			= true,
		[clsid.wpn_stat_mgun] 			= true,
		[clsid.wpn_svd] 				= true,
		[clsid.wpn_svd_s] 				= true,
		[clsid.wpn_svu] 				= true,
		[clsid.wpn_svu_s] 				= true,
		[clsid.wpn_usp45] 				= true,
		[clsid.wpn_usp45_s] 			= true,
		[clsid.wpn_val] 				= true,
		[clsid.wpn_val_s] 				= true,
		[clsid.wpn_vintorez] 			= true,
		[clsid.wpn_vintorez_s] 			= true
	}
	outfit_classes = {
		[clsid.equ_exo] 				= true,
		[clsid.equ_military]			= true,
		[clsid.equ_scientific] 			= true,
		[clsid.equ_stalker] 			= true,
		[clsid.equ_stalker_s] 			= true	
	}
	indoor_levels = {
		["l03u_agr_underground"]		= true,
		["l04u_labx18"]					= true,
		["l08u_brainlab"]				= true,
		["l10u_bunker"]					= true,
		["l12u_sarcofag"]				= true,
		["l12u_control_monolith"]		= true,
		["l23_x9"]						= true
	}

	task_manager.clear_task_manager()
	treasure_manager.clear_treasure_manager()
	dialog_manager.fill_phrase_table()	
end

ammo_section = {
	["ammo_9x18_fmj"]		= true,
	["ammo_9x18_pmm"]		= true,
	["ammo_9x19_fmj"]		= true,
	["ammo_9x19_pbp"]		= true,
	["ammo_5.45x39_fmj"]	= true,
	["ammo_5.45x39_ap"]		= true,
	["ammo_5.56x45_ss190"]	= true,
	["ammo_5.56x45_ap"]		= true,
	["ammo_7.62x54_7h1"]	= true,
	["ammo_7.62x54_ap"]		= true,
	["ammo_7.62x54_7h14"]	= true,
	["ammo_9x39_pab9"]		= true,
	["ammo_9x39_ap"]		= true,
	["ammo_11.43x23_fmj"]	= true,
	["ammo_11.43x23_hydro"]	= true,
	["ammo_12x70_kart"]	    = true,
	["ammo_12x76_zhekan"]	= true,
	["ammo_gauss"]		    = true,
	["ammo_7.62x25_p"]	    = true,
	["ammo_7.62x25_ps"]	    = true,
	["ammo_og-7b"]	        = true,
	["ammo_vog-25p"]	    = true,
	["ammo_vog-25"]	        = true,
	["ammo_m209"]	        = true,
	["ammo_m208a"]	        = true,
	["ammo_7.62x39_fmj"]	= true,
	["ammo_7.62x39_ap"]	    = true,
	["ammo_flame"]          = true,
	["ammo_arbolt"]         = true,
	["ammo_8.6x70_lm"]		= true,
}

quest_section = {
	["btr_control_module_upgrade"]	= true,
	["btr_control_module"]	= true,
	["accum_depleted"]		= true,
	["accum_full"]			= true,
	["af_uley"]			= true,
	["af_kolya"]			= true,
	["quest_btr_keys"]		= true,
	["gunslinger_flash"]	= true,
	["af_blood_tutorial"]	= true,
	["esc_wounded_flash"]	= true,
	["quest_case_02"]		= true,
	["dar_document1"]		= true,
	["dar_document2"]		= true,
	["dar_document3"]		= true,
	["dar_document4"]		= true,
	["dar_document5"]		= true,
	["kruglov_flash"]		= true,
	["lab_x16_documents"]	= true,
	["good_psy_helmet"]	= true,
	["bad_psy_helmet"]		= true,
	["decoder"]			= true,
	["dynamite"]			= true,
	["quest_case_01"]		= true,
	["hunters_toz"]		= true,
	["wpn_montirovka"]		= true,
	["bar_ecolog_flash"]	= true,
	["bar_tiran_pda"]		= true,
	["bar_lucky_pda"]		= true,
}

-------------------------------------------------------------------------------
--                            Добавлено в OGSE                               --
-------------------------------------------------------------------------------
function ASSERT(cond, msg, ...)
	if not cond then
		abort(msg, ...)
	end
end

----------------------------------------------------------------------------
local orig_sys_ini = system_ini()
class "dbg_sys_ini"
function dbg_sys_ini:__init()
	log1("dbg_sys_ini:__init")
end
function dbg_sys_ini:line_count(sec)
	log3("dbg_sys_ini:line_count: %s", sec)
	log3(debug.traceback())
	return orig_sys_ini:line_count(sec)
end
function dbg_sys_ini:section_exist(sec)
	log3("dbg_sys_ini:section_exist: %s", sec)
	log3(debug.traceback())
	return orig_sys_ini:section_exist(sec)
end
function dbg_sys_ini:line_exist(sec, param)
	log3("dbg_sys_ini:line_exist: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:line_exist(sec, param)
end
function dbg_sys_ini:r_bool(sec, param)
	log3("dbg_sys_ini:r_bool: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_bool(sec, param)
end
function dbg_sys_ini:r_float(sec, param)
	log3("dbg_sys_ini:r_float: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_float(sec, param)
end
function dbg_sys_ini:r_clsid(sec, param)
	log3("dbg_sys_ini:r_clsid: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_clsid(sec, param)
end
function dbg_sys_ini:r_s32(sec, param)
	log3("dbg_sys_ini:r_s32: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_s32(sec, param)
end
function dbg_sys_ini:r_u32(sec, param)
	log3("dbg_sys_ini:r_u32: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_u32(sec, param)
end
function dbg_sys_ini:r_vector(sec, param)
	log3("dbg_sys_ini:r_vector: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_vector(sec, param)
end
function dbg_sys_ini:r_string_wq(sec, param)
	log3("dbg_sys_ini:r_string_wq: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_string_wq(sec, param)
end
function dbg_sys_ini:r_string(sec, param)
	log3("dbg_sys_ini:r_string: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_string(sec, param)
end
function dbg_sys_ini:r_token(...)
	log3("dbg_sys_ini:r_token: %s - %s", sec, param)
	log3(debug.traceback())
	return orig_sys_ini:r_token(...)
end
function dbg_sys_ini:r_line(sec, line_num)
	log3("dbg_sys_ini:r_line: %s - %s", sec, line_num)
	log3(debug.traceback())
	return orig_sys_ini:r_line(sec, line_num)
end

--system_ini = function() return dbg_sys_ini() end
----------------------------------------------------------------------------

sys_ini = system_ini() --Из скриптов вызывать только sys_ini!!!!

-- служебные функции для чтения параметров из секций объектов

function get_string(section, param, def_val, ini_file)
	ASSERT(section, "get_string: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_string: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_string(section, param)
	else
		return def_val
	end
end
function get_string_wq(section, param, def_val, ini_file)
	ASSERT(section, "get_string: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_string: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_string_wq(section, param)
	else
		return def_val
	end
end
function get_u32(section, param, def_val, ini_file)
	ASSERT(section, "get_u32: section not defined, param="..tostring(param))
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_u32: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_u32(section, param)
	else
		return def_val
	end
end
function get_bool(section, param, def_val, ini_file)
	ASSERT(section, "get_bool: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_bool: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_bool(section, param)
	else
		return not (not def_val)
	end
end
function get_float(section, param, def_val, ini_file)
	ASSERT(section, "get_float: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_float: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		return ini:r_float(section, param)
	else
		return def_val
	end
end
-- получить класс из секции, полезно в том случае, если нет объекта (и недоступен метод clsid), а есть только имя секции
function get_class(section)
	ASSERT(section, "get_class: section parameter is not defined")
	ASSERT(sys_ini:section_exist(section), "get_class: section '"..section.."' doesn't exist")
	ASSERT(sys_ini:line_exist(section, "class"), "get_class: there is no 'class' parameter in the section '"..section.."'")
	return sys_ini:r_clsid(section, "class")
end
-- делит строку в виде "aaa,bbb,ccc" на строки "aaa", "bbb", "ccc" и возвращает их в виде массива
function split_comma_separated_list(s)
	local res = {}
	for v in string.gmatch(s, "[^,]+") do
		table.insert(res, v)
	end
	return res
end
-- читает время, сохранённое в виде строки со значениями, разделёнными запятой, и конвертирует в значение класса CTime
function unpack_time_from_string(str_time)
	local time_values = {}
	for i,s in ipairs(split_comma_separated_list(str_time)) do
		local value = tonumber(s)
		ASSERT(value, "unpack_time_from_string: problem with unpacking saved time '%s', value #%d (%s)", str_time, i, tostring(s))
		table.insert(time_values, value)
	end
	ASSERT(#time_values == 7, "unpack_time_from_string: packed time '%s' has wrong number of components. Must be equal to seven.")
	local res = game.CTime()
	res:set(unpack(time_values))
	return res
end
-- упаковать время в виде объекта CTime в строку значений, разделённых запятой
function pack_time_to_string(t)
	ASSERT(t, "pack_time_to_string: t is a nil reference")
	return table.concat({t:get()}, ',')
end
-- читает строку вида "s1,s2,s3" и парсит на строковые значения, разделённые запятой, в таблицу вида {s1, s2, s3}
function get_names(section, param, ini_file)
	ASSERT(section, "get_names: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_names: section '"..section.."' doesn't exist")
	local s = ini:r_string(section, param)
	return split_comma_separated_list(s)
end
-- читает строку вида "s1,s2,s3" и парсит на численные значения, разделённые запятой, в таблицу вида {n1, n2, n3}
function get_numbers(section, param, ini_file)
	local t = {}
	for i,sv in ipairs(get_names(section, param, ini_file)) do
		local v = tonumber(sv)
		ASSERT(v, "get_numbers: can not convert to number item ["..i.."]: "..tostring(sv))
		table.insert(t, v)
	end
	return t
end

function get_section_keys(section, ini_file)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_section_keys: section '"..section.."' doesn't exist")
	local t = {}
	for i=0,ini:line_count(section)-1 do
		local v1,key = ini:r_line(section, i)
		t[i+1] = key
	end
	return t
end

function get_section_keys_and_values( section, ini_file )
  local ini = ini_file or sys_ini
  ASSERT( ini:section_exist( section ), "get_section_keys: section '" .. section .. "' doesn't exist" )
  local t = {}
  for i = 0, ini:line_count( section ) - 1 do
  local _, key, v = ini:r_line( section, i, "", "" )
    t[ key ] = v
  end
  return t
end

function get_vector(section, param, def_val, ini_file)
	ASSERT(section, "get_vector: section not defined, param="..param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_vector: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		local pos = get_names(section, param, ini)
		return vector():set(tonumber(pos[1]), tonumber(pos[2]), tonumber(pos[3]))
	else 
		if def_val then
			return def_val
		else
			return vector():set(0,0,0)
		end
	end
end

-- значение по умолчанию должно задаваться таблицей {num1, num2}
function get_vector2(section, param, def_val, ini_file)
	ASSERT(section, "get_vector2: section not defined, param=%s", param)
	local ini = ini_file or sys_ini
	ASSERT(ini:section_exist(section), "get_vector2: section '"..section.."' doesn't exist")
	if ini:line_exist(section, param) then
		local pos = get_names(section, param, ini)
		return tonumber(pos[1]), tonumber(pos[2])
	else
		return def_val and unpack(def_val)
	end
end

-- Берём параметры иконки из конфигов
function get_inventory_icon_rect(sect)
	return 50*sys_ini:r_u32(sect, "inv_grid_x"), 50*sys_ini:r_u32(sect, "inv_grid_y"), 50*sys_ini:r_u32(sect, "inv_grid_width"), 50*sys_ini:r_u32(sect, "inv_grid_height")
end
-- получить номер локации по номеру глобального вертекса
function location_id_by_gvid(gvid)
	if gvid and game_graph():valid_vertex_id( gvid ) then
		return game_graph():vertex( gvid ):level_id()
	end
end
-- получить номер локации для клиентского объекта
function object_location_id(obj)
	local gvid = obj.game_vertex_id and obj:game_vertex_id() or obj.m_game_vertex_id
	return location_id_by_gvid(gvid)
end
function object_level_name(obj)
	local lid = object_location_id( obj )
	if lid then
		return level_system_name_by_lid( lid )
	end
end
function level_system_name_by_lid(lid)
	if lid then
		return alife():level_name( lid )
	end
end
function level_name_by_level_system_name(lname)
	return game.translate_string(lname)
end
--системное имя уровня
function level_system_name_by_gvid(gvid)
	return level_system_name_by_lid(location_id_by_gvid(gvid))
end
--Внятное имя уровня (не системное, а то, которое изображается на карте):
function level_name_by_gvid(gvid)
	return level_name_by_level_system_name(level_system_name_by_gvid(gvid))
end

--***********************************[Функции для вывода в лог]****************************************
-----------------------------------------------------------------------------------------
local tostring_all_tbl = {
	["table"] =		function(table, ind) --Распечатка таблиц
						local res = "{" --Начало
						local end_res = ind and "\n"..ind.."}" or "\n}" --Конец
						local def_ind = "  " --Отступ от начала строки
						ind = ind and ind..def_ind or def_ind --Для каждой "таблицы внутри таблицы" отступ увеличивается в 2 раза
						if isArray(table) then --Если это массив, обрабатываем только значения:
							for i=1, #table do
								res = res.."\n"..ind..tostring_all(table[i], ind)..","
							end
						else --Если НЕ массив, обрабатываем и ключи, и значения:
							for k, v in pairs(table) do
								res = res.."\n"..ind.."["..tostring_all(k, ind).."] = "..tostring_all(v, ind)..","
							end
						end
						return res..end_res
					end,
	["string"] =	function(v) return "'"..v.."'" end, --Строки берём в кавычки. Это нужно, чтобы можно было отличить строку "123" от числа 123, "nil" от nil и тд...
	["number"] =	function(v) return tostring(v) end,
	["boolean"] =	function(v) return tostring(v) end,
	["nil"] =		function(v) return tostring(v) end,
	["function"] =	function() return "[[FUNCTION]]" end, --Function, Userdata и Thread распечатать нельзя, просто заменим на строки
	["userdata"] =	function() return "[[USERDATA]]" end,
	["thread"] =	function() return "[[THREAD]]" end,
}
--Конвертирование чего угодно в строку. Использовать только для вывода в лог!
function tostring_all(obj, ind) --ind - служебный аргумент для распечатки "таблиц в таблицах". НЕ ТРОГАТЬ ЕГО!!!
	return tostring_all_tbl[type(obj)](obj, ind)
end

local subs_tbl = { --Если в самом начале строки формата будут эти символы, то текст в консоли будет:
	["--"] = true, --Зелёный
	["~~"] = true, --Жёлтый
	["!!"] = true  --Красный
}
--Функциональная обёртка для log1.
--Делает дополнительную работу по конвертации параметров, которые не воспринимаются родной функцией string.format.
--Параметры можно передавать ЛЮБОГО ТИПА! В строке формата они должны стоять как %s (потому, что будут сконвертированы в строки).
function log3(fmt, ...)
	local args = {...}
	--Цикл ipairs здесь не работает, поскольку останавливается на первом _значении_ nil, что исключает возможность иметь nil-аргументы
	--Решетка(#) nil-аргументы обрабатывает, но, к сожалению, не обрабатывает void, это никак не исправить.
	--http://www.amk-team.ru/forum/topic/11584-iazyk-lua-obschie-voprosy-programmirovaniia/page-57#entry1016824
	for i=1, #args do
		args[i] = tostring_all(args[i])
	end
	local res, msg = pcall(string.format, fmt, unpack(args))
	if not res then --Если произошла ошибка
		msg = "!!log3 failed: "..msg
		log1(msg) --Вылетать не будем, напишем об ошибке в лог
		return msg
	end
	if msg:find('[\n]') then --Если нашли в тексте хоть один перенос строки
		local subs = msg:sub(1, 2) --Читаем два символа из самого начала текста
		if subs_tbl[subs] then --Если это символы, отвечающие за цвет текста в консоли, то
			msg = msg:gsub("\n", "\n"..subs) --вставим их после каждого "\n", чтобы в консоли были цветными все строки, а не только первая.
		end
		local ret = {}
		for s in msg:gmatch("([^\n]+)") do --Конвертируем строку в массив подстрок
			if not subs_tbl[s] then --Трюк, чтобы отсечь пустые строки.
				ret[#ret+1] = s
			end
		end
		for s=1, #ret do
			log1(ret[s]) --Выводим в лог каждую подстроку отдельно. Это позволяет избежать ограничения в 1024 символа, после которых текст просто обрезается.
		end
		return ret --Нужно для log4
	else --Если подстрок нет
		log1(msg) --Выводим текст в лог без дополнительных манипуляций.
		return msg --Нужно для log4
	end
end
-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------
local logs_cach = {}
--Дополнительная обёртка для log3. Создаёт новый лог-файл и выводит текст в него.
--fname - название лог-файла, например "Anomaly_Evader". Он будет создан в папке logs, к названию добавится дата и время создания.
--fmt, ... - строка формата с параметрами. См. функцию log3.
function log4(fname, fmt, ...)
	local f = logs_cach[fname]
	if not f then
		local dt = os.date("*t")
		local fpath = getFS():update_path("$logs$", string.format("%s_%02d.%02d.%02d_%02d.%02d.%02d.log",fname,dt.day,dt.month,dt.year,dt.hour,dt.min,dt.sec))
		f = io.open(fpath, "w")
		logs_cach[fname] = f
	end
	local msg = log3(fmt, ...)
	if type(msg) == "string" then
		f:write(msg..'\n')
	elseif type(msg) == "table" then
		for s=1, #msg do
			f:write(msg[s]..'\n')
		end
	end
	f:flush()
end
-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------
function log2(fmt, ...) --Простая обёртка для log1.
	log1(fmt:format(...))
end
-----------------------------------------------------------------------------------------
function clear_log() --Очистить лог
	cmd("clear_log")	
end
-----------------------------------------------------------------------------------------
--*****************************************************************************************************

function get_item_weight_by_section(section)
	local res = get_float(section, "inv_weight")
	ASSERT(res, "get_item_weight_by_section: there is no 'inv_weight' parameters in section '"..section.."'")
	return res
end

function get_ammo_weight_by_section(section, count)
	local box_weight = get_item_weight_by_section(section)
	local box_size = get_int(section, "box_size", 0)
	ASSERT(box_size > 0, "get_ammo_weight_by_section: 'box_size' parameters in section '"..section.."' is zero or missed")
	return box_weight * count / box_size
end

function print_vector(name, v)
	log2("%s: %9.3f, %9.3f, %9.3f", name, v.x, v.y, v.z)
end
function print_matrix(name, m)
	log1(name..":")
	log2("[%9.3f, %9.3f, %9.3f, %9.3f]", m.i.x, m.i.y, m.i.z, m._14_)
	log2("[%9.3f, %9.3f, %9.3f, %9.3f]", m.j.x, m.j.y, m.j.z, m._24_)
	log2("[%9.3f, %9.3f, %9.3f, %9.3f]", m.k.x, m.k.y, m.k.z, m._34_)
	log2("[%9.3f, %9.3f, %9.3f, %9.3f]", m.c.x, m.c.y, m.c.z, m._44_)
end
function time2string(time, fmt, order)
	ASSERT(time, "[_g.time2string] 'time' is a nil reference")
	local a,b = time:get_value()
	if not fmt then
		return time:timeToString(game.CTime.TimeToMilisecs).." "..time:dateToString(game.CTime.DateToDay)..string.format(" [%04x %04x]", a,b)
	else
		local y,m,d,h,min,s,ms = time:get()
		local args = {y=y,m=m,d=d,h=h,min=min,s=s,ms=ms,a=a,b=b}
		if order then
			args = {args[order[1]], args[order[2]], args[order[3]], args[order[4]], args[order[5]], args[order[6]], args[order[7]], args[order[8]], args[order[9]]}
		end
		return fmt:format(unpack(args))
	end
end
function print_time(title, time)
	log1(title..": "..time2string(time))
end
local fs = getFS()
function check_module(module_name)
	local script_name = fs:update_path("$game_scripts$", module_name..".script")
	local res, err = loadfile(script_name)
--[[	if res then
		log1("module: '"..script_name.."' is correct")
	else
		log1("module: "..script_name.."\nerror: "..err)
	end]]
	return res, err
end

function hit_object(obj, dir, imp, dr, pow, t)
	local h = hit()
	h.direction = dir
	h.impulse = imp
    h.draftsman = dr
	h.power = pow
	h.type = t
	obj:hit(h)
end

function hit_object_ex(hit_params)
	local h = hit()
	ASSERT(hit_params.obj, "hit_object_ex: target is not defined! 'obj' field is a nil reference")
	h.direction = hit_params.dir or vector():set(1,0,0)
	h.impulse = hit_params.imp or 0
    h.draftsman = hit_params.dr or hit_params.obj
	h.power = hit_params.pow or 0
	h.type = hit_params.t or 0
	h.bone = hit_params.bone or ""
	hit_params.obj:hit(h)
end

--/Нанести хит

function hit_obj_by_id_simple(ObjId, Pwr, iImpulse)
	local obj2hit = level.object_by_id(ObjId)
	ASSERT(obj2hit, "[hit_obj_by_id_simple] no object found for id = %d", ObjId)
	local hit_params = {
		["t"] = hit.explosion, 
		["dir"] = vector():set(0, 0, 0),
		["dr"] = obj2hit,
		["obj"] = obj2hit,
		["imp"] = iImpulse,
		["pow"] = Pwr,
	}
	hit_object_ex(hit_params)
end

function seconds2ctime(time_sec)
	local s,ms = math.modf(time_sec)
	local t = game.CTime()
	t:setHMSms(0,0,s,ms*1000)
	return t
end

-- надёжнее, чем device().aspect_ratio, поскольку не зависит от инициализированности рендера
-- однако медленная. Не рекомендуется использовать часто
function get_aspect_ratio()
	local s =  get_con_string("vid_mode")
	local sw,sh = string.match(s, "(%d+)x(%d+)")
	return tonumber(sh)/tonumber(sw)
end
----------------------------------------------------------------------
-- Работа с актором
----------------------------------------------------------------------
-- константы для функций get_actor_flags и set_actor_flags
actor_flags = {
	invincible     =  1,
	invisible      =  2, -- useless
	always_run     =  4,
	unlimited_ammo =  8,
	run_backward   = 16,
	autopickup     = 32,
	psp            = 64, -- вид от третьего лица
}
function set_actor_invincible(invincible)
	local flags = get_actor_flags()
	local mask = actor_flags.invincible
	set_actor_flags(invincible and bit_or(flags, mask) or bit_and(flags, bit_not(mask)))
end

-- получение некоторых значений с плавающей запятой
-- параметры бега
function get_walk_accel()         return db.actor:get_actor_float(1440) end
function get_jump_speed()         return db.actor:get_actor_float(1444) end
function get_run_factor()         return db.actor:get_actor_float(1448) end
function get_run_back_factor()    return db.actor:get_actor_float(1452) end
function get_walk_back_factor()   return db.actor:get_actor_float(1456) end
function get_crouch_factor()      return db.actor:get_actor_float(1460) end
function get_climb_factor()       return db.actor:get_actor_float(1464) end
function get_sprint_factor()      return db.actor:get_actor_float(1468) end
function get_walk_strafe_factor() return db.actor:get_actor_float(1472) end
function get_run_strafe_factor()  return db.actor:get_actor_float(1476) end
-- параметры стрельбы
function get_disp_base()          return db.actor:get_actor_float(1484) end -- в радианах
function get_disp_aim()           return db.actor:get_actor_float(1488) end -- в радианах
function get_disp_vel_factor()    return db.actor:get_actor_float(1492) end
function get_disp_accel_factor()  return db.actor:get_actor_float(1496) end
function get_disp_crouch_factor() return db.actor:get_actor_float(1500) end
function get_disp_crouch_no_accel_factor()  return db.actor:get_actor_float(1504) end
-- получение некоторых целых и логических значений
-- режим прицеливания
function zoom_mode() return bit_and(db.actor:get_actor_int(nil, 1480), 1) ~= 0 end -- возвращает true/false

-- установка некоторых значений
-- параметры бега
function set_sprint_factor(v)      db.actor:set_actor_float(nil, v, 1468) end
function set_jump_speed(v)         db.actor:set_actor_float(nil, v, 1444) end
function set_walk_accel(v)         db.actor:set_actor_float(nil, v, 1440) end
function set_run_factor(v)         db.actor:set_actor_float(nil, v, 1448) end
function set_run_back_factor(v)    db.actor:set_actor_float(nil, v, 1452) end
function set_walk_back_factor(v)   db.actor:set_actor_float(nil, v, 1456) end
function set_crouch_factor(v)      db.actor:set_actor_float(nil, v, 1460) end
function set_climb_factor(v)       db.actor:set_actor_float(nil, v, 1464) end
function set_walk_strafe_factor(v) db.actor:set_actor_float(nil, v, 1472) end
function set_run_strafe_factor(v)  db.actor:set_actor_float(nil, v, 1476) end
-- параметры стрельбы
function set_disp_base(v)          db.actor:set_actor_float(nil, v, 1484) end -- в радианах

function set_jump_power( v ) db.actor:set_actor_condition_float( nil, v, 276 ) end

local body_states = { -- флажки состояния тела актора
[1]		= "fwd",
[2]		= "back",
[4]		= "l_strafe",
[8]		= "r_strafe",
[16]	= "crouch",
[32]	= "accel",
[64]	= "turn",
[128]	= "jump",
[256]	= "fall",
[512]	= "landing",
[1024]	= "landing2",
[2048]	= "climb",
[4096]	= "sprint",
[8192]	= "l_lookout",
[16384]	= "r_lookout"
}
-- получения флагов состояния тела актора
function actor_body_state()
	local body_state = body_states[db.actor:get_actor_int(nil, 1432)]
	if body_state ~= nil then
		return body_state
	else
		return ""
	end
end
-- установка флагов состояния тела актора
function set_actor_body_state(flags_to_set, value)
	local current_flags = db.actor:get_actor_int(nil, 1432)
	local new_flags = value and bit_or(current_flags, flags_to_set) or bit_and(current_flags, bit_not(flags_to_set))
	db.actor:set_actor_int(1432, new_flags)
end
local anomaly_invisibility_flag = tonumber("80000000", 16)
-- установка невидимости сталкера со стороны аномалий
function set_anomaly_invisibility(npc, vis)
	local fl = npc:get_actor_relation_flags()
	fl:set(anomaly_invisibility_flag, vis)
	npc:set_actor_relation_flags(fl)
end
-- получение статуса невидимости сталкера со стороны аномалий
function get_anomaly_invisibility(npc)
	local fl = npc:get_actor_relation_flags()
	return fl:test(anomaly_invisibility_flag)
end
-- поверхностное (простое) клонирование таблицы: 
--  создаётся копия таблицы и копии всех элементов без их клонирования,
--  т.е. для ссылочных типов обе таблицы будут содержать ссылки на одни и те же данные
--  метатаблицы не копируются
function table.clone_simple(tbl)
	local res = {}
	for k,v in pairs(tbl) do
		res[k] = v
	end
	return res
end

function get_day_time_sec(t)
	local y,m,d,h,min,s,ms = t:get()
	return h * 3600.0 + min * 60.0 + s + ms * 1e-3
end

-- получить текушее игровое время от начала суток, измеренное в часах (значение в пределах [0, 24) )
function get_game_day_time_h()
	local gt = game.get_game_time()
	local y,m,d,h,min,sec,ms = gt:get()
	return math.fmod(h + min/60.0 + (sec + 0.001*ms)/3600.0, 24.0)
end

function relation_registry.get_goodwill(who_id, to_whom_id)
	return GetGoodwill(who_id, to_whom_id)
end

function relation_registry.set_goodwill(who_id, to_whom_id, goodwill)
	ASSERT(db.actor, "relation_registry.set_goodwill: cannot call function")
	return db.actor:set_goodwill_ex(who_id, to_whom_id, goodwill)
end

function relation_registry.change_goodwill(who_id, to_whom_id, goodwill_change)
	ASSERT(db.actor, "relation_registry.change_goodwill: cannot call function")
	return db.actor:change_goodwill_ex(who_id, to_whom_id, goodwill_change)
end

-- флаги трассировки
rq_target = {
	rqtNone,
	rqtObject   = 1,
	rqtStatic   = 2,
	rqtShape    = 4,
	rqtObstacle = 8,
	rqtBoth     = 3, -- rqtObject + rqtStatic
	rqtDyn      = 13, -- rqtObject + rqtShape + rqtObstacle
}

ray_pick = {}
-- устанавливает базовые параметры трассировки
function ray_pick.init(pos_from, dir, range, flags, ignore_obj)
	ray_pick.set_pos(pos_from)
	ray_pick.set_dir(dir)
	ray_pick.set_range(range)
	ray_pick.set_flags(flags)
	ray_pick.set_object_to_ignore(ignore_obj)
end

-- устанавливает стартовую точку трассировки
function ray_pick.set_pos(pos)
	--print_vector("pos", pos)
	db.actor:set_vector_global_arg_2(pos)
end
-- устанавливает направление трассировки
function ray_pick.set_dir(dir)
	--print_vector("dir", dir)
	db.actor:set_vector_global_arg_1(dir)
end
-- устанавливает диапазон трассировки
function ray_pick.set_range(range)
	--log2("range: %7.2f", range)
	set_float_args_12(range, 0)
end
-- устанавливает флаги трассировки (rq_target)
function ray_pick.set_flags(flags)
	--log2("flags: %x", flags)
	set_int_arg1(flags)
end
-- устанавливает игнорируемый игровой объект для трассировки
function ray_pick.set_object_to_ignore(obj)
	db.actor:set_object_arg_1(obj)
end
-- выполняет запрос на трассировку и возвращает true, если она была успешна
function ray_pick.check()
	return level.perform_ray_pick_query()
end

-- если трассировка была успешна, возвращает дистанцию до точки, иначе возвращает ранее заданный диапазон трассировки
function ray_pick.get_dist()
	return level.get_ray_pick_dist()	
end

-- если трассировка была успешна, возвращает игровой объект
function ray_pick.get_obj()
	return level.get_ray_pick_obj()
end
-- если луч пересек игровой объект, то возвращает номер кости, иначе возвращает номер полигона статической геометрии (при неудачной трассировке возвращает -1)
function ray_pick.get_element()
	return level.get_ray_pick_element()
end


function is_16_9_mode()
	local dev = device()
	return dev.width / dev.height > 1.34
end

-- выравнивание значения n в пределы от min до max
math.clamp = function( n, min, max )
	if min>max then min,max=max,min end
	return (n>max and max) or (n<min and min) or n
end

-- округление к ближайшему
function math.round(v)
	return math.floor(v + 0.5)
end

function math.lerp(x1, x2, y1, y2, x)
	return (x - x1) * (y2 - y1) / (x2 - x1)
end

function math.similar(a1, a2, tol)
	return math.abs(a1 - a2) <= tol
end

-- смещения полей в структуре SHit, т.е. параметры хита
hit_offset = {
  Time              = 0,  -- 4, insigned int
  PACKET_TYPE       = 4,  -- 2, insigned short
  DestID            = 6,  -- 2, insigned short
  power             = 8,  -- 4, float 
  dir_x             = 12, -- 4, float
  dir_y             = 16, -- 4, float
  dir_z             = 20, -- 4, float
  who               = 24, -- 4, pointer
  whoID             = 28, -- 2, insigned short
  weaponID          = 30, -- 2, insigned short
  boneID            = 32, -- 2, insigned short
  -- 2 байта на выравнивание
  p_in_bone_space_x = 36, -- 4, float
  p_in_bone_space_y = 40, -- 4, float
  p_in_bone_space_z = 44, -- 4, float
  impulse           = 48, -- 4, float
  hit_type          = 52, -- 4, unsigned int (ALife::EHitType)
  ap                = 56, -- 4, float
  aim_bullet        = 60, -- 1, bool
  -- 3 байта на выравнивание
  BulletID          = 64, -- 2, unsigned int
  SenderID          = 66, -- 2, unsigned int
}

-- коды дополнительных колбеков
callback_ex = {
	["on_key_press"]                 = 123,
	["on_key_release"]               = 124,
	["on_key_hold"]                  = 125,
	["on_mouse_wheel"]               = 126,
	["on_mouse_move"]                = 127,

	["on_belt"]                      = 130,
	["on_ruck"]                      = 131,
	["on_slot"]                      = 132,
	["on_select_item"]               = 133,
	["on_create_cell_item"]          = 136,

	["on_after_save"]				 = 140,

	["on_goodwill_change"]           = 145,
	["on_release_npc"]               = 146,

	["on_inv_box_put_item"]          = 151,
	["entity_alive_before_hit"]      = 152,
	["dbg_gg_distance_failed"]       = 153,
	["update_addons_visibility"]     = 154,
	["update_hud_addons_visibility"] = 155,
	["on_before_use_item"]           = 156;
	["on_hud_animation_end"]         = 157,

	["pda_contact"]                  = 180,
}
inventory_item_offsets = {
	["health_influence"]    = 220,
	["power_influence"]     = 224,
	["satiety_influence"]   = 228,
	["radiation_influence"] = 232,
	["power_max_influence"] = 236,
	["wound_heal"]          = 240,
	["alcohol_influence"]   = 688,
}

-- обнуление всех эффектов съедаемого предмета
-- изменённые значения в сейве не сохраняются
-- функция предназначена в основном для использования в событии предиспользования,
-- когда эффекты предмета ещё не применены и их можно изменить, что повлияет на собственно эффект от 
-- предмета на параметры здоровья, радиации и т.п.. При этом подразумевается,
-- что предмет после использования будет удалён, поэтому вопрос о сохранении этих свойств не стоит
-- если используется подход с eat_portions_num > 1 (обычно задаётся "бесконечное" значение, типа 10000),
-- то эту функцию либо использовать нельзя, либо надо таким же образом восстанавливать свойства предмета
-- в событии использования (стандартный колбек callback.use, который в сущности является колбеком на 
-- "послеиспользование", когда эффекты предмета уже применены)
function zero_all_item_effects(item)
	ASSERT(item:is_eatable_item(), "")
	for param, offset in pairs(inventory_item_offsets) do
		-- параметр влияния алкоголя годится только для объекта-бутылки
		if param ~= "alcohol_influence" or item:is_bottle_item() then
			item:set_inventory_item_float(nil, 0.0, offset)
		end
	end
end
-- набор констант для использования в колбеках на использование и предиспользование инвентарных предметов
-- константы сигналят, что надо делать с предметом после его обработки: 
--     удалить, создать его дубликат, не делать ничего
-- это надо для упорядочения работы с инвентарными предметами при разных подходах использования eat_portions_num
-- если eat_portions_num = 1 или -1, то предмет одноразовый. В этом случае, если мы хотим "сохранить" предмет
-- в инвентаре, то возвращаем post_use_action.create_new_item, в противном случае возвращаем post_use_action.do_nothing
-- если же используем подход с eat_portions_num = "бесконечность", то как раз при использовании сигналим
-- вызвавшему коду, что предмет надо удалить, т.е. возвращаем post_use_action.delete_item, в противном случае просто оставляем
-- предмет в покое (возвращаем post_use_action.do_nothing).
-- P.S.: Этот подход архитектурно не навязан. Используется по желанию. Константы вынесены сюда на тот случай,
-- если кто-то захочет использовать такую же организацию кода
post_use_action = {
	do_nothing = 0,
	delete_item = 1,
	create_new_item = 2,
}

-- установка направления взгляда актора в заданную точку
function actor_look_at_point(target_point)
	ASSERT(target_point, "actor_look_at_point: target point vector is a nil reference!")
	local look_dir = vector():sub(target_point, device().cam_pos)
	local h = look_dir:getH()
	local p = look_dir:getP()
	db.actor:set_camera_direction(vector():set(-h,-p,0))
end

local con = get_console()

function cmd(scmd, ...)
	ASSERT(scmd, "[cmd] scmd is a nil reference")
	local args = {...}
	if #args > 0 then
		scmd = scmd..' '..table.concat(args, ' ')
	end
	con:execute(scmd)
end

function get_con_float(param)
	return con:get_float(param)
end
function get_con_string(param)
	return con:get_string(param)
end
function get_con_bool(param)
	return con:get_bool(param)
end

-- проверка сушествования файла на диске
-- примечания: 
-- 1. это  для проверки существования реального файла, не в архиве
-- 2. способ неуклюжий, но другого в чистом Lua нет
function file_exists(name)
	local f = io.open(name,"r")
	if f then
		f:close()
		return true
	end
	return false
end


-- Управление торгуемостью и группировкой предметов в инвентаре
ii_flags = {
	drop_manual         = 1,
	can_take            = 2,
	can_trade           = 4,
	belt                = 8,
	ruck                = 16,
	ruck_default        = 32,
	using_condition     = 64,
	allow_sprint        = 128,
	useful_for_npc      = 256,
	in_interpolation    = 512,
	in_interpolate      = 1024,
	is_quest_item       = 2048,
	-- extra flags added in x-ray extensions
	always_tradable     = 4096,
	always_untradable   = 8192,
	ungroupable         = 16384,
	manual_highlighting = 32768,
}

ext_ii_flags = {
	actor_can_take         = 1,
}

function set_ext_ii_flags(item, mask, value)
	item:set_inventory_item_int16(134, flags16():assign(item:get_inventory_item_int16(nil, 134)):set(mask, value):get())
end

function set_item_forbidden_to_actor(item)
	set_ext_ii_flags(item, ext_ii_flags.actor_can_take, true)
end

function mark_grenade_non_pickable(id, item)
	set_item_forbidden_to_actor(item)
	log1("!!DEBUG_GRENKA_NONPICKABLE "..tostring(id))
	--level.client_spawn_manager():remove(id, 0)
end

-- вспомогательная функция для установки флагов в классе CInventoryItem
function set_ii_flags(item, mask, value)
	item:set_inventory_item_int16(132, flags16():assign(item:get_inventory_item_int16(nil, 132)):set(mask, value):get())
end
-- вспомогательная функция для установки флагов в классе CInventoryItem
function set_ii_custom_color_ids(item, col_idx)
	ASSERT(col_idx >=0 and col_idx <=15, "[set_ii_custom_color_ids] col_idx must be in the range [0-15]")
	local fl = bit_or(bit_and(item:get_inventory_item_int16(nil, 134), 65520), col_idx)
	item:set_inventory_item_int16(134, fl)
end
-- сделать предмет безусловно негруппируемым в окнах инвентаря
function set_item_ungroupable(item)
	set_ii_flags(item, ii_flags.ungroupable, true)
end
-- включить движковую группировку для предмета
function set_item_default_grouping(item)
	set_ii_flags(item, ii_flags.ungroupable, false)
end
-- сделать предмет безусловно продаваемым
function set_item_always_tradable(item)
	set_ii_flags(item, ii_flags.always_tradable, true)
end
-- сделать предмет безусловно непродаваемым, будет показан красным. Для избежания глюков надо также
-- выключать группируемость для этого предмета
function set_item_always_untradable(item)
	set_ii_flags(item, ii_flags.always_tradable, false)
	set_ii_flags(item, ii_flags.always_untradable, true)
end
-- включить движковую торгуемость для предмета
function set_item_tradable(item, value)
	set_ii_flags(item, ii_flags.can_trade, true)
end
-- выключить движковую торгуемость для предмета
function set_item_untradable(item, value)
	set_ii_flags(item, ii_flags.can_trade, false)
end
-- убрать принудительную тогумеость или неторгуемость и оставить только двидковый алгоритм
function set_item_default_tradability(item)
	set_ii_flags(item, ii_flags.always_tradable + ii_flags.always_untradable, false)
end
-- включить для предмета явную раскраску кастомным цветом
function set_item_always_highlighted(item)
	set_ii_flags(item, ii_flags.manual_highlighting, true)
end
-- использовать только движковую раскраску
function set_item_default_highlighting(item)
	set_ii_flags(item, ii_flags.manual_highlighting, false)
end

-- сбросить торгуемость для всех предметов в инвентаре актора
function reset_actor_items_tradability()
	for i = 0, db.actor:object_count() - 1 do
		set_item_default_tradability(db.actor:object(i)) 
	end
end

get_game_id = ogse_unist.get_game_id


--Задать кол-во патронов в пачке
function set_ammo_size(item, size)
	item:set_go_int16(476, size)
end


function get_inv_item_slot( obj )
	return obj:get_inventory_item_int( nil, 156 )
end

function set_inv_item_slot( obj, slot )
	obj:set_inventory_item_int( 156, slot )
end


-- http://www.amk-team.ru/forum/index.php?showtopic=6185&p=945289
weapon_states = {
  idle      = 0,
  fire      = 1,
  fire2     = 2,
  reload    = 3,
  showing   = 4,
  hiding    = 5,
  hidden    = 6,
  misfire   = 7,
  mag_empty = 8,
  switch    = 9
}
--[[ --Пример использования:
local state = db.actor:active_item():get_hud_item_state()
if state == weapon_states.reload then
...
end
--]]


-- http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=1002890
function normal_triangle( element ) -- возвращает нормаль треугольника, аргументом передавать элемент геометрии (который можно получить, например, функцией level.get_target_element() или ray_pick.get_element())
  local n = vector()
  local a = level.get_tri_vertex1( element ) --возвращает первую вершину статического треугольника.
  local b = level.get_tri_vertex2( element ) --возвращает вторую вершину статического треугольника.
  local c = level.get_tri_vertex3( element ) --возвращает третью вершину статического треугольника.
  n.x = ( ( b.z - a.z ) * ( c.y - a.y ) ) - ( ( b.y - a.y ) * ( c.z -a.z ) )
  n.y = ( ( b.x - a.x ) * ( c.z - a.z ) ) - ( ( b.z - a.z ) * ( c.x -a.x ) )
  n.z = ( ( b.y - a.y ) * ( c.x - a.x ) ) - ( ( b.x - a.x ) * ( c.y -a.y ) )
  return n:normalize()
end


--[=[
От Malandrinus отсюда: http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=1006978

Проиграть произвольную анимацию худовой модели:

db.actor:set_hud_animation_channel(2)
db.actor:set_use_hud_animation_callback(true)
db.actor:set_hud_animation_callback_param(12345)
wpn:play_hud_animation("reload", true)

Колбек на окончание анимации вызывается для актора, код колбека 157.
В колбек передаётся один целый аргумент - то число, которое было установлено
вызовом db.actor:set_hud_animation_callback_param(<целое число>).
Так можно в колбеке различать, какая именно анимация закончилась.

uint<remaining_time> get_hud_animation_remaining_time() - возвращает время в миллисекундах, оставшееся до окончания текущей анимации.
int<length> get_hud_animation_length(string<anim_name>) - оставшееся время до окончания НЕ зацикленной анимации, меняется в реальном времени. Т.е. в начале, например твоей перезарядки метод вернет 2541, а в конце 0 (анимация закончена). Для зацикленных анимаций, НЕимеющих флаг Stop At End (idle, sprint и т.п.), всегда возвращает 0, т.к. они не имеют конца.
bool<is_cyclic> is_cyclic_hud_animation() - возвратит true, если текущая анимация зациклена.
bool<has_anim> has_hud_animation(string<anim_name>) - возвратит true, если анимация есть в модели.
--]=]

--[=[
http://www.amk-team.ru/forum/topic/10538-x-ray-extensions/?p=701404
Вот пример получения/записи значений для объекта актора.

db.actor:set_actor_shared_str("test", 1392)
local sss = {
    1392,
    1396,
    1400,
    1404,
    1408,
    1412,
}
for _, s1 in ipairs(sss) do
    set_int_arg0(s1)
    local s = db.actor:get_actor_shared_str()
    log1(""..s1.." "..s)
end
--]=]


-- возвращает имя кости по ее индексу
-- http://xray-engine.org/index.php?title=X-Ray_extensions
function get_bone_name_by_id( obj, bone_id )
  set_int_arg0( bone_id )
  return obj:get_bone_name()
end


-- возвращает level_vertex_id по позиции на уровне
function level.vertex_id_by_pos( position )
  db.actor:set_vector_global_arg_1( position )
  return level.vertex_id( position )
end


-- запускает эффектор шатания камеры с заданными параметрами
function level.add_cam_effector3( total_time, amplitude, period_number, power )
  level.set_ce_time( total_time )
  level.set_ce_amplitude( amplitude )
  level.set_ce_period_number( period_number )
  level.set_ce_power( power )
  level.add_ce()
end
