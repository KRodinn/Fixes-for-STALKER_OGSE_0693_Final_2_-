-----------------------------------------------------------------------
--- ogse_car_control.script
--- Продажа и спавн всего транспорта в игре
--- Модуль интерфейса и логики управления БТР
--- Авторы: KamikaZze, Dusty79, Malandrinus
--- version 2.0.00 (22/05/2014)
-----------------------------------------------------------------------


--local log_stream = io.open("..\\OGSE_LOGS\\ogse_car_control.txt", "a")
--function log1(str)
--	log_stream:write(str, '\n')
--	log_stream:flush()
--end

function attach(sm) -- для менеджера сигналов
	sm:subscribe({signal = "on_spawn",    fun = this.on_spawn})
	sm:subscribe({signal = "on_finalize", fun = this.on_finalize})
	sm:subscribe({signal = "on_key_down", fun = this.on_key_down})
	sm:subscribe({signal = "on_key_up",   fun = this.on_key_up})
	--sm:subscribe({signal = "on_key_hold", fun = this.on_key_hold})
	sm:subscribe({signal = "on_wheel",    fun = this.on_wheel})
	sm:subscribe({signal = "on_update",   fun = this.on_update})
	sm:subscribe({signal = "on_first_update",   fun = this.on_first_update})
	sm:subscribe({signal = "on_info",     fun = this.on_info})
end

local sim
local btr_hud_wnd
local car_hud_wnd
local surge = false
local alt_hud_bg
local fov_vol = sys_ini:r_s32("options","fov_volume")
local min_alarm_fov_vol = sys_ini:r_s32("options","min_fov_volume")
local max_alarm_fov_vol = sys_ini:r_s32("options","max_fov_volume")

local car_log
local debug_output = false

local function dbg_log(s)
	if debug_output and car_log then
		car_log:write(s, '\n')
		car_log:flush()
	end
end

function on_spawn(sactor)
	sim = alife()
	local bg = get_hud():AddCustomStatic("btr_hud_background", true):wnd() -- подложка для окна худа БТР
	bg:SetWidth(0)
	bg:SetColor(GetARGB(0,255,255,255))
	bg:SetWndRect(Frect():set(0,0,1024,768))

	bg:Show(true)
	btr_hud_wnd = btr_hud() -- если ещё не создали, то создать
	ASSERT(btr_hud_wnd, "ogse_car_control.on_spawn: btr_hud_wnd == nil") -- были проблемы при создании
	car_hud_wnd = car_hud()
	alt_hud_bg = CUIWindow()
	alt_hud_bg:Init(0,0,1024,768)
	alt_hud_bg:Show(true)
	get_hud():AddDialogToRender(alt_hud_bg)
	-- debug --
	if debug_output then
		local log_dir = getFS():update_path("$logs$", "car_log.txt")
		car_log = io.open(log_dir, "a+")
	end
	
	-- debug --
end

function detach_from_all()
	car_hud_wnd:DetachFromParent()
	btr_hud_wnd:DetachFromParent()
end

function on_finalize()
	detach_from_all()
	
	btr_hud_wnd.self = nil
	btr_hud_wnd = nil
	car_hud_wnd.self = nil
	car_hud_wnd = nil
	get_hud():RemoveDialogToRender(alt_hud_bg)
	alt_hud_bg = nil
	if car_log then car_log:close() end
end

function transfer_btr_hud_to_static()
	detach_from_all()
	local bg = get_hud():AddCustomStatic("btr_hud_background", true):wnd()
	bg:AttachChild(btr_hud_wnd)
	bg:AttachChild(car_hud_wnd)
	ogse_signals.get_mgr():call("on_hud_show")
end

function transfer_btr_hud_to_alt()
	detach_from_all()
	local bg = get_hud():AddCustomStatic("btr_hud_background", true):wnd()
	bg:AttachChild(car_hud_wnd)
	alt_hud_bg:AttachChild(btr_hud_wnd)
	btr_hud_wnd:Show(true)
	ogse_signals.get_mgr():call("on_hud_show")
end

in_btr = false
current_car = nil
local current_target_id = nil
local targets = {}

function actor_has_control_module() -- проверка на квестовый БТР
	if current_car and in_btr then
		local btr = level_object_by_sid(story_ids.dead_city_btr_real)
		if btr and btr:id() == ogse_car_control.current_car:id() then
			return db.actor:has_info("btr_control_set")
		else
			return true
		end
	end
	return false
end

function actor_has_power_unit() -- проверка на квестовый БТР
	if current_car and in_btr then
		local btr = level_object_by_sid(story_ids.dead_city_btr_real)
		if btr and btr:id() == ogse_car_control.current_car:id() then
			return db.actor:has_info("btr_get_accum_set")
		else
			return true
		end
	end
	return false
end

function register_target(obj)
	local t = {}
	t.obj_id = obj:id()
	t.obj = obj
	t.desc = resolve_target(obj)
	targets[t.obj_id] = t
	return t
end
function unregister_target(obj)
	targets[obj:id()] = nil
	if current_target_id == obj:id() then 
		current_target_id = nil
	end
end

local periscope_faile_fx_intensity     = 200                         -- интенсивность налагаемого эффекта визуального шума при выбросе (0-255)

local btr_fov_max_value               = fov_vol + 40  -- максимально допустимый для зумма БТР FOV (ZOOM-)
local btr_fov_min_value               = fov_vol - 70  -- минимально допустимый для зумма БТР FOV (ZOOM+)
local btr_fov_different               = 5                           -- изменение FOV за один щелчок оборота колёсика мыши
local target_detect_range             = 180                         -- радиус захвата целей
local target_max_range                = 150                         -- наибольший радиус сопровождения целей
local target_min_range                = 4                           -- наименьший радиус сопровождения целей
local auto_fire_broken_limit          = 0.35                        -- уровень исправности БТР, ниже которого автоматический режим выходит из строя
local recognition_target_broken_limit = 0.25                        -- уровень исправности БТР, ниже которого распознавание целей выходит из строя
local general_broken_limit            = 0.20                        -- уровень исправности БТР, ниже которого выдаётся тревожное сообщение
local snd_new_target                  = [[detectors\contact_8]]     -- звук при захвате новой цели
local snd_error                       = [[car\gear_old]]     -- звук при ошибке
local fix_camera_limits = false
need_companion_btr = true -- должна быть доступна снаружи

local reprioritize_timeout = 500 	-- интервал реприоретизации, мсек - нельзя делать слишком низким - будет судорожно метаться между целями
local memory_timeout = 60000		-- время, сколько помнить о появлении врага, миллиссекунд
local combat_mult_npc = 0.5			-- множитель веса ближней цели неписей
local combat_mult_monster = 0.3		-- множитель веса ближней цели неписей
local last_reprioritize		= nil
local primary_target = nil 			-- кого окучивать будем, id
local need_issue_targeting_warning = false -- предупредить о пиздеце под колесами
local need_warn_turret_failure = false
local targets_list = {		-- список целей

}
local last_target = {}				-- последняя цель, [id] = last_time 
------- структура записи таблицы
-- targets_list[npc_id] = {
	-- npc = непись или нет
	-- range = расстояние
	-- vis = видим или нет
-- }

local periscope_modes             = {manual = 1, target_select = 2, auto = 3,}
local periscope_mode              = periscope_modes.manual
local car_health                  = 0.0
local car_critically_damaged      = false
local auto_fire_operable          = true   -- флаг исправности автоматического режима
local recognition_target_mode     = true   -- флаг распознавания цели
local recognition_target_operable = true   -- флаг исправности распознавания цели

function is_manual_mode()
	return periscope_mode == periscope_modes.manual
end
function is_target_select_mode()
	return periscope_mode == periscope_modes.target_select
end
function is_auto_fire_mode()
	return periscope_mode == periscope_modes.auto
end

function is_recognition_target_active()
	return recognition_target_mode and recognition_target_operable
end

-- получить машину, на задницу которой мы смотрим
function car_which_trunk_we_looking_at()
	if current_car then return nil end
	local car = level.get_target_obj()
	if not car then return nil end
	local true_car = car:get_car()
	if true_car and true_car:GetfHealth() > 0.05 then
		local trunk_def = bind_car.read_door_definition(car, "trunk_door")
		local bone_name = trunk_def and trunk_def.bone_name or "exhausts"
		if db.actor:position():distance_to(car:bone_position(bone_name)) < 2 then
			return car
		end
	end
	return nil
end

-- получить машину, на топливный бак которой мы смотрим
function car_which_gastank_we_looking_at()
	if current_car then return nil end
	local car = level.get_target_obj()
	if not car then return nil end
	local true_car = car:get_car()
	if true_car and true_car:GetfHealth() > 0.05 then
		local ini = car:get_visual_ini()
		ASSERT(ini, "")
		local gas_tank_bone = get_string("car_definition", "gas_tank", "exhausts", ini)

		if db.actor:position():distance_to(car:bone_position(gas_tank_bone)) < 2 then
			return car
		end
	end
	return nil
end

function car_which_engine_door_we_looking_at()
	if current_car then return nil end
	local car = level.get_target_obj()
	if not car then return nil end
	local true_car = car:get_car()
	if true_car and true_car:GetfHealth() > 0.05 then
		local trunk_def = bind_car.read_door_definition(car, "engine_door")
		if trunk_def then
			if db.actor:position():distance_to(car:bone_position(trunk_def.bone_name)) < 2 then
				return car
			end
		end
	end
	return nil
end

-- коллбек на нажатие клавиши
function on_key_down(key, bind)
	if not db.actor or not db.actor:alive() then return end -- нет актора - нечего делать
	if level.main_input_receiver() then return end
	if not current_car then -- действия, имеющие смысл только при нахождении снаружи машины
		if bind == 15 then -- лезем в багажник
			local car = car_which_trunk_we_looking_at()
			if car then
				trunk_inv.open_trunk_dialog(car)
				ogse_signals.get_mgr():call("on_car_trunk_open", car)
			else
				local car = car_which_engine_door_we_looking_at()
				if car then
					ogse_signals.get_mgr():call("on_car_engine_open", car)
				end
			end
			return
		elseif bind == 56 then -- Заправка транспорта
			local car = car_which_gastank_we_looking_at()
			if car then
				refuel(car)
			end
			return
		end
	end
	
	if not in_btr then return end -- последующие действия имеют смысл только при нахождении внутри БТР
	
	if bind == key_bindings.kCAM_ZOOM_OUT then
		--if not level.main_input_receiver() then -- контроль худа
		--	hud_disable = true
		--end
	elseif bind == key_bindings.kCAM_ZOOM_IN then
		--if not level.main_input_receiver() then
		--	hud_disable = false
		--end
	elseif bind == key_bindings.kL_LOOKOUT then -- управление распознаванием
		if not recognition_target_operable then -- режим распознования сломался
			play_error_sound()
			return
		end
		if not actor_has_control_module() then
			play_error_sound()
			return		
		end
		recognition_target_mode = not recognition_target_mode -- переключаем режим
		switch_firing(current_car, false) -- надо прекратить стрелять на всякий случай
		current_target_id = nil
	elseif bind == key_bindings.kWPN_1 then -- установить ручной режим
		periscope_mode = periscope_modes.manual
		switch_firing(current_car, false) -- останавливаем огонь (если вдруг мы переключили режим при зажатой мыши во время огня)
		current_target_id = nil
	elseif bind == key_bindings.kWPN_2 then -- установить режим автонаведения с ручным выбором цели и ручным огнём
		if not actor_has_control_module() then
			play_error_sound()
			return		
		end	
		periscope_mode = periscope_modes.target_select
		switch_firing(current_car, false)
		current_target_id = nil
	elseif bind == key_bindings.kWPN_3 then -- установить полностью автоматический режим (наведение и огонь)
		if not actor_has_control_module() then
			play_error_sound()
			return		
		end	
		if not auto_fire_operable then
			play_error_sound()
			return
		end
		periscope_mode = periscope_modes.auto
		switch_firing(current_car, false) 
		current_target_id = nil
		-- также отключаем огонь, 
		-- хоть и автоматический режим, но пусть курок нажимает автоматический решатель, а пока прекращаем.
	elseif bind == key_bindings.kWPN_FIRE then -- начать стрелять (обычно левая крысо-кнопка)
		if is_auto_fire_mode() then -- если мы сейчас стреляли автоматически
			periscope_mode = periscope_modes.manual -- то переходим в полуавтоматический режим
		end
		if not actor_has_control_module() then
			play_error_sound()
			return		
		end		
		switch_firing(current_car, true)
	elseif bind == key_bindings.kWPN_ZOOM then -- переключение целей явным указанием (обычно правая крысо-кнопка)
		if is_manual_mode() or surge then -- работает в полуавтоматическом или автоматическом режимах и не работает во время выброса
			play_error_sound() -- пшик
			return
		end
		if not actor_has_control_module() then
			play_error_sound()
			return		
		end		
		local new_target_id = find_target_at_sight()
		if new_target_id then
			play_contact_sound()
			switch_firing(current_car, false)
			current_target_id = new_target_id
		end
	elseif bind == key_bindings.kR_LOOKOUT then -- управление распознаванием
		if is_manual_mode() or surge then -- работает в полуавтоматическом или автоматическом режимах и не работает во время выброса
			play_error_sound() -- пшик
			return
		end
		if not actor_has_control_module() then
			play_error_sound()
			return		
		end		
		local new_target_id = get_next_target()
		if new_target_id then
			play_contact_sound()
			switch_firing(current_car, false)
			current_target_id = new_target_id
		end
	end
end
-- получить следующую цель в списке
function get_next_target()
	-- ищем в два приёма:
	-- 1. От текущей цели до конца
	-- 2. От начала до текущей цели
	local id = current_target_id
	repeat 
		local target_item
		id, target_item = next(targets, id)
		if not id then -- дошли до конца, это также обработает ситуацию пустой таблицы целей
			break
		end
		if can_be_target(target_item.obj) then
			return id
		end
	until false
	-- если дошли до сюда, а текущей цели небыло, значит искали с начала и дошли до конца. Ничего не нашли и выходим
	if not current_target_id then return nil end
	-- иначе ищем в части массива, предшествующей текущей цели
	-- в этой точке id равен nil, значит будеи искать с начала таблицы
	repeat 
		local target_item
		id, target_item = next(targets, id)
		if can_be_target(target_item.obj) then
			return id
		end
	until id == current_target_id
	return id
end
-- найти цель по оси взгляда
function find_target_at_sight()
	local res_target_id
	local targ_dist = math.huge
	for id, target_item in pairs(targets) do
		local target = target_item.obj --level.object_by_id(id)
		if can_be_target(target) then
			local dist = target:position():distance_to(device().cam_pos)
			local dangerang = 1./dist
			local ang = horz_angle(device().cam_dir, target:position():sub(device().cam_pos))
			local tgt = ang > -dangerang and ang < dangerang
			if tgt and dist < targ_dist then
				targ_dist = dist
				res_target_id = id
			end
		end
	end
	return res_target_id
end

-- Проверка отпускания клавиш
function on_key_up(key, bind)
	if in_btr then
		if level.main_input_receiver() then return end
		-- управление огнём
		if bind == key_bindings.kWPN_FIRE then -- прекращаем огонь
			switch_firing(current_car, false)
		elseif bind == key_bindings.kWPN_ZOOM then
			--target_select_mode = false
		elseif key == 339 then -- управление зуммом
			db.actor:set_camera_fov(fov_vol)
		end
	end
end

-- Проверка удержания клавиш
function on_key_hold(key, bind)
end

-- Проверка вращения колесика мыши
function on_wheel(vol)
	if level.main_input_receiver() then return end
	local act = db.actor
	if in_btr and act and act:alive() then
		-- управление зуммом
		if vol == 0 then return end
		local current_fov = act:get_camera_fov()
		local new_fov = current_fov + (vol > 0 and 1 or -1) * btr_fov_different
		if new_fov < math.max(btr_fov_min_value, min_alarm_fov_vol) or new_fov > math.min(btr_fov_max_value, max_alarm_fov_vol) then
			return
		end
		act:set_camera_fov(new_fov)
	end
end

function on_update(delta) -- вызывается из менеджера 
	update_car_hud()
end

function on_info(npc, info_id)
	if info_id == "no_net_signal" then
		surge = true
	elseif info_id == "net_signal" then
		surge = false
	end
	update_car_hud()
	if in_btr then
		if info_id == "ui_pda" or info_id == "ui_inventory" then
			transfer_btr_hud_to_alt()
			btr_hud_wnd.emty:Show(true)
		elseif info_id == "ui_pda_hide" or info_id == "ui_inventory_hide" then
			transfer_btr_hud_to_static()
			btr_hud_wnd.emty:Show(false)
		end
	end
end

-------------------------------------------------------------------------------------------------------------
-- функция заправки машины топливом
-------------------------------------------------------------------------------------------------------------
function refuel(car)
	ASSERT(car, "refuel: car is a nil reference")
	local item = db.actor:object("explosive_mobiltank")
	if not item then
		ogse_screen_msg.show_message_trouble(game.translate_string("ogse_car_no_fuel_text"))
		return
	end			
	local fuel = car:get_fuel()
	local fuel_tank = car:get_fuel_tank()
	if fuel_tank - fuel <= 10 then
		ogse_screen_msg.show_message_trouble(game.translate_string("ogse_car_not_need_fuel_text"))
		return 
	end
	fuel = fuel + 10
	if fuel > fuel_tank then
		fuel = fuel_tank
	end
	car:set_fuel(fuel)
	ogse_screen_msg.show_message_use_item(item:section())
	alife():release(alife():object(item:id()), true)
end

class "car_hud" (CUIScriptWnd)
function car_hud:__init() super()
	local xml = CScriptXmlInit()
	xml:ParseFile("ogse_car_fuel.xml")
	xml:InitWindow("main", 0, self)
	self.bg = xml:InitStatic("car_fuel_back", self)
	self.fuel_level = xml:InitStatic("car_fuel_back:fuel_level", self.bg)
	self.max_width = self.fuel_level:GetWidth()
	self:Show(true)
	self.self = self
end
		
class "btr_hud" (CUIScriptWnd)

function btr_hud:__init() super()
	local xml = CScriptXmlInit()
	xml:ParseFile("ogse_btr_hud.xml")
	xml:InitWindow("main", 0, self)
	self.noise            = xml:InitStatic("main:noise_static", self)
	self.noise:SetColor(GetARGB(periscope_faile_fx_intensity,255,255,255))
	self.noise:Show(false)
	self.grid             = xml:InitStatic("main:grid_static", self)
	self.hud_target       = xml:InitStatic("main:hud_target", self)
	self.hud_target:Show(false)
	self.hud_target:SetColor(GetARGB(255, 0, 255, 117))
	self.target           = xml:InitStatic("main:target", self)
	self.zoom             = xml:InitStatic("main:zoom", self)
	self.armor            = xml:InitStatic("main:armor", self)
	self.critical         = xml:InitStatic("main:critical", self)
	self.recognition_mode = xml:InitStatic("main:recognition_mode", self)
	self.fire_mode        = xml:InitStatic("main:firing_mode", self)
	self.target_select    = xml:InitStatic("main:target_select", self)
	self.target_obstacle  = xml:InitStatic("main:target_obstacle", self)
	self.emty             = xml:InitStatic("main:off_bkgnd", self)
	self.emty:Show(false)
	self.frame            = xml:InitStatic("main:frame_static", self)
	self:Show(true)
	self.self = self
end
function btr_hud:enable_noise(enable)
	self.noise:Show(enable)
end

--===============< непосредственно управление оружием машины >=================--
local explode_old_value = 0
-- активация/деактивация пушки
function enable_car_gun(car, enable)
	local script_car = car:get_car()
	if script_car:HasWeapon() then
		script_car:Action(CCar.eWpnActivate, enable and 1 or 0)
	end	
end

local avoid_bug = 0
-- обновление направления пушки
function update_car_gun_direction(car)
	local script_car = car:get_car()
	if not script_car:HasWeapon() then return end -- у машины нет оружия
	local position
	local explode = script_car:ExplodeTime()
	if explode_old_value == 0 then
		explode_old_value = explode
		avoid_bug = time_global()
	else	
		if explode_old_value ~= explode then
			avoid_bug = time_global() + 2000
			explode_old_value = explode
		end
	end
	if debug_output then log1("CAR_EXPLODE "..tostring(explode).." AVOID "..tostring(avoid_bug)) end
	if is_manual_mode() then -- ручной контроль
		local dev = device()
		local dist = level.get_target_dist()
		if dist < 1 then dist = 100 end
		position = dev.cam_pos:mad(dev.cam_dir, dist)
		if debug_output then
			log1("DEBUG_BTR MAD cam_pos:["..dev.cam_pos.x..","..dev.cam_pos.y..","..dev.cam_pos.z.."]")
			log1("DEBUG_BTR MAD cam_dir:["..dev.cam_dir.x..","..dev.cam_dir.y..","..dev.cam_dir.z.."]")
			log1("DEBUG_BTR MAD dist:["..dist.."]")
			log1("DEBUG_BTR MAD RESULT:["..position.x..","..position.y..","..position.z.."]")
		end
	elseif is_target_select_mode() or (is_auto_fire_mode() and auto_fire_operable) then -- автоматический контроль
		local targ_item = targets[current_target_id]
		local targ
		if targ_item then
			targ = targ_item.obj
		end
		if not targ or not targ:alive() then -- цель отсутствует, в оффлайне или дохлая
			current_target_id = nil
			if avoid_bug < time_global() or not actor_has_control_module() then
				if debug_output then
					log1("DEBUG_BTR MAD VAR:[1]")
				end
				script_car:SetParam(CCar.eWpnToDefaultDir, vector())
				need_warn_turret_failure = false
			else	
				need_warn_turret_failure = true
			end
			return
		end
		position = get_aiming_point_for_target(targ)
		if debug_output then
			log1("DEBUG_BTR MAD RESULT_2:["..position.x..","..position.y..","..position.z.."]")
		end
	end
	if avoid_bug < time_global() or not actor_has_control_module() then
		if position then
			if debug_output then
				log1("DEBUG_BTR MAD [2]:["..position.x..","..position.y..","..position.z.."]")
			end
			script_car:SetParam(CCar.eWpnDesiredPos, position)
		end
		need_warn_turret_failure = false
	else	
		need_warn_turret_failure = true
	end
end
-- включение/выключение огня
local cannon_firing = false
function switch_firing(car, fire)
	ASSERT(car, "switch_firing: car is a nil reference")
	local script_car = car:get_car()
	ASSERT(script_car, "switch_firing: script_car is a nil reference, object is not a car!")
	if not script_car:HasWeapon() then return end
	if cannon_firing ~= fire then
		local v = fire and 1 or 0
		script_car:Action(CCar.eWpnAutoFire,v)
		script_car:Action(CCar.eWpnFire, v)						
		cannon_firing = fire
	end
end
-- получить машину, в которой сидит ГГ
function get_actor_car()
	local holder_id = db.actor:get_actor_int16(nil, 1240)
	local hldr = level.object_by_id(holder_id)
	if hldr and hldr:is_car() then return hldr end
	return nil
end
function setup_car_camera(car)
	ASSERT(car, "setup_car_camera: 'car' parameter is a nil reference!")
	local visual_ini = car:get_visual_ini()
	if visual_ini:section_exist("car_camera") then
		local lim_pitch_min, lim_pitch_max = get_vector2("car_camera", "lim_pitch", nil, visual_ini)
		ASSERT(lim_pitch_min and lim_pitch_max and (lim_pitch_min < lim_pitch_max), "setup_car_camera: 'lim_pitch' is not defined properly for '%s'", car:section())
		local lim_yaw_min, lim_yaw_max = get_vector2("car_camera", "lim_yaw", nil, visual_ini)
		ASSERT(lim_yaw_min and lim_yaw_max and (lim_yaw_min < lim_yaw_max), "setup_car_camera: 'lim_yaw' is not defined properly for '%s'", car:section())
		local rot_speed = get_vector("car_camera", "rot_speed", nil, visual_ini)
		ASSERT(rot_speed, "setup_car_camera: 'rot_speed' is not defined properly for '%s'", car:section())
		--
		local cam_cur_addr = car:get_car_int(nil, 1320)
		car:set_memory_float(nil, lim_yaw_min, sum_args_ex(cam_cur_addr, 40))
		car:set_memory_float(nil, lim_yaw_max, sum_args_ex(cam_cur_addr, 44))
		car:set_memory_float(nil, lim_pitch_min, sum_args_ex(cam_cur_addr, 48))
		car:set_memory_float(nil, lim_pitch_max, sum_args_ex(cam_cur_addr, 52))

		car:set_memory_float(nil, rot_speed.x, sum_args_ex(cam_cur_addr, 64))
		car:set_memory_float(nil, rot_speed.y, sum_args_ex(cam_cur_addr, 68))
		car:set_memory_float(nil, rot_speed.z, sum_args_ex(cam_cur_addr, 72))
		fix_camera_limits = get_bool("car_camera", "fix_camera_limits", false, visual_ini)
	end
end

function on_first_update()
	SetDetailsMinRadius(current_car and 2.0 or 0.0)

	if db.actor:has_info("no_net_signal") then
		surge = true
	end
end

function update_car_hud()
	local car = get_actor_car() -- получаем машину, в которой сидит ГГ
	-- обновляем состояние машины
	if car then
		update_car_states(car)
		if fix_camera_limits then
			local cam_cur_addr = car:get_car_int(nil, 1320)
			local ang = car:get_memory_float(sum_args_ex(cam_cur_addr, 20))
			if math.abs(ang) > 2*math.pi then
				local ang2 = math.fmod(ang, 2*math.pi)
				car:set_memory_float(nil, ang2, sum_args_ex(cam_cur_addr, 20))
			end
		end
	end
	-- что-то делаем по факту смены состояния внутри/снаружи
	if car and not current_car then -- только что залезли в машину
		SetDetailsMinRadius(2.0) -- убираем траву из под ног
		setup_car_camera(car)
		db.actor:hide_weapon()
		db.actor:set_actor_int(1432, 0)
		db.actor:set_actor_int(1428, 0)
		current_car = car
		in_btr = string.find(car:section(), "btr") ~= nil
		if in_btr then
			enable_car_gun(car, true)
			--set_actor_invincible(true)
		end
		show_car_hud(car, in_btr)
		ogse_signals.get_mgr():call("on_hud_show")
	elseif not car and current_car then -- только что вылезли из машины
		SetDetailsMinRadius(0.0) -- вертаем траву обратно
		fix_camera_limits = false
		db.actor:restore_weapon()
		switch_firing(current_car, false)
		current_car = nil
		hide_car_hud(in_btr)
		if in_btr then
			in_btr = false
			--set_actor_invincible(false)
		end
	end
	if car then
		local new_width = (car:get_fuel() / car:get_fuel_tank()) * car_hud_wnd.max_width
		car_hud_wnd.fuel_level:SetWidth(new_width)
	end
	if in_btr then
		update_btr_targets(car)
		update_car_gun_direction(car)
		update_btr_hud(car)
		update_fire_status(car)
	end
end
function on_car_death(car)
	if current_car and car:id() == current_car:id() then
		db.actor:kill(db.actor)
	end
	update_car_hud()
end

function update_car_states(car)
	local script_car = car:get_car()
	car_health = script_car:GetfHealth()
	
	-- need_companion_btr
	if has_alife_info("btr_targeting_computer") then
		need_companion_btr = false	
	end	
	
	if need_companion_btr == true then
		auto_fire_operable          = car_health >= auto_fire_broken_limit          and not surge and xr_companion.is_inside_my_car() and actor_has_control_module()
	else
		auto_fire_operable          = car_health >= auto_fire_broken_limit          and not surge and actor_has_control_module()
	end
	recognition_target_operable = car_health >= recognition_target_broken_limit and not surge and actor_has_control_module()
	car_critically_damaged      = car_health < general_broken_limit
end
function show_car_hud(car, btr)
	detach_from_all()
	local bg = get_hud():AddCustomStatic("btr_hud_background", true):wnd() -- подложка для окна худа БТР
	if btr then
		bg:AttachChild(btr_hud_wnd) -- поместить окно на подложку
		db.actor:set_camera_fov(fov_vol)
		current_target_id = nil

		ogse_signals.get_mgr():call("on_show_car_hud")
	end
	bg:AttachChild(car_hud_wnd) -- поместить окно на подложку
end
function hide_car_hud(btr)
	detach_from_all()
	if btr then
		db.actor:set_camera_fov(fov_vol)
		current_target_id = nil
		db.actor:set_camera_fov(fov_vol)

		ogse_signals.get_mgr():call("on_hide_car_hud")
	end
end

local chech_count = 0

-- обновление всех элементов худа
function update_btr_hud(car)
	if not in_btr or not db.actor then return end
	-- обновление видимости шума на экране
	btr_hud_wnd:enable_noise(in_btr and (surge or not actor_has_power_unit()))
	
	if not actor_has_power_unit() then
		btr_hud_wnd.critical:SetText(game.translate_string("btr_error_power_offline_text"))
		return
	end
	
	if car_critically_damaged then
		if chech_count == 0 then
			local s = (math.random() > 0.5) and game.translate_string("ogse_car_fire_warning_1_text") or game.translate_string("ogse_car_fire_warning_2_text")
			btr_hud_wnd.critical:SetText(s)
		end
		chech_count = chech_count + 1
		if chech_count >= 50 then
			chech_count = 0
		end
	end
	
	if not actor_has_control_module() then
		btr_hud_wnd.critical:SetText(game.translate_string("btr_error_1_text"))
	elseif not car_critically_damaged then	
		btr_hud_wnd.critical:SetText("")
	end
	--
	btr_hud_wnd.armor:SetText(string.format(game.translate_string("ogse_car_armor_state_text").." %3.0f%%", car_health*100))
	--
	if need_issue_targeting_warning and is_auto_fire_mode() then
		btr_hud_wnd.target_select:SetText(game.translate_string("ogse_car_enemy_too_near_text"))
	elseif need_warn_turret_failure then
		btr_hud_wnd.target_select:SetText(game.translate_string("ogse_car_turret_failure_text"))
	else
		if actor_has_control_module() then
			btr_hud_wnd.target_select:SetText(is_target_select_mode() and game.translate_string("ogse_car_following_target_text") or "")
		else
			btr_hud_wnd.target_select:SetText(game.translate_string("btr_error_2_text"))
		end
	end
	--
	btr_hud_wnd.zoom:SetText(string.format("X %.2f", fov_vol/db.actor:get_camera_fov()))
	--
	local s = game.translate_string("ogse_car_mode_text")
	if surge then
		s = s..game.translate_string("ogse_car_fail_text")
	elseif is_auto_fire_mode() then
		if auto_fire_operable then
			if need_companion_btr then
				s = s..game.translate_string("ogse_car_human_gunner_text")
			else
				s = s..game.translate_string("ogse_car_automatic_text")
			end
		else
			s = s..game.translate_string("ogse_car_broken_text")
		end
	elseif is_target_select_mode() then
		s = s..game.translate_string("ogse_car_semiauto_text")
	elseif is_manual_mode() then
		s = s..game.translate_string("ogse_car_manual_text")
	else
		abort("Wrong periscope state!")
	end
	if actor_has_control_module() then
		btr_hud_wnd.fire_mode:SetText(s)
	else	
		btr_hud_wnd.fire_mode:SetText(game.translate_string("btr_error_3_text"))
	end
	--
	local s = game.translate_string("ogse_car_fof_text")
	if surge then
		s = s..game.translate_string("ogse_car_fail_text")
	elseif is_manual_mode() then
		s = s..game.translate_string("ogse_car_blocked_text")
	elseif is_recognition_target_active() then
		if recognition_target_operable then
			s = s..game.translate_string("ogse_car_on_text")
		else
			s = s..game.translate_string("ogse_car_broken_text")
		end
	else
		s = s..game.translate_string("ogse_car_off_text")
	end
	
	if actor_has_control_module() then
		btr_hud_wnd.recognition_mode:SetText(s)
	else
		btr_hud_wnd.recognition_mode:SetText(game.translate_string("btr_error_3_text"))
	end
	--
	-- состояние стрельбы
	local script_car = car:get_car()
	local target_str = game.translate_string("ogse_car_no_targ_text")
	local obstacle_ind_visible = false
	if is_manual_mode() then
		target_str = ""
	elseif not recognition_target_operable then
		target_str = game.translate_string("ogse_car_targ_failure_text")
	elseif current_target_id then
		local target_obj = level.object_by_id(current_target_id)
		if target_obj then
			local str = resolve_target(target_obj)
			target_str = str and (game.translate_string("ogse_car_cur_targ_text")..tostring(str).." -") or game.translate_string("ogse_car_targ_unknown_text")
			obstacle_ind_visible = not script_car:IsObjectVisible(target_obj)
		end
	end
	btr_hud_wnd.target_obstacle:Show(obstacle_ind_visible)
	btr_hud_wnd.target:SetText(target_str)
	--------------------------------------------------------------------------------------------
	-- маркер цели
	update_target_marker()
	do return end
	--------------------------------------------------------------------------------------------
	-- текущая цель
	if current_target_id then
		local tget = level.object_by_id(current_target_id)
		if tget then
			local tget_dist = tget:position():distance_to(db.actor:position())
			if tget_dist > target_max_range or tget_dist < target_min_range then
				tget = nil
				current_target_id = nil
			end
		else
			current_target_id = nil
		end
	end
	
end

local turrets_sections = {turret_mgun == true, turret_army = true, turret_nato = true,}
function is_enemy_turret(npc, turret)
    -- сначала выясним, турель ли это вообще.
    if not turrets_sections[turret:section()] then
        return false
    end
    local community = db.storage[turret:id()].community
    if community and utils2.community_relation(community, npc) <= -500 then
        return true
    end
    return false
end

function is_enemy(object)
	return object:relation(db.actor) == game_object.enemy or is_enemy_turret(db.actor, object) or object:is_monster()
end

function has_heavy_fire_power(object)
	local name = object:name()
	return string.find(name, "turret") ~= nil or string.find(name, "btr") ~= nil
end

function can_be_target(object)
	if object:id() == current_car:id() then return false end -- объект - наша сабственная машина
	if is_recognition_target_active() and not is_enemy(object) then return false end -- если работает распознавание свой/чужой и цель нам не враг, то игнорируем
	local obj_dist = object:position():distance_to(db.actor:position()) -- расстояние от актора до объекта
	if obj_dist > target_detect_range or (obj_dist < target_min_range and not is_auto_fire_mode()) then return false end -- цель вне пределов досягаемости - игнорируем
	return true
end

function combat_multiplier(enemy_is_npc)
	if enemy_is_npc then
		return combat_mult_npc
	else
		return combat_mult_monster
	end
end

function process_enemy(car, enemy)
	if enemy and enemy:alive() and enemy:id() ~= db.actor:id() then
		if (IsStalker(enemy) or IsMonster(enemy)) then
			-- человек ты иль монструшка
			register_as_target(car, enemy)
		else
			return
		end
	end
end

function register_as_target(car, enemy)
	local id = enemy:id()
	if not targets_list[id] then
		local script_car = car:get_car()
		local dist = car:position():distance_to(enemy:position())
		local enemy_record = {
			npc = false,
			range = 0,
			vis = false		
		}
		enemy_record.npc = IsStalker(enemy)
		enemy_record.range = dist
		enemy_record.vis = script_car:IsObjectVisible(enemy) or enemy:see(car) -- мы видим текущую цель или она видит нас
		enemy_record.weight = 1000
		if enemy_record.vis == true and enemy_record.npc == true then
			enemy_record.last_time_seen = time_global()
			enemy_record.vertex = enemy:level_vertex_id()
		end
		targets_list[id] = enemy_record
	end
end

function get_targets_from_registry(car)
	-- сбор врагов, вызывается из reprioritize_targets
	for id, target_item in pairs(targets) do
		local target = target_item.obj --level.object_by_id(id)
		if can_be_target(target) then
			process_enemy(car,target)
		end
	end
end

function refresh_targets_btr(car)
	-- обновление реестра врагов, вызывается из апдейта
		need_issue_targeting_warning = false
	--
	local script_car = car:get_car()
	for k, v in pairs(targets_list) do
		local check_target = level.object_by_id(k)
		if check_target and check_target:alive() then
			local dist	= car:position():distance_to(check_target:position())
			local vis	= script_car:IsObjectVisible(check_target) or check_target:see(car) -- мы видим текущую цель или она видит нас
			v.range	= dist
			if vis then
				v.vis	= true
			else	
				v.vis	= false
			end
			if v.vis == false then
				if v.npc == false then
					if dist > (target_max_range/2) then
						if primary_target == k then
							last_target[primary_target] = time_global()
							primary_target = nil
						end
						targets_list[k] = nil
					elseif dist <= target_min_range then
						need_issue_targeting_warning = true
						if primary_target == k then
							last_target[primary_target] = time_global()
							primary_target = nil
						end
						targets_list[k] = nil						
					end
				else
					if dist > target_max_range then
						if primary_target == k then
							last_target[primary_target] = time_global()
							primary_target = nil
						end	
						targets_list[k] = nil
					elseif dist <= target_min_range then	
						need_issue_targeting_warning = true
						if primary_target == k then
							last_target[primary_target] = time_global()
							primary_target = nil
						end
						targets_list[k] = nil						
					else
						if script_car:IsObjectVisible(check_target) then
							v.last_time_seen = time_global()
							v.vertex = check_target:level_vertex_id()
						end						
					end
				end
			else
				if v.npc == true then
					v.last_time_seen = time_global()
					v.vertex = check_target:level_vertex_id()
				end
				if dist <= target_min_range then
					need_issue_targeting_warning = true
					if primary_target == k then
						last_target[primary_target] = time_global()
						primary_target = nil
					end
						targets_list[k] = nil						
					end				
				end
		elseif check_target then
			if primary_target == k then
				last_target[primary_target] = time_global()
				primary_target = nil
			end
			targets_list[k] = nil			
		else	
			if primary_target == k then
				primary_target = nil
			end
			targets_list[k] = nil			
		end
	end
	table.sort(targets_list,function(a,b) return a.range < b.range end)
end

function reprioritize_targets(car)
	-- обновление основной цели, вызывается из апдейта
	-- обновим предварительно реестр целей
	
	if last_reprioritize and time_global() < (last_reprioritize+reprioritize_timeout) and primary_target then
		return
	end
	
	get_targets_from_registry(car)
	refresh_targets_btr(car)
	
	--
	if debug_output then
		print_table_inlog_v2(targets_list, "TARGS_BTR>>")
	end
	-- На дистанциях выше 20 метров приоритет неписям, ближе 20 метров приоритет монстрам. При дистанции ниже 10 метров но выше минимальной объект сразу становится примари_таргет без вариантов. 
	-- При варианте далее 20 метров проверяем видимость, приоритет видимому.
	local last_weight 	= 1000
	
	for k, v in pairs(targets_list) do
		if v.vis == true then -- если цель видит нас
			local close_combat, far_combat = 20, 100
			local mult = combat_multiplier(v.npc)
			if v.npc == true then -- если она непись
				if v.range >= close_combat and v.range < far_combat then -- и цель на средней дистанции
					v.weight = v.range * combat_multiplier(v.npc)
				elseif v.range < close_combat then -- а если вплотную
					v.weight = 0
				end
			else -- а если монстр
				if v.range >= close_combat and v.range < far_combat then -- если не ближний бой
					v.weight = v.range
				elseif v.range < close_combat then -- а если ближний
					v.weight = v.range * combat_multiplier(v.npc)
				end
			end
		else -- если невидима
			if primary_target == k then
				last_target[primary_target] = time_global()
				primary_target = nil
			end
			if v.npc == false then -- если она монстр
				if v.range < 20 then 
					v.weight = v.range * 2
				else
					v.weight = 1000
				end
			else -- а если непись
				if v.range < 50 then -- если в радиусе "слуха"
					v.weight = v.range * 3
				elseif v.range < 100 then -- если в радиусе максимального отхода от ГГ
					if v.last_time_seen and (v.last_time_seen + memory_timeout) > time_global() then -- если видели её не менее минуты назад
						v.weight = v.range * 4
					else	
						v.weight = 1000
					end					
				else
					v.weight = 1000
				end
			end
		end
	end

	for k, v in pairs(targets_list) do
		if v.weight < last_weight then
			last_weight = v.weight
			primary_target = k
			last_target = {}
		end	
	end
	
	if primary_target ~= nil then
		last_reprioritize = time_global()
		if debug_output then
			log1("--BTR_SKYNET_COMBAT: Выбрана цель: "..tostring(primary_target))
		end
		return
	else
		last_target = {}
	end

end

function update_btr_targets(car)

	if not in_btr then return false end
	if not (is_auto_fire_mode() and auto_fire_operable) then return false end
	
	reprioritize_targets(car)
	
	if primary_target then
		current_target_id = primary_target
	else	
		current_target_id = nil
	end

end

function update_fire_status(car)

	if not in_btr then return false end
	if not (is_auto_fire_mode() and auto_fire_operable) or not actor_has_control_module() then return false end
	local script_car = car:get_car()
	
	if current_target_id then
		-- стреляем
		local tget = level.object_by_id(current_target_id)
		switch_firing(car, (script_car:IsObjectVisible(tget) or tget:see(db.actor)))
	else	
		-- прекращаем
		switch_firing(car, false)
	end	

end

-- Возвращает угол между проекциями векторов vec1 и vec2 на горизонтальную плоскость
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle(vec1,vec2)
	local a = vec1:getH() - vec2:getH()
	if a < -math.pi then return a + 2*math.pi end
	if a > math.pi then return a - 2*math.pi end
	return a
end

local stalkers_comm2desc = {
	["stalker"]  = game.translate_string("ogse_car_stalkers_comm2desc_1_text"),
	["quest_stalker"]  = game.translate_string("ogse_car_stalkers_comm2desc_2_text"),
	["kulg_band"]  = game.translate_string("ogse_car_stalkers_comm2desc_3_text"),
	["kulg_band_2"]  = game.translate_string("ogse_car_stalkers_comm2desc_3_text"),
	["bratstvo_9"]  = game.translate_string("ogse_car_stalkers_comm2desc_4_text"),
	["iskatel"]  = game.translate_string("ogse_car_stalkers_comm2desc_5_text"),
	["monolith"] = game.translate_string("ogse_car_stalkers_comm2desc_6_text"),
	["military"] = game.translate_string("ogse_car_stalkers_comm2desc_7_text"),
	["neutral_military"] = game.translate_string("ogse_car_stalkers_comm2desc_7_text"),	
	["killer"]   = game.translate_string("ogse_car_stalkers_comm2desc_8_text"),
	["neutral_killer"]   = game.translate_string("ogse_car_stalkers_comm2desc_8_text"),	
	["ecolog"]   = game.translate_string("ogse_car_stalkers_comm2desc_9_text"),
	["dolg"]     = game.translate_string("ogse_car_stalkers_comm2desc_10_text"),
	["freedom"]  = game.translate_string("ogse_car_stalkers_comm2desc_11_text"),
	["bandit"]   = game.translate_string("ogse_car_stalkers_comm2desc_3_text"),
	["zombied"]  = game.translate_string("ogse_car_stalkers_comm2desc_12_text"),
	["stranger"] = game.translate_string("ogse_car_stalkers_comm2desc_13_text"),
	["trader"]   = game.translate_string("ogse_car_stalkers_comm2desc_14_text"),
	["csky"]     = game.translate_string("ogse_car_stalkers_comm2desc_15_text")
}
local objects_sec2desc = {
	["boar"]        = game.translate_string("ogse_car_objects_sec2desc_1_text"),
	["bloodsucker"] = game.translate_string("ogse_car_objects_sec2desc_2_text"),
	["flesh"]       = game.translate_string("ogse_car_objects_sec2desc_3_text"),
	["dog"]         = game.translate_string("ogse_car_objects_sec2desc_4_text"),
	["pseudodog"]   = game.translate_string("ogse_car_objects_sec2desc_5_text"),
	["cat"]         = game.translate_string("ogse_car_objects_sec2desc_6_text"),
	["chimera"]     = game.translate_string("ogse_car_objects_sec2desc_7_text"),
	["gigant"]      = game.translate_string("ogse_car_objects_sec2desc_8_text"),
	["zombie"]      = game.translate_string("ogse_car_objects_sec2desc_9_text"),
	["burer"]       = game.translate_string("ogse_car_objects_sec2desc_10_text"),
	["controller"]  = game.translate_string("ogse_car_objects_sec2desc_11_text"),
	["poltergeist"] = game.translate_string("ogse_car_objects_sec2desc_12_text"),
	["snork"]       = game.translate_string("ogse_car_objects_sec2desc_13_text"),
	["fracture"]    = game.translate_string("ogse_car_objects_sec2desc_14_text"),
	["bird"]        = game.translate_string("ogse_car_objects_sec2desc_15_text"),
	["rat"]         = game.translate_string("ogse_car_objects_sec2desc_16_text"),
	["tushkano"]    = game.translate_string("ogse_car_objects_sec2desc_17_text"),
	--
	["helicop"]     = game.translate_string("ogse_car_objects_sec2desc_18_text"),
	["turret"]      = game.translate_string("ogse_car_objects_sec2desc_19_text"),
	["btr"]         = game.translate_string("ogse_car_objects_sec2desc_20_text"),
}
local sec2desc_cache = {}
function resolve_target(target)
	ASSERT(target, "resolve_target: target is nil reference")
	local sec = target:section()
	local tid = target:id()
	local descript = sec2desc_cache[tostring(sec)..tostring(tid)]
	if descript then return descript end
	local pattern, list
	if target:is_stalker() then
		pattern, list = target:character_community(), stalkers_comm2desc
	else
		pattern, list = sec, objects_sec2desc
	end
	for k,desc in pairs(list) do
		if string.find(pattern, k) then
			sec2desc_cache[tostring(sec)..tostring(tid)] = desc
			return desc
		end
	end
	descript = game.translate_string("ogse_car_unrecognized_text")
	sec2desc_cache[tostring(sec)..tostring(tid)] = descript
	return descript
end

function btr_kill(victim)
	relation_registry.set_community_goodwill(victim:character_community(), db.actor:id(), -50)
	if victim:relation(db.actor) == game_object.neutral then
		db.actor:change_character_reputation(-25)
	elseif victim:relation(db.actor) == game_object.friend then
		db.actor:change_character_reputation(-50)
	end
	for k, v in pairs(db.creature) do
		local obj = level.object_by_id(k)
		if obj and v == true and obj:character_community() == victim:character_community() and obj:position():distance_to(victim:position()) < 30 then
			obj:set_relation(game_object.enemy, db.actor)
		end	
	end
end

function play_contact_sound()
	local snd_obj = xr_sound.get_safe_sound_object(snd_new_target)
	snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
end

function play_error_sound()
	local snd_obj = xr_sound.get_safe_sound_object(snd_error)
	snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
end

----------------------------------------------------------------------------------------------------
--/ Модуль интерфейса прицельной марки БТР /--

local target_textures = {
	[true]  = {[true] = [[ui\target_mark]],       [false] = [[ui\target_mark_dots]]},
	[false] = {[true] = [[ui\target_mark_cross]], [false] = [[ui\target_mark_cross_dots]]},
}
local target_colors = {[true] = GetARGB(255, 255, 0, 0), [false] = GetARGB(255, 0, 255, 117)}

-- Обновляет прицельные метки
function update_target_marker()
	if not current_target_id then
		btr_hud_wnd.hud_target:Show(false)
		return
	end
	btr_hud_wnd.hud_target:Show(true)
	local target = targets[current_target_id]
	
	local script_car = current_car:get_car()
	local obj_vis = script_car:IsObjectVisible(target.obj)
	local dist = target.obj:position():distance_to(db.actor:position())
	local recognized_as_enemy = is_recognition_target_active() and is_enemy(target.obj)
	local texture = target_textures[recognized_as_enemy][obj_vis]
	btr_hud_wnd.hud_target:InitTexture(texture)
	btr_hud_wnd.hud_target:SetColor(target_colors[recognized_as_enemy])
	btr_hud_wnd.hud_target:SetTextColor(target_colors[recognized_as_enemy])
	btr_hud_wnd.hud_target:SetTextST(string.format("%.1f", dist))
	--
	local x,y,z = get_screen_coords(get_aiming_point_for_target(target.obj))
	btr_hud_wnd.hud_target:Show(z > 0)
	btr_hud_wnd.hud_target:SetWndPos(x - 32, y - 32)
end

local clsid2target_bone = {
	[clsid.turret_mgun]   = "wpn_body1",
	[clsid.wpn_mounted]   = "wpn_body1",
	[clsid.wpn_stat_mgun] = "wpn_body1",
	[clsid.script_heli]   = "pilot2", -- "root"
	[clsid.helicopter]    = "pilot2",
	[clsid.car_s]         = "root",
	[clsid.car]           = "root",
}
function get_aiming_point_for_target(targ)
	if targ:is_stalker() then
		return targ:bone_position("bip01_pelvis")
	elseif targ:is_monster() then
		return targ:bone_position("bip01_spine")
	else
		local bone_name = clsid2target_bone[targ:clsid()]
		if bone_name then
			return targ:bone_position(bone_name)
		else
			return targ:position()
		end
	end
end

function get_screen_coords(point)
    local dev = device()
    local scr_w = dev.width
    local scr_h = dev.height

    local fov2 = (dev.fov/2) * (math.pi/180)
    local scr_dist = 0.5 * scr_h / math.tan(fov2)

    local ppp = vector():sub(point, dev.cam_pos)
    local dp = dev.cam_dir:dotproduct(ppp)

    local x = 512 + dev.cam_right:dotproduct(ppp) * scr_dist / dp * (1024/scr_w)
    local y = 384 - dev.cam_top:dotproduct(ppp)   * scr_dist / dp * (768/scr_h)
    return x, y, scr_dist
end
