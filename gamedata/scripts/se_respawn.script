--[[------------------------------------------------------------------------------------------------------------------
Respawner. Схема обновления популяции всего всего всего в симуляции.
by Stohe (Диденко Руслан)
--------------------------------------------------------------------------------------------------------------------]]
-- Поправки: Колмогор, KamikaZze
--------------------------------------------------------------------------------------------------------------------]]
-- Доработано под нужды мода OGSE 0.6.9.2 KamikaZze
--------------------------------------------------------------------------------------------------------------------]]
local t_common = sys_ini:r_s32("options","t_common")


local section_name = "respawn"
local i,k,v = 0,0,0

local simMaxCount = {
}

local debug_flag = false
-------------------------------------------------------
---' Регулярная проверка численности и доспавн
-------------------------------------------------------
---' Табличка для хранения численности
-------------------------------------------------------
population_human	= {}
population_factions	= {}
population_monster	= {}
-------------------------------------------------------
---' Лимиты населения
-------------------------------------------------------
---: ВНИМАНИЕ! Корректируя эту таблицу не забывайте править
---: и таблицу factions_limit
local npc_limit = {

-- 100
["bandit_novice"]			= 60,
["bandit_regular"]			= 45,
["bandit_veteran"]			= 23,
["bandit_master"]			= 22,

-- 65
["dolg_novice"]				= 10,
["dolg_regular"]			= 25,
["dolg_veteran"]			= 15,
["dolg_master"]				= 15,

-- 50
["freedom_novice"]			= 5,
["freedom_regular"]			= 15,
["freedom_veteran"]			= 15,
["freedom_master"]			= 15,

-- 50
["killer_novice"]			= 0,
["killer_regular"]			= 30,
["killer_veteran"]			= 10,
["killer_master"]			= 10,

-- 165
["military_novice"]			= 10,
["military_regular"]		= 40,
["military_veteran"]		= 100,
["military_master"]			= 15,

-- 420
["monolith_novice"]			= 0,
["monolith_regular"]		= 100,
["monolith_veteran"]		= 160,
["monolith_master"]			= 160,

-- 80
["stalker_novice"]			= 30,
["stalker_regular"]			= 45,
["stalker_veteran"]			= 30,
["stalker_master"]			= 15,

-- 160
["zombied_novice"]			= 70,
["zombied_regular"]			= 30,
["zombied_veteran"]			= 30,
["zombied_master"]			= 30

}

factions_limit = {

["bandit"]			= 150,
["dolg"]			= 65,
["freedom"]			= 50,
["killer"]			= 50,
["military"]		= 165,
["monolith"]		= 420,
["stalker"]			= 120,
["zombied"]			= 160

}

monsters_limit = {

["bloodsucker_normal"]		= 7,
["bloodsucker_strong"]		= 7,
["m_bloodsucker_e"]			= 7,
["bloodsucker_weak"]		= 7,
["bloodsucker_invisible"]	= 6,
["bloodsucker_v_strong"]	= 6,
["bloodsucker_v_strong2"]	= 6,
["bloodsucker_mil"]			= 6,
["bloodsucker_v_strong3"]	= 6,
["bloodsucker_v_strong4"]	= 5,

["boar_normal"]				= 30,
["boar_strong"]				= 20,
["boar_weak"]				= 25,

["burer_strong"]			= 6,
["burer_v_strong"]			= 6,
["burer_weak"]				= 6,

["cat_v_normal"]			= 12,
["cat_v_strong"]			= 12,
["cat_weak"]				= 12,

["chimera_weak"]			= 6,
["chimera_strong"]			= 3,
["chimera_v_strong"]		= 2,

["dog_normal"]				= 36,
["dog_strong"]				= 30,
["dog_v_strong"]			= 10,
["dog_weak"]				= 48,
["m_dog_e"]					= 10,

["flesh_normal"]			= 30,
["flesh_strong"]			= 22,
["flesh_v_strong"]			= 15,
["flesh_weak"]				= 25,

["fracture_weak"]			= 12,

["gigant_normal"]			= 5,
["gigant_strong"]			= 5,

["m_controller_normal"]		= 5,
["m_controller_normal_fat"]	= 5,
["m_controller_old_fat"]	= 5,
["controller_tubeman"]		= 3,
["m_controller_old"]		= 3,

["m_poltergeist_normal_flame"]	= 4,
["m_poltergeist_normal_tele"]	= 10,
["m_poltergeist_strong_flame"]	= 4,
["m_poltergeist_tele_outdoor"]	= 4,

["m_rat_e"]					= 12,
["rat_weak"]				= 20,
["rat_normal"]				= 20,
["rat_strong"]				= 20,
["rat_plague"]				= 10,

["m_tushkano_normal"]		= 22,
["m_tushkano_e"]			= 18,
["tushkano_normal"]			= 22,
["tushkano_weak"]			= 27,

["pseudodog_v_strong"]		= 5,
["pseudodog_normal"]		= 10,
["pseudodog_strong"]		= 10,
["pseudodog_weak"]			= 10,
["m_pseudodog_e"]			= 8,

["psy_dog"]					= 5,
["psy_dog_radar"]			= 5,

["snork_indoor"]			= 8,
["snork_jumper"]			= 15,
["snork_normal"]			= 20,
["snork_outdoor"]			= 10,
["snork_strong"]			= 40,
["snork_weak"]				= 40,

["zombie_ghost"]			= 12,
["zombie_immortal"]			= 20,
["zombie_normal"]			= 30,
["zombie_old"]				= 20,
["zombie_plague"]			= 15,
["zombie_rusty"]			= 20,
["zombie_strong"]			= 20,
["zombie_weak"]				= 25,
["zombie_v_normal"]			= 20,
["zombie_v_strong"]			= 15,


-- special

["sceleton_weak"]			= 0,
["rad_zombie_rusty"]		= 1


}

function printf(fmt, ...)
	if ogse.check_game() then
		ogse.send_tip(fmt)
		log1(fmt)
	end
end

function init()

	population_human	= {}
	population_factions	= {}
	population_monster	= {}

	for k, v in pairs(monsters_limit) do
		population_monster[k] = 0
	end
	for k, v in pairs(factions_limit) do
		population_factions[k] = 0
	end
	for k, v in pairs(npc_limit) do
		population_human[k] = 0
	end	

end
-------------------------------------------------------
---' Формат хранения
---' population["object_section"] = number
-------------------------------------------------------
local base_deadcity_zombies = 60
local deadcity_zombies = 0
local zombie_types = {

"city_zombied_respawn_1", 
"city_zombied_respawn_2", 
"city_zombied_respawn_3", 
"yan_zombied_respawn_1",
"yan_zombied_respawn_2",
"yan_zombied_respawn_3",
"rad_zombied_respawn_1",
"rad_zombied_respawn_2",
"rad_zombied_respawn_3",

}

local spawn_points = {
	[1]="deadcity_zombies_1_kamp_1",
	[2]="deadcity_zombies_1_kamp_2",
	[3]="deadcity_zombies_1_kamp_3",
	[4]="deadcity_zombies_1_kamp_4",
	[5]="deadcity_zombies_1_kamp_5",
	[6]="deadcity_zombies_1_kamp_6",
	[7]="deadcity_zombies_1_kamp_7",
	[8]="deadcity_zombies_2_kamp_1",
	[9]="deadcity_zombies_2_kamp_2",
	[10]="deadcity_zombies_2_kamp_3",
	[11]="deadcity_zombies_2_kamp_4",
	[12]="deadcity_zombies_2_kamp_5",
	[13]="deadcity_zombies_2_kamp_6",
	[14]="deadcity_zombies_3_kamp_1",
	[15]="deadcity_zombies_3_kamp_2",
	[16]="deadcity_zombies_3_kamp_3",
	[17]="deadcity_zombies_3_kamp_4",
	[18]="deadcity_zombies_3_kamp_5",
	[19]="deadcity_zombies_4_kamp_1",
	[20]="deadcity_zombies_4_kamp_2",
	[21]="deadcity_zombies_4_kamp_3",
	[22]="deadcity_zombies_4_kamp_4",
	[23]="deadcity_zombies_4_kamp_5",
	[24]="deadcity_zombies_4_kamp_6",
	[25]="deadcity_zombies_4_kamp_7",
	[26]="deadcity_zombies_4_kamp_8",
	[27]="deadcity_zombies_5_kamp_1",
	[28]="deadcity_zombies_5_kamp_2",
	[29]="deadcity_zombies_5_kamp_3",
	[30]="deadcity_zombies_5_kamp_4",
	[31]="deadcity_zombies_5_kamp_5",
	[32]="deadcity_zombies_5_kamp_6",
	[33]="deadcity_zombies_6_kamp_1",
	[34]="deadcity_zombies_6_kamp_2",
	[35]="deadcity_zombies_6_kamp_3",
	[36]="deadcity_zombies_6_kamp_4",
	[37]="deadcity_zombies_6_kamp_5",
	[38]="deadcity_zombies_6_kamp_6",
}

function get_random_spawn_location_deadcity()
	local point = patrol(spawn_points[math.random(#spawn_points)])
	if debug_flag then
		log1("!!MG_RESP POINT ["..point:name().."]")
	end
	local position = point:point(0)
	local lv = point:level_vertex_id()
	local gv = point:game_vertex_id()
	local spawn_point = {
		pos = position,
		y_offs = 1,
		lvid = lv,
		gvid = gv		
	}
	return spawn_point
end

function convert_pos_to_table(point)
	local tab = {point.x, point.y, point.z}
	return tab
end

-- Возвращает угол между проекциями векторов vec1 и vec2 на горизонтальную плоскость
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle(vec1,vec2)
  local x=vec2.x*vec1.x+vec2.z*vec1.z
  local y=-vec2.z*vec1.x+vec2.x*vec1.z -- повернули систему координат     
  return math.atan2(y,x) -- угол доворота от -pi до pi
end

function add_deadcity_zombies(number)
	if db.actor:dont_has_info("master_quest_soup_ready") and level.name() == "l09_deadcity_ogse" then
		local check_spawn = number
		if debug_flag then
			log1("!!MG_RESP NEED SPAWN ["..tostring(check_spawn).."]")
		end		
		while check_spawn > 0 do
			local spawn_point = get_random_spawn_location_deadcity()
			if spawn_point then
				local dist = db.actor:position():distance_to(spawn_point.pos)
				if dist < 150 then
					local dangerang = 1
					local ang = horz_angle(device().cam_dir, spawn_point.pos:sub(device().cam_pos))
					local tgt = ang > -dangerang and ang < dangerang
					if tgt then
						-- не справним в направлении взгляда
					else	
						-- спавним
						local sect = zombie_types[math.random(#zombie_types)]
						spawn_point.pos = convert_pos_to_table(spawn_point.pos)
						ogse.quest_spawn_ex(sect, 1, spawn_point)
						check_spawn = check_spawn - 1
						if debug_flag then
							log1("!!MG_RESP RESPAWNED_BACK ["..tostring(sect).."]")
						end
					end
				else
					local sect = zombie_types[math.random(#zombie_types)]
					spawn_point.pos = convert_pos_to_table(spawn_point.pos)
					ogse.quest_spawn_ex(sect, 1, spawn_point)
					check_spawn = check_spawn - 1
					if debug_flag then
						log1("!!MG_RESP RESPAWNED ["..tostring(sect).."]")
					end					
					-- спавним
				end			
			end		
		end
	end
end

function check_zone_population()

	init()
	
	deadcity_zombies = 0
	
	for id=1,65535 do
		local npc = alife():object(id)
		if npc then
			local sect = npc:section_name()
			if IsStalker(npc) and npc:alive() then
				local npc_vid 	= game_graph():vertex(npc.m_game_vertex_id):level_id()
				local p_map = alife():level_name(game_graph():vertex(npc.m_game_vertex_id):level_id())
				local community = npc:community()
				if not ogse.is_quest_npc(npc) then
					local rank = ranks.get_obj_rank_name(npc)
					if rank == "experienced" then rank = "regular" end
					local name = community.."_"..rank
					if debug_flag then
						log1("!!NPC_LOCATION_["..npc_vid.."] ["..name.."] NAME "..npc:name())
					end
					if not population_human[name] then
						population_human[name] = 1
					else
						population_human[name] = population_human[name] + 1
					end
					if not population_factions[community] then
						population_factions[community] = 1
					else	
						population_factions[community] = population_factions[community] + 1
					end
					if p_map == "l09_deadcity_ogse" then
						if npc:community() == "zombied" then	
							deadcity_zombies = deadcity_zombies + 1						
						end						
					end
				end
			elseif IsMonster(npc) and npc:alive() then
				if not population_monster[sect] then
					population_monster[sect] = 1
				else
					population_monster[sect] = population_monster[sect] + 1
				end
			end
		end
	end
	
	if deadcity_zombies < base_deadcity_zombies and not utils.is_day() then
		local num = base_deadcity_zombies - deadcity_zombies
		add_deadcity_zombies(num)
	end
	
	if debug_flag then
		log1("Сводка Населения МГ: в МГ сейчас ["..tostring(deadcity_zombies).."]")
		log1("~~Сводка Населения Зоны:")
		log1("!!NPC")
		log1("!!----------------------")
		for k,v in pairs(population_human) do
			log1("--"..k.." = "..v)	
		end
		log1("~~Сводка Населения Зоны:")
		log1("!!Группировки")
		log1("!!----------------------")
		for k,v in pairs(population_factions) do
			log1("--"..k.." = "..v)	
		end	
		log1("!!Монстры")
		log1("!!----------------------")	
		for k,v in pairs(population_monster) do
			log1("--"..k.." = "..v)	
		end	
	end

end

function check_npc_spawn_allowed(section, community, rank)
	if (community and community ~= "nil") and (rank and rank ~= "nil") then
		local string_id = community.."_"..rank
		if population_human[string_id] then -- если есть данные по численности
			if npc_limit[string_id] then	-- если есть лимит по опытности внутри коммунити переходим к проверке
				if population_human[string_id] < npc_limit[string_id] then	-- если лимит по опыту внутри коммунити не превышен 
					if population_factions[community] < factions_limit[community] then	-- и лимит по населению не превышен
						if debug_flag then printf("SE_RESPAWN> Разрешен респавн: "..string_id) end
						return true
					else
						if debug_flag then printf("SE_RESPAWN> Запрещен респавн: "..string_id.." по превышению лимита численности группировки.") end
						return false
					end
				elseif population_human[string_id] > npc_limit[string_id] and population_factions[community] < factions_limit[community] then -- если лимит по опыту внутри коммунити превышен, но не превышен по численности - то и фиг с вами, спавним
					if debug_flag then printf("SE_RESPAWN> Разрешен респавн по нехватке численности: "..string_id) end
					return true					
				else
					if debug_flag then printf("SE_RESPAWN> Запрещен респавн: "..string_id.." по превышению численности опытных.") end
					return false
				end
			else
				if debug_flag then printf("SE_RESPAWN> Запрещен респавн: "..string_id.." так как отсутствует лимит NPC.") end
				return false
			end
		else
			if debug_flag then
				if section and monsters_limit[section] then
					-- просто пропускаем, это монстр
					-- if debug_flag then  printf("SE_RESPAWN> Запрещен респавн: "..string_id.." так это проверка для NPC.") end
				else
					printf("SE_RESPAWN> Запрещен респавн: "..string_id.." так как нет данных по численности NPC.") 
				end
			end
			return false
		end
	end
	if debug_flag then printf("SE_RESPAWN> Не пройдена проверка спавна NPC так как не предоставлены все необходимые данные: "..tostring(section)) end
	return true
end

function check_monster_spawn_allowed(section, community, rank) 
-- monster_limit
	if section and (community and community ~= "nil") and (rank and rank ~= "nil") then
		if population_monster[section] then
			if monsters_limit[section] then
				if population_monster[section] < monsters_limit[section] then
					if debug_flag then printf("SE_RESPAWN> Разрешен респавн: "..section) end
					return true
				else
					if debug_flag then printf("SE_RESPAWN> Запрещен респавн: "..section.." по превышению лимита численности.") end
					return false
				end				
			else
				if debug_flag then printf("SE_RESPAWN> Запрещен респавн: "..section.." так как отсутствует лимит монстров.") end
				return false			
			end		
		else
			if debug_flag then 
				if (community and community ~= "nil") and (rank and rank ~= "nil") then
					local string_id = community.."_"..rank
					if npc_limit[string_id] then
						-- просто пропускаем, это NPC
						-- if debug_flag then  printf("SE_RESPAWN> Запрещен респавн: "..string_id.." так это проверка для монстров.") end
					else						
						if debug_flag then printf("SE_RESPAWN> Запрещен респавн: "..section.." так как нет данных по численности монстров - вариант 2.") end
					end
				else
					printf("SE_RESPAWN> Запрещен респавн: "..section.." так как нет данных по численности монстров.") 
				end
			end
			return false		
		end
	elseif section then
		if debug_flag then printf("SE_RESPAWN> Разрешен спавн неизвестного объекта: "..tostring(section)) end
		return true
	end
	if debug_flag then printf("SE_RESPAWN> Не пройдена проверка спавна монстра так как не предоставлены все необходимые данные: "..tostring(section)) end	
	return true
end

local idle_spawn_preset = {
	seldom = 60*60*t_common*2,
	medium = 60*60*t_common,
	often = math.ceil((60*60*t_common)/2),
	once = -100000
}

-- Список респавнеров, для сбора статистики
local respawners = {}
local respawners_by_parent = {}
----------------------------------------------------------------------------------------------------------------------
-- Разные полезные функции
----------------------------------------------------------------------------------------------------------------------

--[[function r_bool( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_bool( section, line )
  else
    return default
  end
end]]

--[[function r_str( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_string( section, line )
  else
    return default
  end
end]]

--[[function r_num( spawn_ini, section, line, default )
  if spawn_ini:line_exist( section, line ) then
    return spawn_ini:r_float( section, line )
  else
    return default
  end
end]]

--[[function r_2nums( spawn_ini, section, line, def1, def2 )
	if spawn_ini:line_exist( section, line ) then
		-- если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
		local t = parse_names( spawn_ini:r_string( section, line ) )
		local n = table.getn( t )

		if n == 0 then
			return def1, def2
		elseif n == 1 then
			return t[1], def2
		else
			return t[1], t[2]
		end
	else
		return def1, def2
	end
end

function parse_names( s )
    local t = {}
    for name in string.gfind( s, "([%w_%-.\\]+)%p*" ) do
        table.insert( t, name )
    end
    return t
end]]

function r_spawns( spawn_ini, section, line, sectSpawnProps)
  if spawn_ini:line_exist( section, line ) then
    --' если default-ов больше, чем значений в ini, то забить недостающие последним значением из ini
    local t = parse_names( spawn_ini:r_string( section, line ) )
    local n = table.getn( t )
    
    local ret_table = {}
    local k = 1
    while k <= n do
      local spawn = {}
      spawn.section = t[k]
      -- Проверяем что это не последняя запись
      if t[k+1] ~= nil then
        local p = tonumber(t[k+1])
        -- проверяем что вторым числом задана вероятность, а не другая секция спавну
        if p then
          -- забиваем число
          spawn.prob = p
          k = k + 2
        else
          -- забиваем дефолт 1
          spawn.prob = 1
          k = k + 1
        end
      else
        spawn.prob = 1
        k = k + 1
      end
      table.insert(ret_table, spawn)
  
      -- Вычитываем настройки секций респавна и кешируем их.
      if sectSpawnProps[spawn.section] == nil then
        local community = r_str(sys_ini, spawn.section, "community", "nil")
        local rank = r_str(sys_ini, spawn.section, "spec_rank", "nil")
        local check = true
        local custom_data = r_str(sys_ini, spawn.section, "custom_data")
        if custom_data ~= nil and (tostring(custom_data) ~= "stalker_custom_data.ltx") then --KRodin: ни к чему несколько раз подряд читать один и тот же пустой конфиг!
		--log1("SE_RESPAWN - CUSTOM_DATA: "..tostring(custom_data))
          local custom_data_ltx = ini_file(custom_data)
          if custom_data_ltx:section_exist("smart_terrains") then
            if custom_data_ltx:line_exist("smart_terrains", "none") then
              if r_str(custom_data_ltx, "smart_terrains", "none") == "true" then
                check = false
              end 
            end
            if custom_data_ltx:line_exist("smart_terrains", "respawn_check") then
				if r_str(custom_data_ltx, "smart_terrains", "respawn_check") == "false" then
					check = false
				end
			end                        
          end
        end
        
        sectSpawnProps[spawn.section] = {community = community, rank = rank, check = check}
      end
            
    end
    return ret_table
  end
  return nil
end
----------------------------------------------------------------------------------------------------------------------
-- Серверный объект спавнера
----------------------------------------------------------------------------------------------------------------------
class "se_respawn" ( cse_alife_smart_zone )
function se_respawn:__init( section ) super( section )
  self.spawned_obj = {}
  -- Таблица для кеширования свойств секций респавна.
  self.sectSpawnProps = {}
  self.rt_read = false
  self.proxy_initialized = false
end
-- сохранение
function se_respawn:STATE_Write( packet )
  cse_alife_smart_zone.STATE_Write( self, packet )

  local table_size = table.getn(self.spawned_obj)
--  printf("SE_RESPAWN> SPAWNER SAVE table_size[%d]", table_size)
--  print_table(self.spawned_obj)

  packet:w_u8(table_size)
  for i=1,table_size do
    packet:w_u16(self.spawned_obj[i])
  end

  utils.w_CTime(packet, self.respawn_time)

  if self.respawn_time == nil then
    self.respawn_time = game.CTime()
  end
  --log1("%s write respawn_time %s %s", tostring(self:name()), self.respawn_time:dateToString(0), self.respawn_time:timeToString(1))
end

-- восстановление
function se_respawn:STATE_Read( packet, size )
  cse_alife_smart_zone.STATE_Read( self, packet, size )
  
  if editor() then
    return
  end

  local table_size = packet:r_u8()
  for i=1,table_size do
    table.insert(self.spawned_obj, packet:r_u16())
  end

--  printf("SE_RESPAWN> SPAWNER READ table_size[%d]", table_size)
--  print_table(self.spawned_obj) 

  if not packet:r_eof() then
    self.respawn_time = utils.r_CTime(packet)
    self.rt_read = true
    --log1("%s read respawn_time %s %s", tostring(self:name()), self.respawn_time:dateToString(0), self.respawn_time:timeToString(1))
  end
end

-- инициализация объекта.
-- вызывается симулятором.
function se_respawn:on_register()
  cse_alife_smart_zone.on_register( self )
  --printf("SE_RESPAWN> RESPAWN: [%s] se_respawn on_register", tostring(self:name()))
	init_respawn_params(self)
end
-- Создаем объект
function se_respawn:create(prob)
	if tostring(prob)=="true" then
		prob=80
	elseif tostring(prob)=="false" then
		prob=0
	end
  if tonumber(prob) == nil then   
    print_table(self.conditions)
    abort("RESPAWN[%s]spawn probability doesn't set", tostring(self:name()))
    prob = 0
  end
  
  if math.random(100) <= tonumber(prob) then
    local spawn_section = ""
    local sum = 0
    -- Производим рандомную взвешенную выборку
    -- с учетом уже заспавленного количества человек.
    for k,v in pairs(self.respawn_section) do
--'     local tt = self.sectSpawnProps[v.section]
--'     local community_rank = tt.community.."_"..tt.rank
--'     local s_count = simMaxCount[community_rank]
--'     if s_count == nil then
--'       s_count = 0
--'     end
--'     if tt.check == false or
--'        self.item_spawn == true or
--'        sim_statistic.simNpcCount(tt.community, tt.rank) < s_count
--'     then  
        sum = sum + v.prob
--'     end
    end
    sum = math.random(0, sum)
    for k,v in pairs(self.respawn_section) do
--'     local tt = self.sectSpawnProps[v.section]
--'     local community_rank = tt.community.."_"..tt.rank
--'     local s_count = simMaxCount[community_rank]
--'     if s_count == nil then
--'       s_count = 0
--'     end     
--'     if tt.check == false or
--'        self.item_spawn == true or
--'        sim_statistic.simNpcCount(tt.community, tt.rank) < s_count 
--'     then  
        sum = sum - v.prob      
        if sum <= 0 then
          spawn_section = v.section
          break
        end
--'     end
    end
    
    if spawn_section == "" then
--      printf("SE_RESPAWN> SPAWNING [%s], CANT SPAWN, SIMULATION POPULATION EXCEED", tostring(self:name()))
      --log1("SPAWNING [%s], CANT SPAWN, SIMULATION POPULATION EXCEED", tostring(self:name()))
      return false
    end
    
    local parent_id = nil
    if self.parent ~= nil then
      local s_obj = alife():story_object(self.parent)
      if s_obj == nil then
        abort("SPAWNING [%s], cant find parent with SID [%s]", self:name(), self.parent)
        return
      end
      parent_id = s_obj.id
    end
    
    local obj
	
	-- отсюда берем ранг и секцию для проверки
    local tt = self.sectSpawnProps[spawn_section]	
	
	local check_1 =  check_npc_spawn_allowed(spawn_section, tt.community, tt.rank)
	local check_2 =  check_monster_spawn_allowed(spawn_section, tt.community, tt.rank)
	
	if check_1 == true or check_2 == true then
	
	-- сюда лепим
		if parent_id == nil then
		  obj = alife():create(spawn_section, 
				self.position,
				self.m_level_vertex_id, 
				self.m_game_vertex_id)
		else
		  obj = alife():create(spawn_section, 
				self.position,
				self.m_level_vertex_id, 
				self.m_game_vertex_id,
				parent_id)
		end
		
		
		local str = tt.community.."_"..tt.rank
		if population_human[str] then
			population_human[str] = population_human[str] + 1
		end
		if population_factions[tt.community] then
			population_factions[tt.community] = population_factions[tt.community] + 1
		end
		if IsMonster(obj) then
			if population_monster[spawn_section] then
				population_monster[spawn_section] = population_monster[spawn_section] + 1
			end
		end
	
	else
		if debug_flag then log1("!!SE_RESPAWN> Существо не прошло обе проверки "..spawn_section) end
		return false
	end



--    printf("SE_RESPAWN> SPAWN [%s] -> [%s]", tostring(self:name()), obj:name())
--    log1("SPAWN [%s] -> [%s]", tostring(self:name()), obj:name())

		if self.item_spawn == false then        
			if tt.check == true then
				obj:brain():update()
				local smart_terrain_id = obj:smart_terrain_id()
--				printf("SE_RESPAWN> SPAWN [%s] move_offline [%s], interactive [%s], smart_terrain_id [%s]", tostring(self:name()), tostring(self:move_offline()), tostring(self:interactive()), smart_terrain_id)
				if smart_terrain_id ~= 65535 then   
					table.insert(self.spawned_obj ,obj.id)
					local pos = obj.position
--					printf("SE_RESPAWN> SPAWNING [%s] -> [%s], position [%s][%s][%s]", tostring(self:name()), spawn_section, pos.x, pos.y, pos.z)
					local sm_obj = alife():object(smart_terrain_id)

--					printf("SE_RESPAWN> SPAWNING for SMART [%s] : [%s] -> [%s]", self:name(), obj:name(), sm_obj:name())
--					log1("SPAWNING for SMART [%s] : [%s] -> [%s]", self:name(), obj:name(), sm_obj:name())  
          
					return true
				else
					if obj then
						alife():release(obj, true)
					end
--					log1("SPAWNING [%s] -> [%s], CANT SPAWN. NO SMART_TERRAIN AVAILABLE!!!", tostring(self:name()), spawn_section)
--					printf("SE_RESPAWN> SPAWNING [%s] -> [%s], CANT SPAWN. NO SMART_TERRAIN AVAILABLE!!!", tostring(self:name()), spawn_section)
					return false
				end
			end
		end
		table.insert(self.spawned_obj ,obj.id)
		return true
	end
end

-- Попытка спаунить объекты. Анализируется сколько уже заспавнено и выбирается один из механизмов - либо 
-- мы доспавниваем до минимального количества, либо спавним с заданной вероятностью
function se_respawn:spawn()	
	--  printf("SE_RESPAWN> RESPAWN: [%s] spawn execute", tostring(self:name()))
	--log1("RESPAWN: [%s] spawn execute", tostring(self:name()))
	if not self.spawn_once then
		-- Пробегаемся по списку уже заспавненных объектов и удаляем из них мертвые либо уничтоженные.
		for k,v in pairs(self.spawned_obj) do
			local obj = level.object_by_id(v)
			if obj == nil then
				obj = alife():object(v)
			end

			if obj ~= nil then
				if (IsStalker(obj) or IsMonster(obj)) and obj:alive() ~= true then
					table.remove(self.spawned_obj, k)
				end
			else
				table.remove(self.spawned_obj, k)
			end
		end 
	end
	if xr_logic.pick_section_from_condlist(db.actor_proxy, self, self.conditions) == "0" then
		--    printf("SE_RESPAWN> SPAWNING [%s], CANT SPAWN. PROBABILITY ZERO!!!", tostring(self:name()))
		--log1("SPAWNING [%s], CANT SPAWN. PROBABILITY ZERO!!!", tostring(self:name()))
		sim_statistic.respawn_enabled(self, false)
		return
	end
	sim_statistic.respawn_enabled(self, true)

	if self.spawn_once and not self.already_once_spawned then 
		self.already_once_spawned = true
	end
	
	-- экстренный спаун минимального количества объектов
	if table.getn(self.spawned_obj) < self.min_count then 
		while table.getn(self.spawned_obj) < self.min_count do
			--log1("RESPAWN: [%s] very small object", tostring(self:name()))
			if self:create(100) == false then
				return
			end
		end
		return
	end

	if self.max_count ~= -1 and table.getn(self.spawned_obj) >= self.max_count then
		--log1("RESPAWN: [%s] max count reached", tostring(self:name()))
		--printf("SE_RESPAWN> SPAWNING [%s], CANT SPAWN. MAX COUNT REACHED!!!", tostring(self:name()))
		return
	end  	
	-- делаем несколько попыток заспаунить объект.
	for i=1, self.max_spawn do   
		self:create(xr_logic.pick_section_from_condlist(db.actor_proxy, self, self.conditions))
	end   
end

--' Удаляем уже заспавненный объект из списка заспавненных
--' Используется только  для ящиком со шмотками в смарттеррейнах
function se_respawn:remove_spawned(id)
  for k,v in pairs(self.spawned_obj) do
    if id == v then
      table.remove(self.spawned_obj, k)
    end       
  end 
end
-- Обновление респавнера. В зависимости от настроек обновляется либо только в офлайне, либо и там и там.
function se_respawn:execute()
--  printf("SE_RESPAWN> RESPAWN: [%s] se_respawn execute", tostring(self:name()))
	if self.already_once_spawned==true then return end
  --' Выходим, если у нас установлен событийный спавн.
  if self.idle_spawn_min == -1 then
    return
  end
  
  if self.respawn_time < game.get_game_time() then
--    if not self.proxy_initialized then
--      db.actor_proxy:init()
--      self.proxy_initialized = true
--    end
    local idle_time = game.CTime()
    local now = game.get_game_time()

   -- idle_time:setHMSms( 0, 0, 0, math.random(self.idle_spawn_min, self.idle_spawn_max)*1000)
	idle_time:setHMSms( 0, 0, 0, math.random(self.idle_spawn_min, self.idle_spawn_max)*1000)
    self.respawn_time = now + idle_time
    
    --log1("RESPAWN: [%s] se_respawn execute %s %s", tostring(self:name()), now:dateToString(0), now:timeToString(1))
    --log1("next respawn %s %s", self.respawn_time:dateToString(0), self.respawn_time:timeToString(1))
    -- Производим попытку заспаунить объекты    
    self:spawn()
		
    
--    printf("SE_RESPAWN> spawn_count = %s", table.getn(self.spawned_obj))
  end
end
-- Обновление в офлайне
function se_respawn:update()
  cse_alife_smart_zone.update( self )

  --'printf("SE_RESPAWN> RESPAWN: [%s] se_respawn update_offline", tostring(self:name()))

  self:execute()
end
-- Обновление в онлайне
function se_respawn:update_online()
	--'cse_alife_smart_zone.update( self )

	--'printf("SE_RESPAWN> RESPAWN: [%s] se_respawn update_online", tostring(self:name()))

	if self.respawn_radius == -1 then
		sim_statistic.respawn_enabled(self, false)
		return
	end
	if db.actor:position():distance_to (self.position) >= self.respawn_radius then
		self:execute()
	else
		sim_statistic.respawn_enabled(self, false)
	end
end

function spawn(name)

  local spawner = respawners[name]
  if spawner == nil then
    return
  end
  
  --log1("spawn("..tostring(spawner:name())..")")

  for i=1,spawner.max_spawn do
    if spawner.max_count ~= -1 and table.getn(spawner.spawned_obj) >= spawner.max_count then
--      printf("SE_RESPAWN> SPAWNING [%s], CANT SPAWN. MAX COUNT REACHED!!!", tostring(spawner:name()))
      return
    end   
    if spawner:create(xr_logic.pick_section_from_condlist(db.actor_proxy, spawner, spawner.conditions)) == false then
      return
    end
  end   
end

function get_respawner_by_parent(parent_id)
  return respawners_by_parent[parent_id]
end

-- Сбор статистики
function stats()
  local total_spawned = 0
  local total_avail = 0
  local total = 0
  printf("SE_RESPAWN> ***************** RESPAWN STATISTIC *********************")
  for k,v in pairs(respawners) do
    local s = xr_logic.pick_section_from_condlist(db.actor_proxy, v, v.conditions)
    local pops = "DISABLE"
    if s ~= "nil" and s ~= "0" then
      pops = table.getn(v.spawned_obj)
    end
    local str_pops
    if v.max_count == pops then
      str_pops = "FULL "..tostring(pops)
    else
      str_pops = tostring(pops)
    end
    printf("SE_RESPAWN> [%s] spawns [%s] object", tostring(v:name()), str_pops)
    print_table(v.respawn_section)
    -- Увеличиваем общие счетчики
    total = total + v.max_count
    if pops ~= "DISABLE" then
      total_avail = total_avail + v.max_count
      total_spawned = total_spawned + pops
    end
  end
  printf("SE_RESPAWN> *** SUMMARY ***")
  printf("SE_RESPAWN>   total = %s", total)
  printf("SE_RESPAWN>   total_avail = %s", total_avail)
  printf("SE_RESPAWN>   total_spawned = %s", total_spawned)
  printf("SE_RESPAWN> ***************")
end

-- Сбор продвинутой статистики статистики по лимитам
function lstats()

end


-- Сбор статистики по ненастроенным объектам
function estats()
  printf("SE_RESPAWN> ***************** SPAWN ERROR STATISTIC *********************")
  for k,v in pairs(respawners) do
    -- Заносим максимальное количество всех типов чуваков, которые данный респавнер может наспаунить.
    for kk,vv in pairs(v.respawn_section) do
      local tt = v.sectSpawnProps[vv.section]
      if tt.community == "nil" or tt.rank == "nil" then
        printf("SE_RESPAWN> respawner [%s]", tostring(v:name()))
        printf("SE_RESPAWN> Section [%s] community[%s] rank [%s]", vv.section, tt.community, tt.rank)
      end
    end
  end 
end



function create_ammo(section, position, lvi, gvi, pid, num)
	local num_in_box = sys_ini:r_u32(section, "box_size")

	while num > num_in_box do
		local sitem = alife():create_ammo(section, position, lvi, gvi, pid, num_in_box)
		local sammo = alife():object(sitem.id)
		sammo:use_ai_locations(false)
		num = num - num_in_box
	end
	local sitem = alife():create_ammo(section, position, lvi, gvi, pid, num)
	local sammo = alife():object(sitem.id)
	sammo:use_ai_locations(false)
end

function init_respawn_params(obj)

  -- Вычитываем настройки спауна
  local ini = obj:spawn_ini()
  if not ini:section_exist(section_name) then
    return  
  end
  
  obj.respawn_section = r_spawns(ini, section_name, "respawn_section", obj.sectSpawnProps)  
  if obj.respawn_section == nil then
    abort("RESPAWN: [%s] field 'respawn_section' doesn't exist.", obj:name())
  end

  obj.spawned_goes_online = r_bool(ini, section_name, "spawned_goes_online", nil)
	
  obj.spawn_once = r_bool(ini, section_name, "spawn_once", false)
	
  obj.min_count = r_num(ini, section_name, "min_count", 0)
  obj.max_count = r_num(ini, section_name, "max_count", -1)
  if obj.min_count > obj.max_count and
     obj.max_count ~= -1 
  then
    abort("RESPAWN: [%s] min_count > max_count", obj:name())
  end
  --' FOR DEBUG ONLY, please don't forget to delete
  --'if obj.max_count > 0 then
  --' obj.min_count = obj.max_count
  --'end
  
  obj.max_spawn = r_num(ini, section_name, "max_spawn", 1)
  obj.idle_spawn_min, obj.idle_spawn_max = r_2strings(ini, section_name, "idle_spawn")
  if obj.idle_spawn_min == nil then
    abort("RESPAWN: [%s] field 'idle_spawn' doesn't exist.", obj:name())
  end
  if obj.idle_spawn_max == nil then
    obj.idle_spawn_max = obj.idle_spawn_min
  end

  --' Вычитка пресетов
  if idle_spawn_preset[obj.idle_spawn_min] ~= nil then
    obj.idle_spawn_min = idle_spawn_preset[obj.idle_spawn_min]
  else
    obj.idle_spawn_min = tonumber(obj.idle_spawn_min)
  end
  if idle_spawn_preset[obj.idle_spawn_max] ~= nil then
    obj.idle_spawn_max = idle_spawn_preset[obj.idle_spawn_max]
  else
    obj.idle_spawn_max = tonumber(obj.idle_spawn_max)
  end

  --log1("spawn_min %d spawn_max %d", obj.idle_spawn_min, obj.idle_spawn_max) 

  obj.str_conditions = r_str(ini, section_name, "conditions", 100) 
  obj.conditions = xr_logic.parse_condlist(obj, section_name, "conditions", obj.str_conditions)
  obj.respawn_radius = r_num(ini, section_name, "respawn_radius", -1)
    --' Спешкейс, чтобы сохранить совместимость сейвов.
  if obj:name() == "mil_freedom_barier_respawn_1" then
    obj.respawn_radius = -1
  end
  obj.parent = r_num(ini, section_name, "parent", nil)
  obj.item_spawn = r_bool(ini, section_name, "item_spawn", false)
  
  -- производим первичную инициализацию
  if obj.rt_read == false then
    obj.respawn_time = game.CTime()
    --log1("INIT [%s] %s %s", tostring(obj:name()), obj.respawn_time:dateToString(0), obj.respawn_time:timeToString(1))
  end

  -- Для сбора статистики сохраняем указатель на респавнер
	respawners[obj:name()] = obj
  if obj.parent ~= nil then
    respawners_by_parent[obj.parent] = obj
  end
	
  --' Отметка респавнера мапспотом (для статистики)
  sim_statistic.register_respawn(obj)

end
