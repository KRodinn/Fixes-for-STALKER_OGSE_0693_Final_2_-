-- -*- mode: lua; coding: windows-1251-dos -*-
-------------------------------------------------------------------------------
--| ogse_st_mgr.script                                                      |--
--| Serializable Timers Manager                                             |--
--| Malandrinus, OGS Evolution Team, 2012                                   |--
--| version 1.0                                                             |--
-------------------------------------------------------------------------------

-- Использование сохраняемых (сериализуемых) таймеров в целом похоже на использование
-- "быстрых" таймеров из модуля ogse_qt.script. Создаётся объект таймера, в нём 
-- создаются методы условия и действия, он запускается и далее живёт своей жизнью,
-- срабатывая по условию и выполняя в нужный момент заданное действие.
-- Первое отличие от quick_timer в некоторых ограничениях при создании, связанных
-- с необходимостью создавать объект класса таймера заново при загрузке.
-- Второе отличие, в наличии методов save/load, в которых таймер может сохранить
-- любые данные, необходимые ему для работы. Это могут быть как данные, необходимые для
-- проверки условия, так и данные необходимые для выполнения действия.
--
-- Пример создания и использования простого таймера, использующего только
-- временнОе условие:
--[[
class "test_timer" (ogse_st_mgr.savable_timer)
function test_timer:__init() super()
        -- обязательная строка с именем класса таймера
        self._class = script_name()..".test_timer"
end
-- метод для первичной инициализации, может иметь произвольное имя
function test_timer:set_data(s)
        self.str = s
end
-- перегруженные методы загрузки/сохранения пользовательских данных
function test_timer:load(packet)
        self.str = packet:r_stringZ()
end
function test_timer:save(packet)
        packet:w_stringZ(self.str)
end
-- перегруженный метод действия по временнОму условию
function test_timer:taction()
        log1(self.str) -- что-то делаем в назначенное время
end

-- создание и запуск таймера
local t = test_timer()
t:set_data("some string")
t:set_delay(600) -- сработает через 10 минут реального времени
-- или
--t:set_gdelay(600) -- сработает через 10 минут игрового времени
-- или
--t:set_gtime(game.CTime():set(...)) -- сработает в заданный момент игрового времени
t:start() -- запустить с низким приоритетом (по умолчанию)
-- или
--t:start(true) -- запустить с высоким приоритетом (проверка на каждом апдейте)
]]

-- Пример таймера с произвольным условием. Следит за неким неписем, который
-- когда-то может быть выйдет в онлайн:
--[[
class "conditional_timer" (ogse_st_mgr.savable_timer)
function conditional_timer:__init(timer_id) super(timer_id)
        self._class = script_name()..".conditional_timer"
end
function conditional_timer:init(npc_id)
        self.npc_id = npc_id
        return self -- для вызова цепочкой
end
-- перегруженные методы загрузки/сохранения пользовательских данных
function conditional_timer:load(packet)
        self.npc_id = packet:r_u16()
end
function conditional_timer:save(packet)
        packet:w_u16(self.npc_id)
end
function conditional_timer:condition()
        self.npc = level.object_by_id(self.npc_id)
        return self.npc
end
-- перегруженный метод действия по пользовательскому условию (имя метода action, а не taction !)
function conditional_timer:action()
        self.npc:kill(db.actor) -- что-то делаем при появлении чувака
end

-- создание таймера, инициализация и запуск с низким приоритетом
conditional_timer("my_timer"):init(12345):start()
get_timer("my_timer"):stop() -- передумали и остановили
]]


function attach(sm)
  sm:subscribe({ signal = "on_load",   fun = this.on_load   })
  sm:subscribe( {signal = "on_save",   fun = this.on_save   })
end


-- уникальный идентификатор для переменной со списком таймеров. НЕ МЕНЯТЬ!
local root_guid = "{663A0135-0A8F-41D9-91BA-FCCBFD59B146}_root"
-- уникальная базовая часть идентификатора таймеров. НЕ МЕНЯТЬ!
local storage_guid = "{36881905-5863-4D7C-BB12-0ECAC401FE1A}"
local registry = {} -- хранилище таймеров в памяти.


function delete_all_timers()
  for id, timer in pairs( registry ) do
    timer:stop()
  end
end


local function get_free_id()
  for i = 0, 65535 do
    local id = tostring( i )
    if not registry[ id ] then return id end
  end
  abort( "ogse_st_mgr.get_free_id: Can't find free id for timer!" )
end


function get_timer( id )
  local timer = registry[ id ]
  ASSERT(
    timer, "ogse_st_mgr.get_timer: timer with id'" .. id .. "' doesn't exist"
  )
  return timer
end


function timer_exists( id )
  return registry[ id ] ~= nil
end


-- загрузка всех таймеров
function on_load()
  local chunks = ogse.load_var_safe( script_name() .. ".chunks" )
  if not chunks then return on_load_old() end
  for _, pk in ipairs( chunks ) do
    local timer_id    = pk:r_stringZ()
    local timer_class = pk:r_stringZ()

	if --Затычка для того, чтобы старые таймеры не вызывали вылеты. УБРАТЬ С НИ!!!!
		timer_class ~= "ogse.timer_new"
		and timer_id ~= "random_spawn"
		and not string.find(timer_class, "ogse_teleport_trap_journey")
		and not string.find(timer_class, "ogse_teleport_trap_art_destiny")
		and not string.find(timer_class, "ogse_military_psycho_surprise")
		and not string.find(timer_class, "captive_on_agr_mill_base_shutdown_news_timer")
		and not string.find(timer_id, "TransferItemFromActorToTrunk")
	then

    local f, msg = loadstring( "return " .. timer_class .. "(...)" )
    ASSERT( f, msg )
    local timer = f( timer_id )
    timer:_aux_load( pk )
    timer:start( timer._high_priority )

	end
  end
  log2( "--[%s]: %s timers loaded", script_name(), table.getn( chunks ) )
end


function on_load_old()
  local timers_list = ogse.load_var( root_guid, {}, "array" )
  for _, timer_id in ipairs( timers_list ) do
    local timer_chunk = ogse.load_var( storage_guid .. "_" .. timer_id )
    local timer_class = timer_chunk:r_stringZ()

	if --Затычка для того, чтобы старые таймеры не вызывали вылеты. УБРАТЬ С НИ!!!!
		timer_class ~= "ogse.timer_new"
		and timer_id ~= "random_spawn"
		and not string.find(timer_class, "ogse_teleport_trap_journey")
		and not string.find(timer_class, "ogse_teleport_trap_art_destiny")
		and not string.find(timer_class, "ogse_military_psycho_surprise")
		and not string.find(timer_class, "captive_on_agr_mill_base_shutdown_news_timer")
		and not string.find(timer_id, "TransferItemFromActorToTrunk")
	then

    local f, msg = loadstring( "return " .. timer_class .. "(...)" )
    ASSERT( f, msg )
    local timer = f( timer_id )
    timer:_aux_load( timer_chunk )
    timer:start( timer._high_priority )
    ogse.delete_var( storage_guid .. "_" .. timer_id )

	end
  end
  ogse.delete_var( root_guid )
  log2( "~~[%s]: %s old timers loaded", script_name(), table.getn( timers_list ) )
end


-- сохранение состояния всех таймеров
function on_save()
  local chunks = {}
  for timer_id, timer in pairs( registry ) do
    local pk = net_packet()
    pk:w_begin( 123 )     -- двухбайтовая заглушка
    pk:r_seek( 2 )        -- чтобы пропустить эти два байта при чтении
    table.insert( chunks, pk )
    pk:w_stringZ( timer_id )
    timer:_aux_save( pk )
  end
  ogse.save_var( script_name() .. ".chunks", chunks, "array", "chunk" )
  log2( "--[%s]: %s timers saved", script_name(), table.getn( chunks ) )
end


-------------------------------------------------------------------------------
--< базовый класс сохраняемого таймера для отслеживания произвольного события >
-------------------------------------------------------------------------------
class "savable_timer" --конструктор таймера в базовом классе
function savable_timer:__init( timer_id )
  self._class = "error: it is forbidden to create instances of a base savable timer class!"
  if timer_id then
    ASSERT(
      tostring( timer_id ),
      "savable_timer:__init: custom id assigned to timer must be a string or be convertible to a string"
    )
    ASSERT(
      not timer_exists( timer_id ),
      "savable_timer:__init: timer with the id '" .. timer_id .. "' already exists!"
    )
    self._id = tostring( timer_id )
  else
    self._id = get_free_id()
  end
  self.sm = ogse_signals.get_mgr()
end

function savable_timer:_aux_load( packet )
  self._high_priority = packet:r_bool()
  -- загружаем сохранённое время срабатывания по шкале реальных и игровых
  -- секунд
  local res_time = packet:r_float()
  if res_time ~= 0 then
    -- строго нулевое значение означает, что таймер реальных секунд не задан
    self:set_delay( res_time )
  end
  -- загружаем игровое время срабатывания
  local end_t = utils.r_CTime_ex( packet )
  if end_t ~= game.CTime() then
    self:set_gtime( end_t )
  end
  -- загружаем игровое время запуска
  self._start_time = utils.r_CTime_ex( packet )
  -- загружаем данные пользователя, если есть
  if not packet:r_eof() then
    self:load( packet )
  end
end

function savable_timer:_aux_save( timer_chunk )
  timer_chunk:w_stringZ( self._class )
  timer_chunk:w_bool( self._high_priority )
  -- сохранение времени срабатывания по шкале реального и игрового времени
  -- включено в состав заголовка таймера.
  -- сохраняем время до срабатывания по шкале реальных секунд
  if self._residual_time then
    -- вычисляем и пишем новое оставшееся до выполнения время
    self._time_from_loading = 1.0e-3 * ( time_global() - self._loading_time )
    local delay = self._residual_time - self._time_from_loading
    --
    --Таймер может уйти в минус,
    --если балансировка отложила его выполнение на следующий
    --апдейт. Т.ч. падать не будем, а обработаем эту ситуацию. Пусть
    --сработает сразу же, после загрузки этого сейва.
    if delay > 0 then
      timer_chunk:w_float( delay )
    else
      log3( "[%s]: saving wrong delay = %s: %s.%s", script_name(), delay, self._class, self._id )
      timer_chunk:w_float( -1 )
    end
  else
    -- строго нулевое значение будет означать, что таймер реальных секунд не
    -- задан
    timer_chunk:w_float( 0 )
  end
  -- сохраняем игровое время срабатывания
  if self._game_termination_time then
    utils.w_CTime_ex( timer_chunk, self._game_termination_time )
  else
    utils.w_CTime_ex( timer_chunk, game.CTime() )
  end
  -- сохраняем время запуска
  utils.w_CTime_ex( timer_chunk, self._start_time )
  -- теперь сохраняем данные пользователя, если есть
  self:save( timer_chunk )
end

-- задать точное время срабатывания в терминах игрового времени
function savable_timer:set_gtime( t ) -- аргумент - объект типа game.CTime
  self._game_termination_time = game.CTime( t )
  return self
end

function savable_timer:get_start_time()
  return game.CTime( self._start_time )
end

function savable_timer:get_end_time()
  ASSERT(
    self._game_termination_time,
    "savable_timer:get_end_time: termination time is not defined!"
  )
  return game.CTime( self._game_termination_time )
end

function savable_timer:set_gdelayDHMS( d, h, m, s )
  local delay = d * 24 * 3600 + h * 3600 + m * 60 + s
  self:set_gdelay( delay )
  return self
end

function savable_timer:set_HMS_of_day( h, m, s )
  local pt      = { game.get_game_time():get() }
  local now     = pt[ 4 ] * 3600 + pt[ 5 ] * 60 + pt[ 6 ] + pt[ 7 ] / 1000
  local seconds = h * 3600 + m * 60 + s
  if now > seconds then
    seconds = ( 86400 - now ) + seconds
  else
    seconds = seconds - now
  end
  self:set_gdelay( seconds )
  return self
end

-- задать задержку срабатывания от текушего времени в секундах игрового времени
-- аргумент - задержка в секундах, тип float
-- ( дробная часть задаёт микросекунды )
function savable_timer:set_gdelay( delay )
  ASSERT(not self._residual_time, "") --На всякий случай
  local s, ms = math.modf( delay )
  local t = game.CTime()
  t:setHMSms( 0, 0, s, ms * 1000 )
  self._game_termination_time = game.CTime( game.get_game_time() + t )
  return self
end

-- задать задержку срабатывания от текушего времени в секундах реального
-- времени
-- аргумент - задержка в секундах, тип float
function savable_timer:set_delay( delay )
  ASSERT(not self._game_termination_time, "") --На всякий случай
  self._residual_time = delay
  self._loading_time = time_global()
  self._time_from_loading = 0.0
  return self
end

function savable_timer:set_delayDHMS( d, h, m, s )
  local delay = d * 24 * 3600 + h * 3600 + m * 60 + s
  self:set_delay( delay )
  return self
end

-- запустить таймер с указанием, в какую очередь поместить проверку
-- в отличие от "быстрых" таймеров приоритет по умолчанию - низкий
function savable_timer:start( --[[high_priority]] )
  self._start_time     = self._start_time or game.get_game_time()
  self._high_priority  = true --high_priority --TODO: с НИ удалить это вообще.
  self._cond_slot_desc = {
    signal = "on_update",
    self   = self,
    fun    = self._aux_cond,
    --queued = not high_priority, --Больше не нужно, из за использования reschedule()
	script_name = self._class
  }
  self.sm:subscribe( self._cond_slot_desc )
  registry[ self._id ] = self
  return self
end

-- останов таймера
function savable_timer:stop()
  self.sm:unsubscribe( self._cond_slot_desc )
  registry[ self._id ] = nil
end

-- метод для внутреннего использования таймером
function savable_timer:_aux_cond() --KRodin: Этому классу не добавлял reschedule, т.к в таймерах на его основе condition должен выполняться часто. В том же ogse.visual_timer, например.
  if self._game_termination_time then
    if self._game_termination_time <= game.get_game_time() then -- если сработал таймаут
      self:stop()    -- останавливаем проверки
      self:taction() -- выполняем действие по таймауту
      return
	end
  elseif self._residual_time then
    self._time_from_loading = 1.0e-3 * ( time_global() - self._loading_time )
    if self._residual_time <= self._time_from_loading then
      self:stop()    -- останавливаем проверки
      self:taction() -- выполняем действие по таймауту
      return
    end
  end
  if self:condition() then -- если сработало условие
    self:stop() 
    self:action() -- выполняем действие по условию
    return
  end
end

-- условие-заглушка на случай использования только с таймаутом
function savable_timer:condition()
  return false
end

-- пустые действия в базовом классе. Нужны для того случая, 
-- когда не используем соответствующее действие в унаследованном классе
function savable_timer:action()  end
function savable_timer:taction() end

-- переопределять для сохранения/загрузки пользовательских данных
function savable_timer:load( packet ) end
function savable_timer:save( packet ) end


-------------------------------------------------------------------------
--| Обёртка для упрощённого запуска таймера
--| позволяет запустить простой таймер с временнОй задержкой,
--| который запускает заданную функцию, передавая её заданные параметры
-------------------------------------------------------------------------
class "delayed_fun_start" ( savable_timer )
function delayed_fun_start:__init( name ) super( name )
  self._class = script_name() .. ".delayed_fun_start"
end

function delayed_fun_start:start( ... )
  if self._game_termination_time then --Таймеры с игровым временем подписываем на сигнал перевода часов.
    self.after_time_change_signal = {signal = "after_time_change", self = self, fun = self.after_time_change}
    self.sm:subscribe(self.after_time_change_signal)
  end

  return savable_timer.start(self, ...)
end

function delayed_fun_start:after_time_change() --Вынужденное обновление после перевода часов.
  self:_aux_cond(true)
end

function delayed_fun_start:stop()
  if self._game_termination_time then
    self.sm:unsubscribe(self.after_time_change_signal)
    self.after_time_change_signal = nil
  end

  savable_timer.stop(self)
end

function delayed_fun_start:init( action_name, ... )
  self.action_name = action_name
  self.user_action = loadstring( "return " .. self.action_name .. "( ... )" )
  ASSERT(
    self.user_action,
    "delayed_fun_start:init: can not compile function with the name '%s'",
    tostring( self.action_name )
  )
  self.fun_params = { ... }
  return self
end

function delayed_fun_start:load( packet )
  self.action_name = packet:r_stringZ()
  self.user_action = loadstring( "return " .. self.action_name .. "( ... )" )
  ASSERT(
    self.user_action,
    "delayed_fun_start:load: can not compile function with the name '%s'",
    tostring( self.action_name )
  )
  local array_item = ogse_unist.read_item_from_packet( packet )
  ASSERT(
    array_item.type == ogse_unist.types.array,
   "delayed_fun_start:load: wrong parameters readed"
  )
  self.fun_params = array_item:get_value()
  --log3("[%s] Loading timer: id: [%s], class: [%s], action_name = [%s], fun_params = [%s]", script_name(), self._id, self._class, self.action_name, self.fun_params)
end

function delayed_fun_start:save( packet )
  packet:w_stringZ( self.action_name )
  local array_item = ogse_unist.create_item( "", self.fun_params, "array" )
  ogse_unist.write_item_to_packet( packet, array_item )
end

function delayed_fun_start:_aux_cond(forced)
  if self._game_termination_time then
    if self._game_termination_time <= game.get_game_time() then -- если сработал таймаут
      self:stop()    -- останавливаем проверки
      self:taction() -- выполняем действие по таймауту
	else
	  local timeout = (self._game_termination_time:diffSec(game.get_game_time()) * 1000 ) / ogse.game_time_factor
	  --Отладочный вывод--
	  --local cur_game_time = time2string(game.get_game_time(), "%04d/%02d/%02d %02d:%02d:%02d.%03d", {'y','m','d','h','min','s','ms'})
	  --local next_upd_game_time = time2string(self._game_termination_time, "%04d/%02d/%02d %02d:%02d:%02d.%03d", {'y','m','d','h','min','s','ms'})
	  --log3("##[%s(%s)] Current game time: %s, \nNext update game time: %s, \nTime Factor: [%s] \nDelta in REAL ms: [%s]", self._class, self._id, cur_game_time, next_upd_game_time, ogse.game_time_factor, timeout)
	  --------------------
	  if forced then
	    self.sm:rechange_scheduled_time( self._cond_slot_desc, timeout )
	  else
	    self.sm:reschedule( timeout )
	  end
	end
  elseif self._residual_time then
    self._time_from_loading = 1.0e-3 * ( time_global() - self._loading_time )
    if self._residual_time <= self._time_from_loading then
      self:stop()    -- останавливаем проверки
      self:taction() -- выполняем действие по таймауту
	else
	  self.sm:reschedule( ( self._residual_time - self._time_from_loading ) * 1000 )
    end
  end
end

function delayed_fun_start:taction()
  self.user_action( unpack( self.fun_params ) )
end


function start_timer( name, delay, fname, ... )
  return delayed_fun_start( name )
    :set_delay( delay )
    :init( fname, ... )
    :start(delay < 300)
end

function start_gtimer( name, delay, fname, ... )
  return delayed_fun_start( name )
    :set_gdelay( delay )
    :init( fname, ... )
    :start(delay < 300)
end
