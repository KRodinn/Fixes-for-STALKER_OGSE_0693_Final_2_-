-----------------------------------------------------------------------
--- ogse.script
--- Утилитарная база OGSE 0.6.9.3
--- 2007-2008 (c) xStream, DEXXX
--- 2009-2013 (c) OGS Evolution Team
-----------------------------------------------------------------------

function attach(sm)
	sm:subscribe({signal = "on_spawn",			fun = this.on_game_load})
	sm:subscribe({signal = "on_first_update",	fun = this.on_actor_first_update})
	sm:subscribe({signal = "on_update",			fun = this.show_time})
	sm:subscribe({signal = "on_take",			fun = this.on_item_take})
end

game_time_factor = get_float("alife", "time_factor")
local fov_vol = sys_ini:r_s32("options","fov_volume")
local max_alarm_fov_vol = sys_ini:r_s32("options","max_fov_volume")
local min_alarm_fov_vol = sys_ini:r_s32("options","min_fov_volume")
local ammo_on_belt = sys_ini:r_s32("options","ammunition_on_belt")
---------------------------------------------------------------
deadmans_table = {} -- см. dsh_deadmans_table_proxy.script
-- Формат хранения:
-- [id] = { time_died = time_when_killed, killer = who:id() }
---------------------------------------------------------------

-----------Псевдонимы для удобства вызова-----------
save_var = ogse_unist.set_value
load_var = ogse_unist.get_value
load_var_safe = ogse_unist.get_value_safe
var_exists = ogse_unist.value_exist
delete_var = ogse_unist.remove_value
save_or_delete_var = ogse_unist.set_or_remove_value
----------------------------------------------------
start_tmr = ogse_st_mgr.start_timer
start_gtmr = ogse_st_mgr.start_gtimer
get_tmr = ogse_st_mgr.get_timer
tmr_exists = ogse_st_mgr.timer_exists
--Таймеры с визуальным счётчиком на худе вызываются прямо отсюда. См. внизу скрипта.
----------------------------------------------------

art_levels = {
["af_medusa"] = 1,
["af_vyvert"] = 1,
["af_blood"] = 1,
["af_ameba_slime"] = 1,
["af_gravi"] = 2,
["af_drops"] = 2,
["af_electra_sparkler"] = 2,
["af_ameba_slug"] = 2,
["af_rusty_thorn"] = 2,
["af_mincer_meat"] = 2,
["af_cristall_flower"] = 2,
["af_fireball"] = 3,
["af_electra_flash"] = 3,
["af_rusty_kristall"] = 3,
["af_kaktus"] = 3,
["af_gold_fish"] = 4,
["af_cristall"] = 4,
["af_dummy_spring"] = 4,
["af_dummy_dummy"] = 4,
["af_dummy_pellicle"] = 4,
["af_night_star"] = 5,
["af_soul"] = 5,
["af_electra_moonlight"] = 5,
["af_ameba_mica"] = 5,
["af_rusty_sea-urchin"] = 5,
["af_dummy_battery"] = 5,
["af_dummy_glassbeads"] = 5,
["af_fuzz_kolobok"] = 5
}

local loc_levels = {
["l01_escape"] = 1,
["l02_garbage"] = 2,
["l03_agroprom"] = 3,
["l03u_agr_underground"] = 3,
["l04_darkvalley"] = 3,
["l04u_labx18"] = 4,
["l05_bar"] = 3,
["l06_rostok"] = 4,
["l07_military"] = 4,
["l08_yantar"] = 4,
["l08u_brainlab"] = 5,
["l10_radar"] = 5,
["l10u_bunker"] = 5,
["l11_pripyat"] = 5,
["l12_stancia"] = 5,
["l12_stancia_2"] = 5,
["l12u_sarcofag"] = 5,
["l12u_control_monolith"] = 5,
["l09_deadcity_ogse"] = 5,
["l13_generators_ogse"] = 5,
["l22_marsh"] = 5
}

-- Переменные для типсов
tips_variable = {
	["pda_news"] = ([[device\pda\pda_news]]),
	["pda_tips"] = ([[device\pda\pda_tip]]),
	["pda_task"] = ([[device\pda\pda_objective]]),
	["pda_sos"] = ([[device\pda\pda_sos]]),
}
tips_icons = {
	default  = { 82, 282},
	trader   = { 332, 893},
	dolg     = { 0, 658},
	freedom  = { 0, 658},
	ecolog   = { 498, 0},
	arena    = { 332, 141},
	stalker  = { 0, 658},
	krot     = { 332, 47},
	barman   = { 332, 235},
	wolf	   = { 332, 940},
	o_soznanie = { 498, 893},
	monolith = { 0, 658},
	saharov  = { 332, 470},
	prizrak  = { 0, 658},
	killer   = { 0, 658},
	death    = { 0, 752},
	gen_info	= { 0, 658},
	trade 	= { 0, 0},
	uniq	= { 498, 47}
}

function kill_living_npc(npc_id)
   local s_npc = alife():object(npc_id)
   s_npc.force_offline = true
   go_offline_kill_timer(npc_id, pos):start()
end
-- служебный таймер, ждущий ухода в оффлайн
class "go_offline_kill_timer" (ogse_qt.quick_timer)
function go_offline_kill_timer:__init(npc_id) super()
   self.npc_id = npc_id -- запоминаем в таймере id непися
end
function go_offline_kill_timer:condition()
   return (not level.object_by_id(self.npc_id)) -- ждём исчезновения клиентского объекта
end
function go_offline_kill_timer:action()
   local s_npc = alife():object(self.npc_id)
   if s_npc then
      alife():release(s_npc, true)
   --else
      --send_tip("Something wrong!") -- такое возможно при удалении объекта
   end
end

--- Перезапуск логики NPC
function reset_npc_logic(obj)
	if obj then
		local npc_id = obj:id()
		db.storage[npc_id].overrides = nil
		xr_logic.reset_generic_schemes_on_scheme_switch(obj, "nil", "nil")
		db.storage[npc_id].active_section = nil
		db.storage[npc_id].active_scheme = nil
	end
end

-- Получение заданного настройками fov
function get_default_fov()
	return fov_vol
end
-- Получение максимально допустимого настройками fov
function get_max_alarm_fov()
	return max_alarm_fov_vol
end
-- Получение минимально допустимого настройками fov
function get_min_alarm_fov()
	return min_alarm_fov_vol
end

-- Проверка уровня артефакта по имени левела
function art_accesible(item)
	local section = item:section()
	local level_name = level.name()
	local art_level = art_levels[section]
	local loc_level = loc_levels[level_name]
	if art_level and loc_level then
		return art_level <= loc_level
	else
		return true
	end
	return false
end

-- Проверка нахождения актора в особой зоне
function actor_in_zone(pos_psy_x,pos_psy_y,size_psy_x,size_psy_y,z1,z2)
local pos = db.actor:position()
local x1 = pos_psy_x
local x2 = pos_psy_y
local y1 = size_psy_x
local y2 = size_psy_y
if (pos.x >= x1 and pos.x <= x2) and (pos.z >= y1 and pos.z <= y2) and (pos.y >= z1) and (pos.y <= z2) then
	return 1
end
return 0
end

-- Проверка нахождения НПС в особой зоне
function npc_in_zone(obj,lev,pos_psy_x,pos_psy_y,size_psy_x,size_psy_y,z1,z2)
local level_name = level.name()
if level_name ~= lev then
	return false
end
local pos = obj:position()
local x1 = pos_psy_x
local x2 = pos_psy_y
local y1 = size_psy_x
local y2 = size_psy_y
return (pos.x >= x1 and pos.x <= x2) and (pos.z >= y1 and pos.z <= y2) and (pos.y >= z1) and (pos.y <= z2)
end

local quest_profiles = {
	["military_trader"] 		= true,
	["bandit_trader"] 			= true,
	["monolit_trader"] 			= true,
	["merc_trader"] 			= true,
	["pri_trader_profile"]	 	= true,
	["agr_dolg_glavnyi"] 		= true,
	["agr_dolg_sniper"] 		= true,
	["agr_ratcatcher"]			= true,
	["ecolog_v_tainike"] 		= true,
	["ecolog_v_doline"] 		= true,
	["neytral_drug_seregi"]		= true,
	["neytral_serega_manyak"] 	= true,
	["yan_svoboda_informator"] 	= true,
	["mil_dolg_recon"] 			= true,
	["mil_svoboda_wounded"] 	= true,
	["mil_dolg_killer_commander"] = true,
	["mil_dolg_killer_1"] 		= true,
	["mil_dolg_killer_2"] 		= true,
	["mil_Svoboda_zombi_stalker"] = true,
	["mil_svoboda_bespredel"] 	= true,
	["esc_anmaly_military_leader"] 	= true,
	["esc_anmaly_military_solder"] 	= true,
	["bar_arena_manager"]	= true,
	["aem_arny"]	= true,
	["aem_admin_1"]	= true,
	["aem_admin_2"]	= true,
	["aem_admin_3"]	= true,
	["aem_admin_4"]	= true,
	["aem_admin_5"]	= true,
	["esc_specotryad_leader"] = true,
	["esc_specotryad_npc"] = true,
	["esc_plennik_on_blockpost"] = true,
	["esc_anmaly_military_leader"] = true,
	["esc_anmaly_military_solder"] = true,
	["esc_killer_mined_lager"] = true,
	["val_freedom_enemy"] = true,
	["val_freedom_enemy_commander"] = true,
	["val_friend_of_barman"] = true,
	["val_stalkers_barman"] = true,
	["gar_dolg_on_sdelka"] = true,
	["gar_killers_on_sdelka"] = true,
	["agr_plennik_on_base_mils"] = true,
	["agr_military_plennik"] = true,
	["pri_doch_of_starik"] = true,
	["esc_starik_searcing_doch"] = true,
	["rad_freedomer_on_vetr"] = true,
	["esc_stalker_novice_teterev"] = true,
	["esc_bandit_of_teterev_leader"] = true,
	["esc_bandit_of_teterev"] = true,
	["esc_sniper_qest_on_elevator"] = true,
	["esc_sniper_qest_on_elevator_2"] = true,
	["yan_zombied_chuk"] = true,
	["yan_figa"] = true,
	["x18_death_stalker"] = true,
	["val_kvestx10_svyaznoy"] = true,
	["esc_scoryi"] = true,
	["val_orlov"] = true,
	["val_kvest_sniper"] = true,
	["esc_sitnik"] = true,
	["esc_pechkin"] = true,
	["yan_ecolog_preobr"] = true,
	["val_bandit_uzh"] = true,
	["esc_hitryi"] = true,
	["val_bodryi"] = true,
	["x16_gribnik"] = true,
	["x16_leshyi"] = true,
	["gar_hellcar_group_1"] = true,
	["gar_hellcar_group_2"] = true,
	["gar_seryi_drug2"] = true,
	["gar_seryi_drug3"] = true,
	["esc_blokpost_commander"] = true,
	["sim_stalker_master_diador"] = true,
	["agr_defector_stalker1"] = true,
	["bar_ecolog_professor"] = true,
	["gar_sniper_bandit"] = true,
	["first_neutral"] = true,
	["esc_lekar"] = true,
	["bridge_lekar"] = true,
	["esc_digger"] = true,
	["ds_hunter"] = true,
	["ds_glavar"] = true,
	["ds_telohr_1"] = true,
	["ds_telohr_2"] = true,
	["ds_shesterka"] = true,
	["ds_patruln"] = true,
	["bratstvo_lider"] = true,
	["bratstvo_orujeinik"] = true,
	["bratstvo_vrach"] = true,
	["bratstvo_cleaner"] = true,
	["iskatel_shaman"] = true,
	["iskatel_dusty"] = true,
	["iskatel_yuriy"] = true,
	["iskatel_ahmet"] = true,
	["iskatel_bacha"] = true,
	["ds_nalet_band_1"] = true,
	["ds_nalet_band_2"] = true,
	["ds_nalet_band_3"] = true,
	["ds_nalet_band_4"] = true,
	["ds_nalet_band_5"] = true,
	["ds_nalet_band_6"] = true,
	["ds_nalet_band_7"] = true,
	["ds_nalet_band_8"] = true,
	["garb_novice_arthunter"] = true,
	["bar_kulg_agent"] = true,
	["dolg_palach1"] = true,
	["dolg_palach2"] = true,
	["bar_sergant_jivoderov"] = true,
	["rad_company_mikluha"] = true,
	["rad_company_che"] = true,
	["rad_company_fidel"] = true,
	["rad_company_markiz"] = true,
	["rad_company_graf"] = true,
	["rad_company_zahar"] = true,
	["izgioy_lider"] = true,
	["izgoy_pomoshnik"] = true,
	["izgoy_first_patient"] = true,
	["izgoy_second_patient"] = true,
	["dar_merk_lider"] = true,
	["dar_merk_bomber"] = true,
	["dar_merk_guard_1"] = true,
	["dar_merk_guard_2"] = true,
	["dar_officer"] = true,
	["bar_dr_gorbovsky"] = true,
	["dik_the_drifter"] = true,
	["bratstvo_agent_1"] = true,
	["dar_gaz_dolg_lider"] = true,
	["dar_gaz_dolg1"] = true,
	["dar_gaz_dolg2"] = true,
	["dar_gaz_dolg3"] = true,
	["stalker_tikar"] = true,
	["major_pomoshnik2"] = true,
	["major_wounded"] = true,
	["zona_brother1"] = true,
	["zona_brother2"] = true,
	["yan_soldier"] = true,
	["ros_soldier"] = true,
	["yan_soldier_new"] = true,
	["deadcity_bar_nardyman"] = true,
	["deadcity_bar_barman"] = true,
	["deadcity_master_voice"] = true,
	["bar_guider"] = true,
	["yantar_guider"] = true,
	["pri_guider"] = true,
	["esc_semenov"] = true,
	["stalker_hvost"] = true,
	["stalker_kolya"] = true,
	["uley_robber"] = true,
	["deadcity_bar_nardyman"]	= true,
	["deadcity_bar_billiardman"]	= true,
	["deadcity_bar_restsofa"]	= true,
	["deadcity_bar_sleeper"]	= true,
	["deadcity_bar_zasranets"]	= true,
	["deadcity_bar_drinkman"]	= true,
	["deadcity_bar_barman"]	= true,
	["deadcity_bar_guard1"]	= true,
	["deadcity_bar_guard2"]	= true,
	["hohol"]						=	true,
	["esc_buharik"]					=	true,
	["esc_guns_remontnik"]			=	true,
}

--- Возвращает true если параметром передан квестовый непись
function is_quest_npc(npc)
	local story = 4294967296
	if npc then
		if npc.m_story_id ~= nil then
			story = npc.m_story_id
		else
			story = npc:story_id()
		end
		if story == 4294967296 then
			local profile = npc:profile_name()
			local name = npc:name()
			if quest_profiles[profile] or quest_profiles[name] then
				return true
			end
		end
	end
	return story ~= 4294967296
end

-- телепортация NPC в пределах уровня
-- сама функция только ставит флажок на выпихивание в оффлайн и запускает ждущий таймер
-- вся работа будет сделана в экшине таймера
function teleport_npc(npc_id, pos)
   local s_npc = alife():object(npc_id)
   s_npc.force_offline = true
   go_offline_watch_timer(npc_id, pos):start() -- таймер "выстрелил-забыл"
end
-- служебный таймер, ждущий ухода в оффлайн
class "go_offline_watch_timer" (ogse_qt.quick_timer)
function go_offline_watch_timer:__init(npc_id, pos) super()
   self.npc_id = npc_id -- запоминаем в таймере id непися
   self.pos    = pos -- запоминаем позицию, куда будем перемещать
end
function go_offline_watch_timer:condition()
   return (not level.object_by_id(self.npc_id)) -- ждём исчезновения клиентского объекта
end
function go_offline_watch_timer:action()
   local s_npc = alife():object(self.npc_id)
   if s_npc then
      s_npc.position = self.pos -- кастуем злое колдунство
      s_npc.force_offline = nil -- отправляем обратно в онлайн
   --else
      --log1("Something wrong!") -- такое возможно при удалении объекта
   end
end

--- Возвращает класс защиты надетой на ГГ брони от выброса. В obj передавать db:actor
--- С неписями НЕ работает! Пользуйте armor_type(npc)
function armor_class(obj)
	if obj then
		local armor = obj:get_current_outfit()
		local armorname
		if armor ~= nil then armorname = armor:section() else return 5 end
		if armorname ~= nil then
			if 	string.find(armorname, "scientific_outfit") or
				string.find(armorname, "ecolog_outfit") or
				string.find(armorname, "protection_outfit") or
				string.find(armorname, "military_outfit") then
				return 1
	     elseif string.find(armorname, "exo") or
				string.find(armorname, "monolit_exoskeleton") then
				return 2
	     elseif string.find(armorname, "outfit_specnaz_m1") or
				string.find(armorname, "specops_outfit") or
				string.find(armorname, "monolit_outfit_m1") or
				string.find(armorname, "svoboda_heavy_outfit") then
				return 3 else return 4
			end
		end
	end
end

--- Возвращает величину урона ударной волной в зависимости от локации
function level_blow_damage(level_name)

local level_name = level.name()

	if level_name then
		if level_name == "l01_escape" then
			return 0.02
		elseif level_name == "l03_agroprom" or level_name == "l02_garbage" or level_name == "l04_darkvalley" then
			return 0.04
		elseif level_name == "l05_bar" or level_name == "l06_rostok" then
			return 0.06
		elseif level_name == "l07_military" or level_name == "l08_yantar" or level_name == "l11_pripyat" then
			return 0.08
		else return 0.06 end
	end
	return 0.06
end

local armor_type_npc = {["novice"]=4, ["experienced"]=3, ["veteran"]=2, ["master"]=1}
--- Возвращает класс защиты непися
function armor_type(npc)
	if npc then
		local npc_rank = ranks.get_obj_rank_name(npc)
		if npc_rank ~= nil then
			return (armor_type_npc[npc_rank] or 1)
		end
	end
end

-- Показ типса
function send_tip(news_text, header, timeout, showtime, sender, sound)
	if news_text==nil then return end
	local header = (header or game.translate_string("st_tip"))
	local timeout = (timeout or 0)
	local showtime = (showtime or 5)

	local player = xr_sound.get_safe_sound_object((tips_variable[tostring(sound)] or  tips_variable["pda_tips"]))

	--' Играем дефолтный звук
	player:play(db.actor, timeout, sound_object.s2d)

	local sender = (sender or "default")

	local x = tips_icons[sender][1]
	local y = tips_icons[sender][2]

	local news_text = "%c[255,160,160,160]"..header.."\\n".."%c[default]"..news_text
	db.actor:give_game_news(news_text, "ui\\ui_iconsTotal", Frect():set(x,y,83,47), timeout*1000, showtime*1000)
	return true
end

--****************************************ТАЙМЕРЫ - НАЧАЛО.*************************************************
--KRodin: перевёл эти дерьмотаймеры на систему ogse_st_mgr.script
--По-хорошему, надо бы от них избавиться, но тут слишком много работы.
--НИ В КОЕМ СЛУЧАЕ НЕ ПОЛЬЗУЙТЕСЬ ЭТИМИ ТАЙМЕРАМИ В БУДУЩЕМ!
function start_timer(name, delay, action)
	if not delay then return end
	if not action then action = "" end
	--log3("~~Starting timer: [%s_%s]", name, action)

	ogse_st_mgr.delayed_fun_start()
	:set_delay( delay )
	:init( script_name()..".__do_timer_action", name, action )
	:start(delay < 300)
end

function g_start_timer(name, delay_d, delay_h, delay_m, action)
	if not delay_d or not delay_h or not delay_m then return end
	if not action then action = "" end
	--log3("~~Starting gtimer: [%s_%s]", name, action)

	ogse_st_mgr.delayed_fun_start()
	:set_gdelayDHMS( delay_d, delay_h, delay_m, 0 )
	:init( script_name()..".__do_timer_action", name, action )
	:start(delay_m > 0 and delay_m < 20)
end

local selector = {
	["ex1"] = function(params_string)
		if ui_ogse_exo_control.exo_to_rust and ui_ogse_exo_control.exo_to_rust_condition then
			local a = level.object_by_id(ui_ogse_exo_control.exo_to_rust)
			if a ~= nil then a:set_condition(ui_ogse_exo_control.exo_to_rust_condition) end
			ui_ogse_exo_control.exo_to_rust = nil
			ui_ogse_exo_control.exo_to_rust_condition = nil
		end
	end,

	["men"] = function(params_string)
		del_variable("smn")
	end,

	["kol"] = function(params_string)
		local h = hit ()
		h.direction = vector():set(0, 0, 0)
		h.impulse = 5
		h.draftsman = db.actor
		h.type = hit.explosion
		h.power = 3
		if has_alife_info("task_1_start") and not has_alife_info("kolodets_razminirovan") then
			local snd = [[weapons\f1_explode]]
			snd = xr_sound.get_safe_sound_object(snd)
			db.actor:give_info_portion("kolodets_razminirovan")
			db.actor:give_info_portion("task_2_obj_1")
			db.actor:hit(h)
			if snd then
				snd:play_no_feedback(db.actor, sound_object.s3d, 0, db.actor:position(), 1.0)
			end
			level.add_cam_effector("camera_effects\\fusker.anm", 999, false, "")
		end
		if has_alife_info("task_1_start") and has_alife_info("kolodets_razminirovan") then
			db.actor:give_info_portion("task_2_obj_1")
		end
		del_variable("kol")
	end,

	["fpl"] = function(params_string)
		level_tasks.set_task_state(task.completed, "sar_warlab", 0)
		level_tasks.set_task_state(task.completed, "sar_warlab", 1)
	end,

	["oso"] = function(params_string)
		ogse_quests.turn_pnv_off()
		level.add_pp_effector("deadcity_wake.ppe", 2008, false)

		local point = patrol("mon_jump_aes2_walk")
		local look = patrol("mon_jump_aes2_look")
		db.actor:set_actor_position(point:point(0))
		local dir = look:point(0):sub(point:point(0))
		db.actor:set_actor_direction(-dir:getH())

		bind_stalker.restore_weapon()
		level.enable_input()
		level.show_indicators()
	end,

	["vd1"] = function(params_string)
		local p = particles_object("anomaly2\\teleport_out_00")
		p:play_at_pos(params_string)
		local s = sound_object("anomaly\\teleport_incoming")
		s:play_no_feedback(db.actor,sound_object.s2d, 0, vector():set(0, 0, 0), 1.0)
		start_timer("vd2", 2)
	end,

	["vd2"] = function(params_string)
		level.add_pp_effector("teleport.ppe", 2009, false)
		local s = sound_object("anomaly\\teleport_work_2")
		s:play_at_pos(db.actor, vector():set(0, 0, 0), 0, sound_object.s2d)
		db.actor:give_info_portion("pri_trader_vanish")
		start_timer("vd3", 2)
	end,

	["vd3"] = function(params_string)
		local s = sound_object("x18_laugh")
		s:play_no_feedback(db.actor,sound_object.s2d, 0, vector():set(0, 0, 0), 1.0)
		level.enable_input()
		bind_stalker.restore_weapon()
	end,

	["dismiss_prebandit"] = function(params_string)
		if has_alife_info("actor_prebandit") then
			dialogs.actor_clear_community(actor, npc)
		end
	end,

	["make_reinforcements_mad"] = function(params_string)
		jekan_work.dar_zapravka_reinforcement_madness()
	end,

	["block_begin_dialog"] = function(params_string)
		if has_alife_info("block_begin_dialog") then
			db.actor:disable_info_portion("block_begin_dialog")
		end
	end,

	["fail_kill_agr_plennik"] = function(params_string)
		tasks_functor.fail_kill_agr_plennik_timer()
	end,

	["scene_hit_actor_to_prison"] = function(params_string)
		if not tasks_functor.orlov_killed() then
			tasks_functor.show_messeges_shpion_to_orlov()
		end
	end,

	["zag"] = function(params_string)
		db.actor:give_info_portion("hunter_new_zagadka")
		db.actor:disable_info_portion("hunter_oshibka")
	end,

	["rad_zomb"] = function(params_string)
		jekan_work.rad_company_gipnoz()
	end,

	["barpris"] = function(params_string)
		db.actor:give_info_portion("sergant_new_dopros")
	end,

	["dar_officer"] = function(params_string)
		jekan_work.spawn_dar_officer()
		news_manager.send_tip(db.actor, "merc_officer_tip", nil)
		soundtrack.dar_officer_spawn()
	end,

	["road_bomb"] = function(params_string)
		jekan_work.road_bomb_hit()
	end,

	["road_bomb_expl"] = function(params_string)
		jekan_work.btr_signal_to_stop()
	end,

	["uaz"] = function(params_string)
		db.actor:give_info_portion("spawn_dar_uaz")
	end,

	["request"] = function(params_string)
		soundtrack.military_radio_request2()
		db.actor:give_info_portion("dar_dez_btr_spawn")
	end,

	["drifter1"] = function(params_string)
		jekan_work.drifter_body_release()
	end,

	["drifter2"] = function(params_string)
		jekan_work.respawn_drifter()
		jekan_work.spawn_drifter_dog()
	end,
	
	["goto_izgoy_camp"] = function(params_string)
		jekan_work.goto_camp()
	end,
	
	["yan_sold_move_actor"] = function(params_string)
		jekan_work.yan_sold_paralyze_actor()
	end,

	["yan_sold_actor_failed"] = function(params_string)
		if db.actor:dont_has_info("yan_sold_hitted") and db.actor:dont_has_info("yan_soldier_dead") then
			db.actor:give_info_portion("yan_sold_actor_wait_too_long")
		else
			db.actor:give_info_portion("yan_sold_generator_enabled")
		end
	end,
	
	["yan_sold_give_tip"] = function(params_string)
		level.enable_input()
		news_manager.send_tip( db.actor, "tips_yan_sold", nil, "actor", nil )
	end,
	
	["yan_actor_hit_soldier"] = function(params_string)
		news_manager.send_tip( db.actor, "tips_actor_hit_soldier", nil, "actor", nil )
	end,
	
	["izgoy_fin"] = function(params_string)
		jekan_work.izgoy_fin()
	end,
	
	["brat_1"] = function(params_string)
		jekan_work.teleport_brat()
	end,	

	["drifter3"] = function(params_string)
		jekan_work.drifter_release_effect()
	end,

	["uley_1"] = function(params_string)
		jekan_update.uley_timer_1()
	end,

	["uley_2"] = function(params_string)
		jekan_update.uley_timer_2()
	end,

	["zapr"] = function(params_string)
		jekan_work.ds_zapravka_signal2()
	end,
	
	["final_dream"] = function(params_string)
		ogse_quests.final_dream()
	end,
	
	["recall_all"] = function(params_string)
		ogse_quests.flashback()
	end,	

	["final_talk"] = function(params_string)
		ogse_quests.init_talk_final()
	end,	
	
	["orlov_talk_1"] = function(params_string)
		xr_effects.show_messeges_shpion_to_orlov1()
	end,	
	["orlov_talk_2"] = function(params_string)
		xr_effects.show_messeges_shpion_to_orlov2()
	end,	
	["orlov_talk_3"] = function(params_string)
		xr_effects.show_messeges_shpion_to_orlov3()
	end,	
	["orlov_talk_4"] = function(params_string)
		xr_effects.show_messeges_shpion_to_orlov4()
	end,	

	["cheb5"] = function(params_string)
		db.actor:disable_info_portion("cheb_sleep")
	end,
	
	["cheb_magic"] = function(params_string)
		local kolya = level_object_by_sid(story_ids.stalker_kolya)
		local ps = particles_object([[anomaly2\electra2_blast_02]])
		ps:play_at_pos(kolya:position())
		local snd = xr_sound.get_safe_sound_object("anomaly\\anomaly_gravy_blast1")
		snd:play_no_feedback(db.actor, sound_object.s3d, 0, db.actor:position(), 1.0)
		local sKolya = alife():object(kolya:id())
		if sKolya then
			alife():release(sKolya, true)
		end
		quest_deadcity.ps_snow:stop()
		db.actor:give_info_portion("cheb_finish_his_magic")
	end,

	["cheb_art"] = function(params_string)
		db.actor:disable_info_portion("cheb_levelhelp")
		db.actor:disable_info_portion("cheb_busy")
	end,

	["art1"] = function(params_string)
		jekan_work.delete_art1()
	end,

	["art1a"] = function(params_string)
		jekan_work.fake_art1effect()
	end,

	["art2"] = function(params_string)
		jekan_work.delete_art2()
	end,

	["art2a"] = function(params_string)
		jekan_work.fake_art2effect()
	end,

	["art3"] = function(params_string)
		jekan_work.delete_art3()
	end,

	["art3a"] = function(params_string)
		jekan_work.fake_art3effect()
	end,

	["str_zon1"] = function(params_string)
		db.actor:give_info_portion("strangezone1_rebuild")
		jekan_work.strange_zone1_charged_tip()
		db.actor:disable_info_portion("strangezone1_off")
		
		if db.actor:has_info("strangezone1_has_same_art") then
			db.actor:disable_info_portion("strangezone1_has_same_art")
		end
	end,

	["str_zon2"] = function(params_string)
		db.actor:give_info_portion("strangezone2_rebuild")
		jekan_work.strange_zone2_charged_tip()
		db.actor:disable_info_portion("strangezone2_off")
		
		if db.actor:has_info("strangezone2_has_same_art") then
			db.actor:disable_info_portion("strangezone2_has_same_art")
		end
	end,

	["str_zon3"] = function(params_string)
		db.actor:give_info_portion("strangezone3_rebuild")
		jekan_work.strange_zone3_charged_tip()
		db.actor:disable_info_portion("strangezone3_off")
		
		if db.actor:has_info("strangezone3_has_same_art") then
			db.actor:disable_info_portion("strangezone3_has_same_art")
		end
	end,

	["str_zon4"] = function(params_string)
		db.actor:give_info_portion("strangezone4_rebuild")
		jekan_work.strange_zone4_charged_tip()
		db.actor:disable_info_portion("strangezone4_off")
		
		if db.actor:has_info("strangezone4_has_same_art") then
			db.actor:disable_info_portion("strangezone4_has_same_art")
		end
	end,

	["str_zon5"] = function(params_string)
		db.actor:give_info_portion("strangezone5_rebuild")
		jekan_work.strange_zone5_charged_tip()
		db.actor:disable_info_portion("strangezone5_off")
		
		if db.actor:has_info("strangezone5_has_same_art") then
			db.actor:disable_info_portion("strangezone5_has_same_art")
		end
	end,

	["str_zon6"] = function(params_string)
		db.actor:give_info_portion("strangezone6_rebuild")
		jekan_work.strange_zone6_charged_tip()
		db.actor:disable_info_portion("strangezone6_off")
		
		if db.actor:has_info("strangezone6_has_same_art") then
			db.actor:disable_info_portion("strangezone6_has_same_art")
		end
	end,

	["str_zon7"] = function(params_string)
		db.actor:give_info_portion("strangezone7_rebuild")
		jekan_work.strange_zone7_charged_tip()
		db.actor:disable_info_portion("strangezone7_off")
		
		if db.actor:has_info("strangezone7_has_same_art") then
			db.actor:disable_info_portion("strangezone7_has_same_art")
		end
	end,

	["atpbox1"] = function(params_string)
		jekan_work.put_items_to_atp_box()
	end,

	["atpbox2"] = function(params_string)
		jekan_work.vikin_vasyu_na_moroz()
		alife():create("bolt", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id())
	end,

	["unicsos"] = function(params_string)
		db.actor:give_info_portion("unic_krovosos_quest")
	end,

	["unicsos2"] = function(params_string)
		if db.actor:dont_has_info("sleep_bloodsucker_on_place") then
			jekan_work.spawn_krovos_unic_bad2()
			start_timer("unicsos3",0,1)
		end
	end,

	["unicsos3"] = function(params_string)
		jekan_work.release_krovos_unic_body()
	end,

	["psdog"] = function(params_string)
		db.actor:give_info_portion("unic_pseudodog_quest")
	end,

	["psdog2"] = function(params_string)
		if db.actor:dont_has_info("sleep_pseudodog_on_place") then
			jekan_work.spawn_pseudodog_unic_bad2()
			start_timer("psdog3",0,1)
		end
	end,

	["psdog3"] = function(params_string)
		jekan_work.release_pseudodog_unic_body()
	end,

	["guard"] = function(params_string)
		jekan_work.spawn_caravan_guard1()
		jekan_work.spawn_caravan_guard2()
	end,

	["cargo"] = function(params_string)
		jekan_work.spawn_loader_cargo1()
	end,
	
	["art_trap"] = function(params_string)
		ogse_teleport_art_quest.journey_begin()
	end,
	
	["btr_comp"] = function(params_string)
		ogse_quests.comp_is_offline()
	end,

	["btr_acc_rdy"] = function(params_string)
		ogse_quests.btr_accum_charged()
	end,
	
	["btr_final"] = function(params_string)
		ogse_quests.btr_finished()
	end,	

	["atplider"] = function(params_string)
		if db.actor:dont_has_info("atp_lider_dead") then
			jekan_work.spawn_atp_lider_work_restrictor()
		end
	end,

	["kosar"] = function(params_string)
		level.enable_input()
		jekan_work.release_potsik()
		db.actor:give_money(-1000)
	end,
	
	["psy_helm_up"] = function(params_string)
		db.actor:give_info_portion("master_quest_helmet_given")
	end,	
	
	["dead_bomb"] = function(params_string)
		db.actor:give_info_portion("master_quest_bomb_ready")
	end,

	["thermite_bomb"] = function(params_string)
		ogse_quests.blow_bidon_bomb()
	end,
	
	["master_notice"] = function(params_string)
		ogse_quests.notify_actor_mg()
	end,	
	
	["game_loose"] = function(params_string)
		db.actor:disable_info_portion("game_kosti_loose")
	end,	

	["synak_drinked"] = function(params_string)
		db.actor:give_info_portion("sinyak_go_to_sleep")
	end,	
	
	["synak_sleeped"] = function(params_string)
		db.actor:give_info_portion("sinyak_awaked")
	end,	
	
	["release_major_jivoderov"] = function(params_string)
		jekan_work.release_major()
	end,		
	
	["stop_bomb_effector"] = function(params_string)
		level.remove_cam_effector(1001)
	end,	
}

function __do_timer_action(select_string, params_string)
	local action = selector[select_string]
	if action ~= nil then
		action(params_string)
	end
end
--****************************************ТАЙМЕРЫ - КОНЕЦ.*************************************************

-----------------------------------------------------------------------------------------------------------
function spawn_items_in_inv(section, npc, num) --Спавним несколько объектов в инвентарь
	for i=1, num do
		spawn_item_in_inv(section, npc)
	end
end

function spawn_item_in_inv(section, npc) --Спавним объекты в инвентарь
	local npc = npc or db.actor
	local sobj_abstr, id
	if type(npc.id) == "function" then
		id = npc:id()
		sobj_abstr = alife():create(section, npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), id)
	else
		id = npc.id
		sobj_abstr = alife():create(section, npc.position, npc.level_vertex_id, npc.game_vertex_id, id)
	end
	ASSERT(sobj_abstr, "[ogse.spawn_item_in_inv] Can't create object with section [%s] in inv [%s]", section or "nil", npc:name() or "nil")
	if id ~= db.actor:id() then
		level.client_spawn_manager():add(sobj_abstr.id, -1, fix_spawn_item_in_inv, npc) --Фикс пропадания доспавненного предмета при сейв/лоаде
	end
	return alife():object(sobj_abstr.id)
end

-- Спавним патроны в инвентарь
function spawn_ammo_in_inv(section, num, npc)
	if num <= 0 then return end
	local npc = npc or db.actor

	local pos, lvi, gvi, pid
	if type(npc.id) == "function" then
		pos, lvi, gvi, pid = npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
	else
		pos, lvi, gvi, pid = npc.position, npc.level_vertex_id, npc.game_vertex_id, npc.id
	end

	local is_actor = pid == db.actor:id()
	local num_in_box = get_u32(section, "box_size")
	while num > num_in_box do
		local sitem = alife():create_ammo(section, pos, lvi, gvi, pid, num_in_box)
		local sammo = alife():object(sitem.id)
		sammo:use_ai_locations(false)
		if not is_actor then
			level.client_spawn_manager():add(sammo.id, -1, fix_spawn_item_in_inv, npc) --Фикс пропадания доспавненного предмета при сейв/лоаде
		end
		num = num - num_in_box
	end
	local sitem = alife():create_ammo(section, pos, lvi, gvi, pid, num)
	local sammo = alife():object(sitem.id)
	sammo:use_ai_locations(false)
	if not is_actor then
		level.client_spawn_manager():add(sammo.id, -1, fix_spawn_item_in_inv, npc) --Фикс пропадания доспавненного предмета при сейв/лоаде
	end
end

function fix_spawn_item_in_inv(npc, id, sobj_abstr) --Фикс пропадания доспавненного предмета при сейв/лоаде
    npc:transfer_item(sobj_abstr, npc)
end
-----------------------------------------------------------------------------------------------------------

-- Удаляем объект из игры
function remove_item(item_to_remove)
	if item_to_remove then
		local sobj = alife():object(item_to_remove:id())
		if sobj then
			alife():release(sobj, true)
			return true
		else
			return false
		end
	end
	return false
end

-- Удаляем объект из игры по имени
function remove_item_by_name(item_to_remove)
	if item_to_remove then
		local sobj = alife():object(item_to_remove)
		if sobj then
			alife():release(sobj, true)
			return true
		else
			return false
		end
	end
	return false
end

--/Удаление итемов из инвентаря ГГ
function remove_inv_items_by_section(sec, items_to_remove)
	local items_removed = 0
	for i = 0, db.actor:object_count() - 1 do
		local item = db.actor:object(i)
		if item and item:section() == sec then
			if remove_item(item) then
				items_removed = items_removed + 1
			end
			if items_removed == items_to_remove then 
				return
			end 
		end
	end 
end

-- Выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc,item)
	if item~=nil then
	    npc:mark_item_dropped(item)
	end
end

-- Убиваем непися
function make_suicide(npc)
	npc:kill(npc)
end

-- Узнаем отношение одного непися к другому
function get_npc_relation(obj,target)
	local rel = obj:relation(target)
	if rel ~= nil then
		return (rel==game_object.neutral and "neutral" or rel==game_object.friend and "friend" or rel==game_object.enemy and "enemy")
	end
end

-- Задаем отношение одного непися к другому
function set_npc_relation(obj,target,relation)
	ASSERT(relation, "[ogse.set_npc_relation] variable relation == nil!")
	if relation=="neutral" then
		rel=game_object.neutral
	elseif relation=="friend" then
		rel=game_object.friend
	elseif relation=="enemy" then
		rel=game_object.enemy
	else
		return false
	end
	obj:set_relation(rel,target)
	return true
end

-- Узнаем группировку непися, применимо к ГГ
function get_npc_community(npc)
	return npc:community()
end

-- Выставляем группировку непися, можно ГГ
function set_npc_community(npc,community_string)
	--значения для community_string можно узнать в config\creatures\game_relations.ltx
	return npc:set_character_community(community_string, 0, 0)
end

-- Удаляем предмет из инвентаря по имени
function remove_item_from_inventory_by_name(remove_item_name,npc)
	return remove_item_from_inventory(npc:object(remove_item_name),npc)
end
function remove_item_from_inventory(remove_item,npc)
	if npc==nil then npc=db.actor end
	if remove_item~=nil then
	    npc:mark_item_dropped(remove_item)
		local sobj = alife():object(remove_item:id())
		if sobj then
			alife():release(sobj, true)
			return true
		else
			return false
		end
	end
	return false
end

-- Очищаем инвентарь непися, можно ГГ, использует следующую фунцию для удаления предмета
function clear_npc_inventory(npc)
    npc:iterate_inventory(__del_item, npc)
end
function __del_item(npc, item)
    local section = item:section()

    if section == "bolt" or section == "device_torch" then
        return
    end
    npc:mark_item_dropped(item)
	local sobj = alife():object(item:id())
	if sobj then
		alife():release(sobj, true)
	end
end

-- Проверка, запущена ли игра
function check_game()
	return level.present() and (db.actor ~= nil) and db.actor:alive()
end

--**********************************************************************************************************
--KRodin перевёл все функции на систему ogse_unist.script.
--В будущем эти функции НЕ ИСПОЛЬЗОВАТЬ! А использовать ТОЛЬКО ogse_unist.script!!! Подробности читать там.
function save_variable(variable_name, value)
	save_var("ogse."..variable_name, value)
end

function load_variable(variable_name, value_if_not_found)
	if var_exists("ogse."..variable_name) then
		return load_var("ogse."..variable_name)
	elseif value_if_not_found ~= nil then
		return value_if_not_found
	else
		return nil
	end
end

function del_variable(variable_name)
	delete_var("ogse."..variable_name)
end
--***********************************************************************************************************

-- Определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2)
	local pos=npc:position()
	return is_point_inside_interval(pos.x,p1.x,p2.x) and
		is_point_inside_interval(pos.y,p1.y,p2.y) and
		is_point_inside_interval(pos.z,p1.z,p2.z)
end
function is_point_inside_interval(x,p1,p2)
	if p1>p2 then
		p1,p2 = p2,p1
	end

	return x>p1 and x<p2
end

-- Получаем инвентарное название объекта
function get_inv_name(section)
	return sys_ini:r_string(section,"inv_name")
end

-- Колбэк на появление предмета в инвентаре ГГ
function on_item_take(obj)
	if obj:section() == "wpn_montirovka" and db.actor:dont_has_info("player_have_crowbar") and level.name() == "l06_rostok" then
		soundtrack.rostok_gordon()
		db.actor:give_info_portion("player_have_crowbar")
		return true
	elseif obj:section() == "book_1" and db.actor:dont_has_info("prof_zapiska_find") then
		db.actor:give_info_portion("prof_zapiska_find")
		return true
	end
end

function make_guider_happy_again(obj_id, obj)
	obj:set_character_community("ecolog", 0, 0)
end

-- Запуск вызовов при первом апдейта актора
function on_actor_first_update()
	if db.actor:has_info("storyline_actor_start") then		
		if db.actor:dont_has_info("OGSE_LIANA_PATCH_3_FIX") then
			if level.name() ~= "l08u_brainlab" then
				-- баг с лианами
				local obj = alife():object("liana_00")
				if obj then
					alife():release(obj, true)
				end
				obj = alife():object("liana_01")
				if obj then
					alife():release(obj, true)
				end
				obj = alife():object("liana_02")
				if obj then
					alife():release(obj, true)
				end
				obj = alife():object("liana_03")
				if obj then
					alife():release(obj, true)
				end
				obj = alife():object("liana_04")
				if obj then
					alife():release(obj, true)
				end
				obj = alife():object("liana_05")
				if obj then
					alife():release(obj, true)
				end
				obj = alife():object("liana_06")
				if obj then
					alife():release(obj, true)
				end
				alife():create(5929)
				alife():create(5930)
				alife():create(5931)
				alife():create(5932)
				alife():create(5933)
				alife():create(5934)
				alife():create(5935)
			end
			db.actor:give_info_portion("OGSE_LIANA_PATCH_3_FIX")
		end
		if db.actor:dont_has_info("OGSE_KOLYA_PATCH_10_FIX") then
			-- варианты: 
			-- 1) Коля еще не заспавнен
			-- 2) Коля заспавнен, есть, еще не найден
			-- 3) Коля заспавнен, пропал, еще не найден
			-- 4) Коля найден, квест закончен
			if db.actor:dont_has_info("cheb_found_kolya") then
			-- не вариант 4
				-- в вариантах 1 и 3 надо всего лишь заспавнить колю и все
				local kolya = alife():story_object(story_ids.stalker_kolya)
				if kolya then
				-- вариант 2. Удаляем колю, снимая с него метку
					level_tasks.remove_location_by_sid(story_ids.stalker_kolya, "crlc_big")
					alife():release(kolya)
				end
				alife():create(11268)
				if db.actor:has_info("deadcity_first_enter") then
					level_tasks.add_location_by_sid(story_ids.stalker_kolya, "crlc_big", "find_kolya")
				end
			end
			
			db.actor:give_info_portion("OGSE_KOLYA_PATCH_10_FIX")
		end
		if db.actor:dont_has_info("OGSE_PATCH_8_FIX") then
			if db.actor:dont_has_info("dead_stalker_start_dialog_2") then
				local obj = alife():story_object(story_ids.x18_death_stalker)
				if obj then
					alife():release(obj, true)
					dark_valley_u_spawn.dead_stalker()
				end
			end
			db.actor:give_info_portion("OGSE_PATCH_8_FIX")
		end
		if db.actor:dont_has_info("OGSE_PATCH_10_1_FIX") then
			local guider = alife():object("yantar_guider")
			if guider then
				level.client_spawn_manager():add(guider.id, -1, make_guider_happy_again)
			end
			
			local af_kolya = nil
			for i = 1,65535 do
				local obj = alife():object(i)
				if obj and obj:section_name() == "af_kolya" then
					af_kolya = obj
				end
			end
			if af_kolya then
				alife():release(af_kolya, true)
				if db.actor:has_info("cheb_found_kolya") and not db.actor:object("cheb") then
					ogse.spawn_item_in_inv("af_kolya", alife():story_object(story_ids.stalker_kolya))
				end
			end
			db.actor:give_info_portion("OGSE_PATCH_10_1_FIX")
		end
	end

	-- Установка FOV
	db.actor:set_camera_fov(fov_vol)

	-- Перехват хоткеев
	ogse_rebind_key.unbind_key()

	-- позволим актору выйти через тот же выход на Агро, что он пришел
	agroprom_tasks.check_enter()

	-- заебал уже этот фонарь
	local torch = db.actor:item_in_slot(9)
	if torch then
		torch:switch_torch(not torch:is_torch_enabled())
		torch:switch_torch(not torch:is_torch_enabled())
	end

	-- патроны на поясе
	if ammo_on_belt == 1 then
		cmd("g_ammunition_on_belt on")
	else
		cmd("g_ammunition_on_belt off")	
	end
end

-- Загружаем все переменные, которые нужно, вызывается при загрузке игры автоматически
function on_game_load()

	cmd("unbind", "contacts") --Отключаем в PDA вкладку "Контакты"

	ogse_debug.process_actor("a_spw", 117)
	id_cleaner.check_ids() --проверка количества идентификаторов

	ogse_debug.process_actor("a_spw", 118)
	if db.storage[db.actor:id()].pstor == nil then	--Создаем хранилище актора
		db.storage[db.actor:id()].pstor = {}
	end

	ogse_debug.process_actor("a_spw", 119)

	-- Первый запуск мода
	if db.actor:dont_has_info("storyline_actor_start") then
		ogse_spawns.traders_spawn()
		ogse_spawns.sidr_guard_spawn()
		bar_spawn.arbalet()
		db.actor:give_info_portion("encyclopedy_tutorial_jump")
		db.actor:give_info_portion("encyclopedy_tutorial_crouch")
		db.actor:give_info_portion("encyclopedy_tutorial_sprint")
		db.actor:give_info_portion("encyclopedy_tutorial_binocular")
		db.actor:give_info_portion("encyclopedy_tutorial_relation")
		db.actor:give_info_portion("encyclopedy_tutorial_wound")
	--Спавн пластинок --TODO: Перенести в модуль музавтомата, наверно.
	spawn_object(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_1)
	spawn_object(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_2)
	spawn_object(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_3)	
	spawn_object(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_5)
	spawn_object(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_6)
	spawn_object(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_8)
	spawn_object(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_9)	
	spawn_object_rand(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_4)
	spawn_object_rand(ogse_spawn_db.script_spawn_registry.spawn_plastinki.plastinka_7)
	--Зомби на Радаре с рукой-артефактом
	dsh.create_free_mob("rad_zombie_rusty", vector():set(359, -45, -111), 1, 1940)
	end

------------KD: установка настроек графики------------
	-- шмапы
	--log1("[KD] applying graphics settings")
	cmd("r2_ls_depth_bias -0.00005")
	cmd("r2_ls_depth_scale 1.00001")
	cmd("r2_sun_depth_far_bias -0.00001")
	cmd("r2_sun_depth_far_scale 1.0")
	cmd("r2_sun_depth_near_bias -0.0001")
	cmd("r2_sun_depth_near_scale 1.00004")
	cmd("r2_sun_focus on")
	cmd("r2_sun_near_border 1.")
	-- избавляемся от пересвета поверхностей
	-- блум
	cmd("r2_ls_bloom_threshold 1.")
	-- мультипликатор цвета солнца (идиотская настройка)
	cmd("r2_sun_lumscale 1.")
	cmd("r2_rain_drops_control on") --капли на стекле
	cmd("r2_lens_dirt_control on") --грязь на линзе
	cmd("cam_inert 0") --KRodin: сбрасываем инерцию камеры в 0
-----------------------KD: end-------------------------

	ogse_debug.process_actor("a_spw", 1110)
	db.register_all_quest_zones()
end


function kill_offline_npc(obj)
	if obj then
		local pk = xs_netpk.monster(obj)
		if not pk:isOk() then
			pk = xs_netpk.stalker(obj)
		end
		local data = pk:get()
		data.health = 0
		data.updhealth = 0
		pk:set(data)
		obj.offline_dead = 1
		smart_terrain.on_death( obj.id )
	end
end

-- возвращает уровень здоровья НПС, для проверки в оффлайне жив/мёртв НПС
function check_offline_npc(obj)
	if obj then
		local pk = xs_netpk.monster(obj)
		if not pk:isOk() then
			pk = xs_netpk.stalker(obj)
		end
		
		local data = pk:get()
		local health = data.health
		return health > 0
	end
end

-------------------Выводим время на HUD-------------------
function show_time( forced ) --forced должен быть true, если апдейт вызван не из менеджера сигналов (например, из ogse_sleep_mgr).
	if forced ~= true then
		ogse_signals.get_mgr():reschedule( 60000 / game_time_factor )
	end
	local hud = get_hud()
	local cs = hud:GetCustomStatic("hud_timer_text1")
	if not cs then
		cs = hud:AddCustomStatic("hud_timer_text1", true)
	end
	local h = level.get_time_hours()
	local m = level.get_time_minutes()
	local txt = (h >= 10 and h or "0"..h)..":"..(m >= 10 and m or "0"..m)
	cs:wnd():SetText(txt)
end
-----------------------------------------------------------

-- Парсинг ини-файла в массив
function parse_ini_section_to_array(ini,section)
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and string.trim(id)~="" and string.trim(id)~=nil then
				tmp[string.trim(id)] = string.trim(value)
			end
		end
	end
	return tmp
end

-- Туториал на пси-воздействие
function on_my_psy()
	if not has_alife_info("encyclopedy_tutorial_psy") then
		game.start_tutorial("part_7_psy")
		db.actor:give_info_portion("encyclopedy_tutorial_psy")
	end
end

-- вспомогательная функция, создание одного или нескольких объектов в заданной точке
-- назначение: убрать повторный код из функций далее по тексту
local function spawn_single_object_internal(res, spawn_item)
	ASSERT(spawn_item.sec, "[spawn_single_object_internal] section not defined")
	ASSERT(spawn_item.pos, "[spawn_single_object_internal] position not defined, sec = '%s'", spawn_item.sec)
	ASSERT(spawn_item.lvid, "[spawn_single_object_internal] lvid not defined, sec = '%s'", spawn_item.sec)
	ASSERT(spawn_item.gvid, "[spawn_single_object_internal] gvid not defined, sec = '%s'", spawn_item.sec)
	if spawn_item.lvl then
		ASSERT(level_system_name_by_gvid(spawn_item.gvid) == spawn_item.lvl,
			"[spawn_single_object_internal] gvid does not match the level name, sec = '%s', lvl = '%s', gvid = %d",
			spawn_item.sec,
			spawn_item.lvl,
			spawn_item.gvid
			)
	end
	local count = spawn_item.cnt or 1
	ASSERT(not (count > 1 and spawn_item.sid), "[spawn_single_object_internal] cannot assign same sid to multiple objects!, sec = '%s'", spawn_item.sec)
	local sim = alife()
	for i=1,count do
		local sobj_abstract = sim:create(spawn_item.sec, vector():set(unpack(spawn_item.pos)), spawn_item.lvid, spawn_item.gvid)
		-- получаем объект правильнго типа
		local sobj = sim:object(sobj_abstract.id)
		-- на самом деле в этой проверке нет смысла. Ситуации, когда объект создать не удалось, а выполнение продолжилось,
		-- просто не бывает. В этих случаях всегда идёт вылет. Но пусть будет
		ASSERT(sobj, "[spawn_single_object_internal] cannot create object, sec = '%s'", spawn_item.sec)
		if spawn_item.use_ai_location == false or spawn_item.use_ai_location == "false" then
			sobj:use_ai_locations(false)
		elseif spawn_item.use_ai_location == true or spawn_item.use_ai_location == "true" then
			sobj:use_ai_locations(true)
		end
		if spawn_item.sid then
			sim:assign_story_id(nil, nil, sobj.id, spawn_item.sid)
		end
		if spawn_item.angle then
			sobj.angle = vector():set(unpack(spawn_item.angle))
		end
		if spawn_item.inf then
			db.actor:give_info_portion(spawn_item.inf)
		end
		table.insert(res, sobj)
	end
end

-- спавнит один или несколько одинаковых предметов в заданной точке
-- фактически просто обёртка над spawn_single_object_internal
function spawn_object(spawn_item)
	local res = {}
	spawn_single_object_internal(res, spawn_item)
	return unpack(res)
end
-- спавнит несколько предметов, заданных таблицей
function spawn_objects(spawn_items)
	local res = {}
	for idx,spawn_item in ipairs(spawn_items) do
		spawn_single_object_internal(res, spawn_item)
	end
	return res
end
-- спавнит рандомно один из предметов, заданных таблицей
function spawn_object_rand(spawn_items)
	local spawn_item = spawn_items[math.random(#spawn_items)]
	local res = {}
	spawn_single_object_internal(res, spawn_item)
	return unpack(res)
end

function quest_spawn_ex(section, total, spawn_item)
	local res = {}
	for i=1,total do
		local spawn_item_tmp = table.clone_simple(spawn_item)
		spawn_item_tmp.sec = section
		spawn_single_object_internal(res, spawn_item_tmp)
	end
	return unpack(res)
end

function kill_crow()
	local lname = level.name()
	for k = 1, 65534 do
		local crow = level.object_by_id(k)
		if crow and crow:section() == "m_crow" and object_level_name(crow) == lname then
			local hit = hit()
				hit.direction = vector():set(0,0,0)
				hit.impulse = 10
				hit.draftsman = crow
				hit.power = 10
				hit.type = hit.strike
			crow:hit(hit)

			ogse.start_gtmr(nil, math.random(150, 300), "checker_minefield.add_to_delete", k)
		end
	end
end

--TODO: не из-за этой ли функции вороны вылетают из одной точки на земле?
function spawn_crow()
	local lv = db.actor:level_vertex_id()
	local gv = db.actor:game_vertex_id()
	local x_offset = 0
	local z_offset = 0
	local y_offset = 100
	for k=1,20 do
	x_offset = math.random(-100,100)
	z_offset = math.random(-100,100)
		local pos = db.actor:position()
		pos.x = pos.x + x_offset
		pos.y = pos.y + y_offset
		pos.z = pos.z + z_offset
		alife():create("m_crow", pos, lv, gv)
	end
end

function give_supplies_to_actor(first_speaker, second_speaker)
	if not db.actor:object("detector_simple") then
		dialogs.relocate_item_section(first_speaker, "detector_simple", "in")
	end
	if not db.actor:object("device_torch") then
		dialogs.relocate_item_section(first_speaker, "device_torch", "in")
	end
	if not db.actor:object("hand_radio_f") then
		dialogs.relocate_item_section(first_speaker, "hand_radio_f", "in")
	end
end

function give_binocl_to_actor(first_speaker, second_speaker)
	if not db.actor:object("wpn_binoc") then
		dialogs.relocate_item_section(first_speaker, "wpn_binoc", "in")
	end
end

--[[function money_in(money)
	dialogs.relocate_money(db.actor, money, "in")
end]]

--[[function money_out(money)
	dialogs.relocate_money(db.actor, money, "out")
end]]

function give_info(info)
	if not has_info(info) then
		db.actor:give_info_portion(info)
	end
end

function has_info(info)
	return db.actor:has_info(info)
end

-- функция создания окна сообщения, которое закроется само через определённое время
function autohiding_msg(txt, delay)
	local dlg = MonologueMsg(txt)
	level.start_stop_menu(dlg, true)
	autohide_dlg_timer(delay, dlg):start()
end

-- окно "монологового" типа. Просто сообщение в рамке.
-- Закрыть можно по ESC. Также можно использовать в комбинации с
-- таймером автозакрытия (см. MonologueMsg и ф-ю autohiding_msg)
class "MonologueMsg" (CUIScriptWnd)

function MonologueMsg:__init(txt) super()
	local xml = CScriptXmlInit()
	
	if device().width / device().height > 0.7 then
		xml:ParseFile("ui_ogse_monologue_msg.xml") -- 4^3
	else
		xml:ParseFile("ui_ogse_monologue_msg_16.xml") -- 16^9
	end	
	xml:InitWindow("main", 0, self)
	self.msg = xml:InitStatic("main:msg", self)
	self.msg:SetTextST(txt)
	self.dlg = self -- трюк для предотвращения вылета.
	-- Чтобы не было утечки памяти после закрытия окна надо обнулить эту ссылку
	-- (см. метод OnKeyboard и также метод срабатывания спец. таймера)
end
function MonologueMsg:OnKeyboard(dik, key_act) CUIScriptWnd.OnKeyboard(self,dik,key_act)
	if key_act == ui_events.WINDOW_KEY_PRESSED and dik == DIK_keys.DIK_ESCAPE then
		self:GetHolder():start_stop_menu(self,true)
		self.dlg = nil -- отпускаем объект для сборщика мусора
	end
	return true
end
-- служебный таймер для автоматического закрытия диалога через заданное время
class "autohide_dlg_timer" (ogse_qt.quick_timer)
function autohide_dlg_timer:__init(delay, dlg) super(delay)
	self.dlg = dlg
end
function autohide_dlg_timer:taction()
	if self.dlg and self.dlg:IsShown() then
		level.start_stop_menu(self.dlg,true)
		self.dlg.dlg = nil -- отпускаем объект для сборщика мусора
	end
end

--/* Уменьшения репутации на .. едениц главному герою..
function reputation_down_20(stalker, player)
	db.actor:change_character_reputation(-20)
end

function reputation_down_10(stalker, player)
	db.actor:change_character_reputation(-10)
end

function reputation_up_10(stalker, player)
	db.actor:change_character_reputation(10)
end

function reputation_up_20(stalker, player)
	db.actor:change_character_reputation(20)
end

--************************************************[Таймеры с визуальным счётчиком на худе]************************************************
--==============================[Таймер со счётчиком на экране]=================================
class "visual_timer" (ogse_st_mgr.savable_timer)
function visual_timer:__init(name) super(name)
	self._class = script_name()..".visual_timer"
end
function visual_timer:start(...)
	self.on_hud_show_desc = {signal = "on_hud_show", self = self, fun = self.on_hud_show}
	ogse_signals.get_mgr():subscribe(self.on_hud_show_desc)
	local hud = get_hud()
	hud:AddCustomStatic("hud_timer_2", true)
	hud:AddCustomStatic("hud_timer_text_2", true)

	return ogse_st_mgr.savable_timer.start(self, ...)
end
function visual_timer:init( action_name, ... )
	self.action_name = action_name
	self.user_action = loadstring( "return " .. self.action_name .. "( ... )" )
	ASSERT(
		self.user_action,
		"visual_timer:init: can not compile function with the name '%s'",
		tostring( self.action_name )
	)
	self.fun_params = { ... }
	return self
end
function visual_timer:stop()
	ogse_signals.get_mgr():unsubscribe(self.on_hud_show_desc)
	local hud = get_hud()
	hud:RemoveCustomStatic("hud_timer_2")
	hud:RemoveCustomStatic("hud_timer_text_2")

	ogse_st_mgr.savable_timer.stop(self)
end
function visual_timer:load( packet )
  self.action_name = packet:r_stringZ()
  self.user_action = loadstring( "return " .. self.action_name .. "( ... )" )
  ASSERT(
    self.user_action,
    "visual_timer:load: can not compile function with the name '%s'",
    tostring( self.action_name )
  )
  local array_item = ogse_unist.read_item_from_packet( packet )
  ASSERT(
    array_item.type == ogse_unist.types.array,
   "visual_timer:load: wrong parameters readed"
  )
  self.fun_params = array_item:get_value()
end
function visual_timer:save( packet )
  packet:w_stringZ( self.action_name )
  local array_item = ogse_unist.create_item( "", self.fun_params, "array" )
  ogse_unist.write_item_to_packet( packet, array_item )
end
function visual_timer:on_hud_show()
	local hud = get_hud()
	if hud:GetCustomStatic("hud_timer_2") then
		hud:RemoveCustomStatic("hud_timer_2")
	end
	hud:AddCustomStatic("hud_timer_2", true)
	if hud:GetCustomStatic("hud_timer_text_2") then
		hud:RemoveCustomStatic("hud_timer_text_2")
	end
	hud:AddCustomStatic("hud_timer_text_2", true)
end
function visual_timer:condition()
	local dt
	if self._game_termination_time then
		dt = game.CTime(self._game_termination_time):diffSec(game.get_game_time())
	elseif self._residual_time then
		dt =  self._residual_time - self._time_from_loading
	else
		abort("visual_timer:condition: can not update time visual. Time condition is not set.")
	end
	local h = math.floor(dt/3600)
	local m = math.floor(dt/60 - h*60)
	local s = math.floor(dt - h*3600 - m*60)
	local txt = string.format("%02d:%02d:%02d", h, m, s)
	get_hud():GetCustomStatic("hud_timer_text_2"):wnd():SetText(txt)
	return false
end
function visual_timer:taction()
  self.user_action( unpack( self.fun_params ) )
end

-------------[Обёртки для упрощённого запуска]-----------
function start_visual_timer(name, delay, fname, ...)
	return visual_timer(name):set_delay(delay):init(fname, ...):start(true)
end
function start_visual_gtimer(name, delay, fname, ...)
	return visual_timer(name):set_gdelay(delay):init(fname, ...):start(true)
end
---------------------------------------------------------
--==============================================================================================

--=============[Таймер со счётчиком на экране и дополнительным условием останова]===============
class "conditional_visual_timer" (visual_timer)
function conditional_visual_timer:__init(name) super(name)
	self._class = script_name()..".conditional_visual_timer"
end
function conditional_visual_timer:init(cond_name, action_name, ...)
	self.cond_name = cond_name
	self.user_condition = loadstring("return "..self.cond_name.."(...)")
	ASSERT(self.user_condition, "conditional_visual_timer:init: can not compile function with the name '"..tostring(self.cond_name).."'")

	return visual_timer.init(self, action_name, ...)
end
function conditional_visual_timer:condition()
	visual_timer.condition(self) -- всегда возвращает false

	return self.user_condition(unpack(self.fun_params))
end
function conditional_visual_timer:load(packet)
	self.cond_name = packet:r_stringZ()
	self.user_condition = loadstring("return "..self.cond_name.."(...)")
	ASSERT(self.user_condition, "conditional_visual_timer:load: can not compile function with the name '"..tostring(self.cond_name).."'")

	visual_timer.load(self, packet)
end
function conditional_visual_timer:save(packet)
	packet:w_stringZ(self.cond_name)

	visual_timer.save(self, packet)
end
function conditional_visual_timer:action() end --На всякий случай, чтобы тут гарантировано ничего не выполнялось.

-------------[Обёртки для упрощённого запуска]-----------
function start_conditional_visual_timer(name, --Имя таймера. Если nil - будет сгенерировано автоматически.
										delay, --Время до срабатывания (в секундах)
										cond_name, --Имя функции - условия для остановки таймера. Пример: script_name()..".fix_restrictors" Функция будет запускаться на каждом апдейте с аргументами {...} Если вернёт true - таймер остановится.
										act_name, --Имя функции, которая запустится при срабатывании таймера. Запускается с аргументами {...} Пример: script_name()..".fix_restrictors"
										... --Аргументы для функций cond_name и act_name. Могут быть типа string, number, boolean. А можно и вообще без аргументов вызывать.
										)
	return conditional_visual_timer(name):set_delay(delay):init(cond_name, act_name, ...):start(true)
end
function start_conditional_visual_gtimer(name, delay, cond_name, act_name, ...)
	return conditional_visual_timer(name):set_gdelay(delay):init(cond_name, act_name, ...):start(true)
end
---------------------------------------------------------
--==============================================================================================
--****************************************************************************************************************************************

function fix_restrictors(npc)

	if not npc then return end

	local t = parse_names(npc:in_restrictions())

	local pk = nil
	local sObj = alife():object(npc:id())
	if sObj then
		pk = xs_netpk.stalker(sObj)
	end

	for k, v in pairs(t) do
		if not xr_gulag.valid_restrictors[v] then
			npc:remove_restrictions("", v)
			log1("[OGSE] Invalid in restriction ["..v.."] for ["..npc:name().."], removed")
		else	
			if pk and pk:isOk() then
				local data = pk:get()
				local base_out_restr = data.base_out_restrictors
				if base_out_restr ~= "" then
					for base in string.gmatch(base_out_restr, "[^,]+") do
						--log1("[OGSE] NPC "..npc:name().." RESTRICTOR "..base)
						if v == base then
							log1("[OGSE] IN Restriction ["..v.."] changed to OUT for ["..npc:name().."], according spawn")
							npc:remove_restrictions("", v)
							npc:add_restrictions(v, "")
						end
					end
				end
			end
		end
	end

	t = parse_names(npc:out_restrictions())
	
	for k, v in pairs(t) do
		if not xr_gulag.valid_restrictors[v] then
			npc:remove_restrictions(v, "")
			log1("[OGSE] Invalid out restriction ["..v.."] for ["..npc:name().."], removed")
		end
	end	
end

local readers = {}
function get_lvids_count(lname)
	local level_ai_reader = readers[lname]
	if not level_ai_reader then
		local fs = getFS()
		if not fs:exist("$game_levels$", lname.."\\level.ai") then
			return 0
		end
		level_ai_reader = fs:r_open("$game_levels$", lname.."\\level.ai")
		readers[lname] = level_ai_reader 
	end
	
	level_ai_reader:r_seek(0)
	local ver = level_ai_reader:r_u32() --4 -- версия файла
	local v_number = level_ai_reader:r_u32() --4 -- количество вертексов
	return v_number
end

function transfer_items_to_box(box_sid, remove_quest_items, exclude_sections, exclude_clsids)
	local box = level_object_by_sid(box_sid)
	if not box then return end
	local cnt = db.actor:object_count()
	for i=0, cnt-1 do
		local obj = db.actor:object(i)
		-- есть ли объект
		if obj then
		local sect = obj:section()
		-- фильтр по запрещенным class id
		if not exclude_clsids or not exclude_clsids[obj:clsid()] then
		-- фильтр по запрещенным секциям
		if not exclude_sections or not exclude_sections[sect] then
		-- фильтр по квестовым вещам
		if remove_quest_items or not (sys_ini:line_exist(sect, "quest_item") and sys_ini:r_bool(sect, "quest_item")) then
			-- особая обработка метки
			if sect == "amk_metka" then
				ogse_metka.dropped_to_box = ogse_metka.dropped_to_box + 1
			end
			-- передаем предмет
			db.actor:transfer_item(obj, box)
		end
		end
		end
		end
	end
end

function transfer_items_from_box(box_sid, remove_quest_items, exclude_sections, exclude_clsids)
	local box = level_object_by_sid(box_sid)
	if not box then return end
	local cnt = box:inv_box_count()
	for i=0, cnt-1 do
		local obj = box:object_from_inv_box(i)
		-- есть ли объект
		if obj then
			local sect = obj:section()
			-- передаем предмет
			box:transfer_item(obj, db.actor)
		end
	end
end
