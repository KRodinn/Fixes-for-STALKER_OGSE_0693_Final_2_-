------------------------------------------------------------
class "timeout_timer" ( ogse_qt.quick_timer )
function timeout_timer:__init( delay, fun, ... ) super( delay )
  self.fun = fun
  self.args = { ... }
end
function timeout_timer:taction()
  self.fun( unpack( self.args ) )
end

function timeout( delay, fun, ... )
  local tmout = timeout_timer( delay, fun, ... )
  --
  local d = debug.getinfo(2)
  ASSERT(d, "")
  tmout.script_name = d.short_src:gsub('^.-([^\\]+)%.[^.]+$', '%1')
  tmout.line = d.linedefined
  --
  tmout:start()
  return tmout
end


class "condition_timer" ( ogse_qt.quick_timer )
function condition_timer:__init( fun1, fun2, fun3 )
  self.fun1 = fun1
  self.fun2 = fun2
  self.fun3 = fun3
end
function condition_timer:condition()
  return self.fun1()
end
function condition_timer:action()
  self.fun2()
end
function condition_timer:update()
  if self.fun3 then self.fun3() end
end

function wait_condition( ... )
  local tmout = condition_timer( ... )
  --
  local d = debug.getinfo(2)
  ASSERT(d, "")
  tmout.script_name = d.short_src:gsub('^.-([^\\]+)%.[^.]+$', '%1')
  tmout.line = d.linedefined
  --
  tmout:start()
  return tmout
end


class "exec_on_update_timer" ( ogse_qt.quick_timer )
function exec_on_update_timer:__init( fun, ... )
  self.fun  = fun
  self.args = { ... }
end
function exec_on_update_timer:condition()
  return true
end
function exec_on_update_timer:update()
  self.fun( unpack( self.args ) )
end

function exec_on_update( ... )
  local tmout = exec_on_update_timer( ... )
  --
  local d = debug.getinfo(2)
  ASSERT(d, "")
  tmout.script_name = d.short_src:gsub('^.-([^\\]+)%.[^.]+$', '%1')
  tmout.line = d.linedefined
  --
  tmout:start()
  return tmout
end
-------------------------------------------------------------


function remove_quotes( s ) --Вырезать все кавычки из строки
  return string.gsub( s, "[«»\"\']", "" )
end

function strip_quotes( s ) --Срезать кавычки с начала и с конца строки
  --return string.gsub( s, '^[«»\"\']*(.-)[«»\"\']*$', '%1') --Срезает ВСЕ кавычки слева и справа.
  return string.gsub( s, '^[«»\"\'](.*)[«»\"\']$', '%1') --Срезает самую первую кавычку слева и самую последнюю кавычку справа.
end


------------------------------------------------------------------------
function attach( sm )
  sm:subscribe({ signal = "se_monster_on_before_register", fun = this.se_on_before_register })
  sm:subscribe({ signal = "se_stalker_on_before_register", fun = this.se_on_before_register })
end

local is_creating_free_mob = false
function se_on_before_register( sobj )
  if is_creating_free_mob then
    is_creating_free_mob = false
    set_none_smart_terrain( sobj )
  end
end

function set_none_smart_terrain( sobj )
  local pk = get_netpk( sobj, 1 )
  ASSERT( pk:isOk(), "can't read netpacket of %s", sobj:name() )
  local data = pk:get()
  local cd   = data.custom_data:getTable()
  --log3("~~[Custom data %s before set_none_smart_terrain]: %s", sobj:name(), cd)
  cd.smart_terrains = {
    [ "none" ] = "true",
  }
  --log3("--[Custom data %s after set_none_smart_terrain]: %s", sobj:name(), cd)
  data.custom_data:set( cd )
  pk:set( data )
end

-- Создать свободного моба, которого не затянет в какой-нибудь гулаг.
function create_free_mob( ... )
  is_creating_free_mob = true
  return alife():create( ... )
end
------------------------------------------------------------------------


local ini_file_cache = {}
function cached_ini_file( fname )
  if not ini_file_cache[ fname ] then
    ini_file_cache[ fname ] = ini_file( fname )
  end
  return ini_file_cache[ fname ]
end


--Можно использовать эту функцию, если по каким-то причинам недоступен метод use_ai_locations( false ) у серверного объекта
function clear_used_ai_locations( sobj )
  local pk = get_netpk( sobj, 1 )
  ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
  local data = pk:get()
  data.object_flags = bit_and(
    data.object_flags, bit_not( object_flags.UsedAI_Locations )
  ) -- снять флаг flUsedAI_Locations
  pk:set( data )
end


function clear_useful_for_ai( sobj )
  local pk = get_netpk( sobj, 1 )
  ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
  local data = pk:get()
  data.object_flags = bit_and(
    data.object_flags, bit_not( object_flags.UsefulForAI )
  )
  pk:set( data )
end


class "cached_condlist"
function cached_condlist:__init( parsed, ttl )
  self.parsed = parsed
  self.ttl    = ttl
end
function cached_condlist:pick_section_from_condlist( actor, npc )
  if ( not self.cached_time ) or self.cached_time < time_global() then
    self.cached_res  = xr_logic.pick_section_from_condlist(
      actor, npc, self.parsed
    )
    self.cached_time = time_global() + self.ttl
  end
  return self.cached_res
end
