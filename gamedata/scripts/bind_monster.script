-----------------------------------------------------------------------------------
-- Monster binding
-----------------------------------------------------------------------------------
local debug_flag = false

function bind(obj)
	local new_binder = generic_object_binder(obj)
	obj:bind_object(new_binder)
end

------------------------------------------------------------------------------------
class "generic_object_binder" (object_binder)

function generic_object_binder:__init(obj) super(obj)
	self.loaded = false
	self.am = ogse_signals.get_mgr()
	self.am:call( "on_monster_init", obj, self )
end 

function generic_object_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_object_binder:reinit()
	object_binder.reinit(self)

	-- У торговца нет поддержки перемещения
	if self.object:clsid() ~= clsid.script_trader then
		self.object:set_patrol_extrapolate_callback(generic_object_binder.extrapolate_callback, self)
	end

	db.storage[self.object:id()] = {}
	self.st = db.storage[self.object:id()]

	self.object:set_callback(callback.patrol_path_in_point, self.waypoint_callback, self)
	self.object:set_callback(callback.hit, self.hit_callback, self)
	self.object:set_callback(callback.death, self.death_callback, self)
	if self.object:clsid() == clsid.script_trader then
		self.object:set_callback(callback.use_object, self.use_callback, self)
	end
	self.object:set_callback(callback_ex.entity_alive_before_hit, self.before_hit_callback, self)
end

function generic_object_binder:net_spawn(sobject)
	ogse_debug.process_monster(self.object, "m_spw", 1)
	if not object_binder.net_spawn(self, sobject) then
		ogse_debug.process_monster(self.object, "m_spw", 0)
		return false
	end

	db.add_obj(self.object)

	ogse_debug.process_monster(self.object, "m_spw", 3)
	xr_gulag.setup_gulag_and_logic_on_spawn( self.object, self.st, sobject, modules.stype_mobile, self.loaded )

	ogse_debug.process_monster(self.object, "m_spw", 4)
	local particle_param = get_string( self.object:section(), "bones_particles" )
	if particle_param and sys_ini:section_exist(particle_param) then
		local tmp=ogse.parse_ini_section_to_array(sys_ini,particle_param)
		for k,v in pairs(tmp) do
			local t = ogse.parse_ini_section_to_array(sys_ini, v)
			t.obj = self.object
			if not t.stop_on_death or self.object:alive() then
				dsh_particles.play_particle(self.object, t)
			end
		end
	end

	ogse_debug.process_monster(self.object, "m_spw", 2)
	news_main_spawn.on_spawn(self.object)

	ogse_debug.process_monster(self.object, "m_spw", 6)
	if not self.object:alive() then
		--' Наносим небольшой импульс вперед.
		local h = hit()
		h.draftsman = self.object
		h.type = hit.fire_wound
		h.direction = db.actor:position():sub(self.object:position())
		h:bone("bip01_spine")
		h.power = 0.01
		h.impulse = 1
		self.object:hit(h)	

		ogse_debug.process_monster(self.object, "m_spw", 61)
		local s_obj = alife():object(self.object:id())
		if s_obj.offline_dead == 1 then
			if debug_flag then
				log1("--ВНИМАНИЕ! Обнаружен погибший в оффлайне! Объект: ИД: "..self.object:id().." ИМЯ:"..self.object:name().." Будет произведена обработка лута и постановка объекта на удаление!")		
				db.actor:give_game_news(game.translate_string("bind_monster_debug1")..self.object:id()..game.translate_string("bind_monster_debug2")..self.object:name()..game.translate_string("bind_monster_debug3"), "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end
			s_obj.offline_dead = game.time()+(1*24*60*60*1000)
		elseif s_obj.offline_dead > 1 and s_obj.offline_dead <= game.time() then
			ogse_debug.process_monster(self.object, "m_spw", 62)
			if debug_flag then
				log1("--ВНИМАНИЕ! Обнаружен уже обработанный погибший в оффлайне! Объект: ИД: "..self.object:id().." ИМЯ:"..self.object:name().." Будет произведено удаление объекта!")			
				db.actor:give_game_news(game.translate_string("bind_monster_debug21")..self.object:id()..game.translate_string("bind_monster_debug2")..self.object:name()..game.translate_string("bind_monster_debug22"), "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end

			if checker_minefield.to_delete[self.object:id()] == nil and db.actor:position():distance_to(self.object:position()) >= 100 then
				checker_minefield.to_delete[self.object:id()] = self.object:id()
			end			
		end
	end	

	ogse_car_control.register_target(self.object)
	ogse_scripted_btr.register_target(self.object)

	ogse_debug.process_monster(self.object, "m_spw", 63)
	self.am:call( "on_monster_spawn", self.object, self )

	ogse_debug.process_monster(self.object, "m_spw", 0)
	return true
end

function generic_object_binder:update(delta)
	ogse_debug.check_npc()
	ogse_debug.check_actor()
	
	ogse_debug.process_monster(self.object, "upd", 1)
	if string.find(self.object:name(), "crow_") then
		ogse_debug.process_monster(self.object, "upd", 0)
		return false
	end

	object_binder.update(self, delta)

	ogse_debug.process_monster(self.object, "upd", 8)
	if self.object:alive() then
		if self.object:is_talk_enabled() then
			self.object:set_tip_text("character_use")
		else
			self.object:set_tip_text("")
		end
	else
		self.object:set_tip_text_default()
	end
	
	ogse_debug.process_monster(self.object, "upd", 11)
	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
	end

	ogse_debug.process_monster(self.object, "upd", 12)
	self.am:call( "on_monster_update", self.object, delta )
	self.am:call( "on_monster_update." .. self.object:id(), self.object, delta )

	ogse_debug.process_monster(self.object, "upd", 0)
end

function generic_object_binder:use_callback(obj, who)
	self.am:call("npc_use", self.object, who)
end

function generic_object_binder:extrapolate_callback()
    if not self.object:get_script() then return false end

	local cur_pt = self.object:get_current_point_index()
	if patrol(self.object:patrol()):flags(cur_pt):get() == 0 then
		return true
	end
	return false
end

function generic_object_binder:waypoint_callback(obj, action_type, index)
	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "waypoint_callback", obj, action_type, index)
	end
end

function generic_object_binder:death_callback(victim, who)
	ogse_debug.process_monster(victim, "dth", 1)
	if who and string.find(who:name(), "vehicle_btr") then
		who = db.actor
	end

	local name = tostring(victim:name())

	if not self.object then
		self.object = victim
	end

	if name == "secret_villager" then
		db.actor:give_info_portion("secret_villager_dead")
	end

	ogse_debug.process_monster(victim, "dth", 2)
	if db.actor then -- добавлено KamikaZze  с целью отладки 25/02/2009
	--	if who:id() == db.actor:id() then
	-- добавление опыта за убийство
			xr_statistic.addKillCount(who, self.object)
	--	end
	end

	ogse_debug.process_monster(victim, "dth", 3)
	if self.st and self.st.mob_death then
		xr_logic.issue_event(self.object, self.st.mob_death, "death_callback", victim, who)
	end

	ogse_debug.process_monster(victim, "dth", 4)
	if self.st and self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
	end

	ogse_debug.process_monster(victim, "dth", 5)
	smart_terrain.on_death( self.object:id() )

	ogse_debug.process_monster(victim, "dth", 6)
	--проверка на аномалии  
	ogse_death_artefact.on_death(victim, who)

	ogse_debug.process_monster(victim, "dth", 7)
	if checker_minefield then checker_minefield.mine_hit(victim,who) end

	ogse_debug.process_monster(victim, "dth", 8)
	--' Наносим небольшой импульс вперед.
	local h = hit()
	h.draftsman = self.object
	h.type = hit.fire_wound
	if db.actor ~= nil then -- добавлено KamikaZze  с целью отладки 25/02/2009
		h.direction = db.actor:position():sub(self.object:position())
	end
	h:bone("pelvis")
	h.power = 1
	h.impulse = 10
	self.object:hit(h)

	ogse_debug.process_monster(victim, "dth", 11)
	smart_monster_parts.death_spawn(victim)

	ogse_debug.process_monster(victim, "dth", 12)	
	ogse_car_control.unregister_target(self.object)
	ogse_scripted_btr.unregister_target(self.object)

	ogse_debug.process_monster(victim, "dth", 13)	

	self.am:call( "on_monster_death", victim, who )

	ogse_debug.process_monster(victim, "dth", 0)
end

function generic_object_binder:before_hit_callback(p_s_hit, p_ignore_flags)
	self.last_hit_data = read_hit_data( p_s_hit )
	self.am:call( "on_monster_before_hit", self.object, self.last_hit_data, p_s_hit, p_ignore_flags, self )
end

function generic_object_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	ogse_debug.process_monster(self.object, "hit", 1)
	if who and obj and string.find(who:name(), "vehicle_btr") then
		who = db.actor
	end	

	ogse_debug.process_monster(self.object, "hit", 2)
	if self.st.hit then
		xr_logic.issue_event(self.object, self.st.hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end

	ogse_debug.process_monster(self.object, "hit", 3)
	if checker_minefield then checker_minefield.mine_hit(obj,who) end

	ogse_debug.process_monster(self.object, "hit", 4)
	smart_monster_parts.main_check(obj, amount, local_direction, who, bone_index)

	ogse_debug.process_monster(self.object, "hit", 5)
	_sdata.info_about_npc(obj)

	ogse_debug.process_monster(self.object, "hit", 7)
	self.am:call( "on_monster_hit", obj, amount, local_direction, who, bone_index, self )

	ogse_debug.process_monster(self.object, "hit", 0)
end

function generic_object_binder:net_destroy()
	self.object:set_callback(callback.death, nil)
	self.object:set_callback(callback.patrol_path_in_point, nil)
	self.object:set_callback(callback.hit, nil)
	if self.object:clsid() == clsid.script_trader then
		self.object:set_callback(callback.use_object, nil)
	end
	self.object:set_callback( callback_ex.entity_alive_before_hit, nil )

	local st = db.storage[self.object:id()]
	if st and st.active_scheme then
		xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
	end

	db.del_obj(self.object)
	db.storage[self.object:id()] = nil

	ogse_car_control.unregister_target(self.object)
	ogse_scripted_btr.unregister_target(self.object)

	self.am:call( "on_monster_net_destroy", self.object )
	self.am:cleanup_signal_subs( "on_monster_update." .. self.object:id() )

	object_binder.net_destroy(self)
end 

function generic_object_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_object_binder:net_save_relevant()
	return true
end

function generic_object_binder:save(packet)
	xr_logic.pstor_store(self.object, "is_invulnerable", self.object:invulnerable())

	if string.find(self.object:name(), "crow_") then
		return false
	end

	object_binder.save(self, packet)

	xr_logic.save_obj(self.object, packet)
	if self.object:clsid() == clsid.script_trader then
		trade_manager.save(self.object, packet)
	end
end

-- применять так: if self:actor_targets_monster(self.object) then ...
-- Проверяет в прицеле ли монстр
--[[function generic_object_binder:actor_targets_monster(npc)
	if npc then
	  local dangerang=1/npc:position():distance_to(db.actor:position())
	  local ang = horz_angle(device().cam_dir,npc:position():sub(device().cam_pos))
	  local tgt=ang>-dangerang and ang<dangerang
	    if tgt then
		  if self.tgt_time then
		    	return self.tgt_time<time_global()
		  else
			  self.tgt_time=time_global()+600
		  return false end
	    else
		   self.tgt_time=nil
	   end
	   return false
   end
end

-- Возвращает угол между проекциями векторов vec1 и vec2 на горизонтальную плоскость
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle(vec1,vec2)
  local x=vec2.x*vec1.x+vec2.z*vec1.z
  local y=-vec2.z*vec1.x+vec2.x*vec1.z -- повернули систему координат     
  return math.atan2(y,x) -- угол доворота от -pi до pi
end]]

function generic_object_binder:load(reader)
	if string.find(self.object:name(), "crow_") then
		return false
	end

	self.loaded = true

	object_binder.load(self, reader)

	if reader:r_eof() then
		abort("SAVE FILE IS CORRUPT")
	end

	xr_logic.load_obj(self.object, reader)

	if self.object:clsid() == clsid.script_trader then
		trade_manager.load(self.object, reader)
	end

	local is_invulnerable = xr_logic.pstor_retrieve(self.object, "is_invulnerable", false)
	self.object:invulnerable(is_invulnerable)
end
