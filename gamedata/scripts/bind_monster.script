--------------------
--Monster binding
--------------------
function bind(obj)
	local new_binder = generic_object_binder(obj)
	obj:bind_object(new_binder)
end

------------------------------------------------------------------------------------
class "generic_object_binder" (object_binder)

function generic_object_binder:__init(obj) super(obj)
	self.loaded = false

	self.am = ogse_signals.get_mgr()
	self.am:call( "on_monster_init", obj, self )
end 

function generic_object_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_object_binder:reinit()
--log3("~~[%s] Start reinit [%s]", script_name(), self.object and self.object:name() or "nil")
	object_binder.reinit(self)

	-- У торговца нет поддержки перемещения
	if self.object:clsid() ~= clsid.script_trader then
		self.object:set_patrol_extrapolate_callback(generic_object_binder.extrapolate_callback, self)
	end

	db.storage[self.object:id()] = {}
	self.st = db.storage[self.object:id()]

	self.object:set_callback(callback.patrol_path_in_point, self.waypoint_callback, self)
	self.object:set_callback(callback.hit, self.hit_callback, self)
	self.object:set_callback(callback.death, self.death_callback, self)
	--self.object:set_callback(callback.use_object, self.use_callback, self)
	self.object:set_callback(callback_ex.entity_alive_before_hit, self.before_hit_callback, self)
--log3("--[%s] End reinit [%s]", script_name(), self.object and self.object:name() or "nil")
end

local debug_flag = false
function generic_object_binder:net_spawn(sobject)
--log3("~~[%s] Start net_spawn [%s]", script_name(), self.object and self.object:name() or "nil")
	if not object_binder.net_spawn(self, sobject) then return false end

	self:subscribe_updaters()

	db.add_obj(self.object)

	self.object:set_enemy_callback( self.enemy_callback, self )

	xr_gulag.setup_gulag_and_logic_on_spawn( self.object, self.st, sobject, modules.stype_mobile, self.loaded )

	if not self.object:alive() then
		--' Наносим небольшой импульс вперед.
		local h = hit()
		h.draftsman = self.object
		h.type = hit.fire_wound
		h.direction = db.actor:position():sub(self.object:position())
		h:bone("bip01_spine")
		h.power = 0.01
		h.impulse = 1
		self.object:hit(h)	

		local s_obj = alife():object(self.object:id())
		if s_obj.offline_dead == 1 then
			if debug_flag then
				log1("--ВНИМАНИЕ! Обнаружен погибший в оффлайне! Объект: ИД: "..self.object:id().." ИМЯ:"..self.object:name().." Будет произведена обработка лута и постановка объекта на удаление!")		
				db.actor:give_game_news(game.translate_string("bind_monster_debug1")..self.object:id()..game.translate_string("bind_monster_debug2")..self.object:name()..game.translate_string("bind_monster_debug3"), "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end

			if self.st and self.st.mob_death then
				xr_logic.issue_event(self.object, self.st.mob_death, "death_callback", self.object, self.object)
			end

			if self.st and self.st.active_section then
				xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", self.object, self.object)
			end

			self:clear_callbacks()

			s_obj.offline_dead = game.time()+(1*24*60*60*1000)
		elseif s_obj.offline_dead > 1 and s_obj.offline_dead <= game.time() then
			if debug_flag then
				log1("--ВНИМАНИЕ! Обнаружен уже обработанный погибший в оффлайне! Объект: ИД: "..self.object:id().." ИМЯ:"..self.object:name().." Будет произведено удаление объекта!")			
				db.actor:give_game_news(game.translate_string("bind_monster_debug21")..self.object:id()..game.translate_string("bind_monster_debug2")..self.object:name()..game.translate_string("bind_monster_debug22"), "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end

			checker_minefield.add_to_delete(self.object:id())
		end

		return true
	end

	self.am:call( "on_monster_spawn", self.object, self )
	return true
end

function generic_object_binder:subscribe_updaters()
  local s_name = "on_monster_update." .. self.object:id()
  if self.object:alive() then
    self.updaters = {
      {
        [ "signal" ] = s_name,
        [ "self"   ] = self,
        [ "fun"    ] = self.update_tip_text,
        [ "queued" ] = true,
      },
    }
  else
    self.updaters = {}
  end
  for _, s in ipairs( self.updaters ) do
    self.am:subscribe( s )
  end
end

function generic_object_binder:update(delta)	
	if string.find(self.object:name(), "crow_") then return false end

	object_binder.update(self, delta)

	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
	end

	self.am:call( "on_monster_update." .. self.object:id(), self.object, delta )
end

function generic_object_binder:update_tip_text()
	if self.object:is_talk_enabled() then
		self.object:set_tip_text("character_use")
	else
		self.object:set_tip_text("")
	end
end

--function generic_object_binder:use_callback(obj, who)
--	self.am:call("on_monster_use", self.object, who)
--end

function generic_object_binder:extrapolate_callback()
    if not self.object:get_script() then return false end

	local cur_pt = self.object:get_current_point_index()
	if patrol(self.object:patrol()):flags(cur_pt):get() == 0 then
		return true
	end
	return false
end

function generic_object_binder:waypoint_callback(obj, action_type, index)
	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "waypoint_callback", self.object, action_type, index)
	end
end

function generic_object_binder:death_callback(victim, who)
	for _, s in ipairs( self.updaters ) do
		self.am:unsubscribe( s )
	end
	self.updaters = {}
	self.object:set_tip_text_default()

	self:clear_callbacks()

	if who and string.find(who:name(), "vehicle_btr") then
		who = db.actor
	end

	if self.object:name() == "secret_villager" then
		db.actor:give_info_portion("secret_villager_dead")
	end

	--if db.actor then -- добавлено KamikaZze  с целью отладки 25/02/2009
	--	if who:id() == db.actor:id() then
	-- добавление опыта за убийство
			xr_statistic.addKillCount(who, self.object)
	--	end
	--end

	if self.st and self.st.mob_death then
		xr_logic.issue_event(self.object, self.st.mob_death, "death_callback", self.object, who)
	end

	if self.st and self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", self.object, who)
	end

	smart_terrain.on_death( self.object:id() )

	--' Наносим небольшой импульс вперед.
	local h = hit()
	h.draftsman = self.object
	h.type = hit.fire_wound
	--if db.actor ~= nil then -- добавлено KamikaZze  с целью отладки 25/02/2009
		h.direction = db.actor:position():sub(self.object:position())
	--end
	h:bone("pelvis")
	h.power = 1
	h.impulse = 10
	self.object:hit(h)

	self.am:call( "on_monster_death", self.object, who )
end

function generic_object_binder:before_hit_callback(p_s_hit, p_ignore_flags)
	local last_hit_data = read_hit_data( p_s_hit )
--log3("--[%s] Called before_hit_callback for [%s]: %s, %s, %s", script_name(), self.object:name(), last_hit_data, p_s_hit, p_ignore_flags)
	self.am:call( "on_monster_before_hit", self.object, last_hit_data, p_s_hit, p_ignore_flags, self )
end

function generic_object_binder:hit_callback(obj, amount, local_direction, who, bone_index)
--log3("--[%s] Called hit_callback for [%s]. Who: [%s], amount: [%s]", script_name(), self.object:name(), who:name(), amount)
	if who and string.find(who:name(), "vehicle_btr") then
		who = db.actor
	end	

	if self.st.hit then
		xr_logic.issue_event(self.object, self.st.hit, "hit_callback", self.object, amount, local_direction, who, bone_index)
	end

	self.am:call( "on_monster_hit", self.object, amount, local_direction, who, bone_index, self )
end

function generic_object_binder:net_destroy()
--log3("~~[%s] Start destroy [%s]", script_name(), self.object and self.object:name() or "nil")
	self:clear_callbacks()
	--self.object:set_callback(callback.use_object, nil)

	local st = db.storage[self.object:id()]
	if st and st.active_scheme then
		xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
	end

	db.del_obj(self.object)
	db.storage[self.object:id()] = nil

	self.am:call( "on_monster_net_destroy", self.object, self )
	self.am:cleanup_signal_subs( "on_monster_update." .. self.object:id() )

	object_binder.net_destroy(self)
--log3("--[%s] End destroy [%s]", script_name(), self.object and self.object:name() or "nil")
end 

function generic_object_binder:clear_callbacks()
	self.object:set_callback(callback.death, nil)
	self.object:set_callback(callback.patrol_path_in_point, nil)
	self.object:set_callback(callback.hit, nil)
	self.object:set_callback(callback_ex.entity_alive_before_hit, nil)
	self.object:set_enemy_callback()
end

function generic_object_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_object_binder:net_save_relevant()
	return true
end

function generic_object_binder:save(packet)
	if string.find(self.object:name(), "crow_") then return false end

	if self.object:clsid() ~= clsid.script_trader then
		xr_logic.pstor_store(self.object, "is_invulnerable", self.object:invulnerable())
	end

	object_binder.save(self, packet)

	xr_logic.save_obj(self.object, packet)

	if self.object:clsid() == clsid.script_trader then
		trade_manager.save(self.object, packet)
	end
end

-- применять так: if self:actor_targets_monster(self.object) then ...
-- Проверяет в прицеле ли монстр
--[[function generic_object_binder:actor_targets_monster(npc)
	if npc then
	  local dangerang=1/npc:position():distance_to(db.actor:position())
	  local ang = horz_angle(device().cam_dir,npc:position():sub(device().cam_pos))
	  local tgt=ang>-dangerang and ang<dangerang
	    if tgt then
		  if self.tgt_time then
		    	return self.tgt_time<time_global()
		  else
			  self.tgt_time=time_global()+600
		  return false end
	    else
		   self.tgt_time=nil
	   end
	   return false
   end
end

-- Возвращает угол между проекциями векторов vec1 и vec2 на горизонтальную плоскость
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle(vec1,vec2)
  local x=vec2.x*vec1.x+vec2.z*vec1.z
  local y=-vec2.z*vec1.x+vec2.x*vec1.z -- повернули систему координат     
  return math.atan2(y,x) -- угол доворота от -pi до pi
end]]

function generic_object_binder:load(reader)
--log3("~~[%s] Start load [%s]", script_name(), self.object and self.object:name() or "nil")
	if string.find(self.object:name(), "crow_") then return false end

	self.loaded = true

	object_binder.load(self, reader)

	if reader:r_eof() then
		abort("SAVE FILE IS CORRUPT")
	end

	xr_logic.load_obj(self.object, reader)

	if self.object:clsid() == clsid.script_trader then
		trade_manager.load(self.object, reader)
	else
		local is_invulnerable = xr_logic.pstor_retrieve(self.object, "is_invulnerable", false)
		self.object:invulnerable(is_invulnerable)
	end
--log3("--[%s] End load [%s]", script_name(), self.object and self.object:name() or "nil")
end

--Функция проверяет, может ли объект вступать в бой с предполагаемым противником (enemy_st).
--Если вернёт false - объект не будет вступать в бой.
--Вызывается:
--Одноименным калбеком из движка (для движковой боёвки)
--Из xrs_battle_ai.check_is_enemy (скриптовая боёвка)
--Из xr_danger
--Из xr_camper.action_patrol:process_danger()
--Из функции check_sound в мотиваторе
local enemy_callback_freq = 1000
function generic_object_binder:enemy_callback( obj, enemy_st )
  local valid, enemy = validate_enemy_object( enemy_st )
  if not valid then return false end

  return true
--[=[ --Отключено, т.к. пока не используется.
  local res, ttl
  local cached = self[ script_name() .. ".cached" ]
  if cached and cached[ enemy:id() ] then
    res, ttl = unpack( cached[ enemy:id() ] )
  end
  if res == nil or ttl < time_global() then
    local result = {}
    self.am:call( "on_monster_enemy_callback", self.object, enemy, result )
    res = result[1] ~= false
    if cached then
      cached[ enemy:id() ] = { res, time_global() + enemy_callback_freq }
    else
      self[ script_name() .. ".cached" ] = {
        [ enemy:id() ] = { res, time_global() + enemy_callback_freq }
      }
    end
  end
  return res
--]=]
end
