
-- https://github.com/dsh2dsh/op2ogse/blob/master/gamedata/scripts/dsh_wpn_slots.script

local slots = {
  [ 1 ] = {
    [ "coords"     ] = {
      [ "std"  ] = { 710, 410, 270, 60 }, --Квадратный экран
      [ "wide" ] = { 710, 402, 270, 72 }, --Широкий экран
    },
    [ "orig_slots" ] = {
      [ 1 ] = true,
      [ 2 ] = true,
    },
  },
  [ 2 ] = {
    [ "coords"     ] = {
      [ "std"  ] = { 710, 510, 270, 60 },
      [ "wide" ] = { 710, 502, 270, 72 },
    },
    [ "orig_slots" ] = {
      [ 1 ] = true,
      [ 2 ] = true,
    },
  },
}


function attach( sm )
  sm:subscribe({ signal = "on_first_update",   fun = this.restore_slots     })
  sm:subscribe({ signal = "on_save",           fun = this.on_save           })
  sm:subscribe({ signal = "on_inventory_open", fun = this.on_show_inventory })
  sm:subscribe({ signal = "on_inventory_hide", fun = this.on_hide_inventory })
  sm:subscribe({ signal = "on_drop",           fun = this.on_drop           })
end


local selected_item_id, clicked_slot

local subscribed
function on_show_inventory()
  if not subscribed then
    subscribed = {
      { signal = "on_select_item", fun = this.on_select_item },
      { signal = "on_key_down",    fun = this.on_key_down    },
      { signal = "on_key_up",      fun = this.on_key_up      },
    }
    local sm = ogse_signals.get_mgr()
    for _, s in ipairs( subscribed ) do
      sm:subscribe( s )
    end
  end
  selected_item_id = nil
  clicked_slot = nil
end


function on_hide_inventory()
  if subscribed then
    local sm = ogse_signals.get_mgr()
    for _, s in ipairs( subscribed ) do
      sm:unsubscribe( s )
    end
    subscribed = nil
  end
  selected_item_id = nil
  clicked_slot = nil
end


function restore_slots()
  local items     = ogse.load_var_safe( script_name() .. ".items" )
  if not items then return end
  local active    = ogse.load_var( script_name() .. ".active" )
  local new_slots = ogse.load_var( script_name() .. ".slots"  )
  for i, id in ipairs( items ) do
    local obj = level.object_by_id( id )
    ASSERT( obj, "object with id = %s not found", id )
    local slot = new_slots[ i ]
    if db.actor:is_in_slot( obj ) then
      --log3("~~[Restore_slots] Move to ruck obj: [%s]", obj:name())
      db.actor:move_to_ruck( obj ) --Необходимо, иначе будут глюки и непонятные вылеты
    end
    local item_in_slot = db.actor:item_in_slot( slot )
    if item_in_slot then --На всякий случай
      db.actor:move_to_ruck( item_in_slot )
    end
    --log3("~~[Restore_slots] Set slot for obj: [%s], [%s]", obj:name(), slot)
    set_inv_item_slot( obj, slot )
    --log3("~~[Restore_slots] Move to slot [%s] obj: [%s]", slot, obj:name())
    db.actor:move_to_slot( obj )
    if active[ i ] then
      --log3("~~[Restore_slots] Activate slot with obj: [%s]", obj:name())
      db.actor:activate_slot( slot )
    end
  end
end


function on_save()
  local active, items, new_slots = {}, {}, {}
  for slot, v in pairs( slots ) do
    local item_in_slot = db.actor:item_in_slot( slot )
    if item_in_slot then
      local orig_slot = get_u32( item_in_slot:section(), "slot" )
      ASSERT(
        orig_slot, "%s in slot %s without 'slot'", item_in_slot:name(), slot
      )
      if orig_slot ~= slot then
		table.insert(
          active, (
            db.actor:active_item()
            and db.actor:active_item():id() == item_in_slot:id()
          ) and true or false
        )
        table.insert( items, item_in_slot:id() )
        table.insert( new_slots, slot )
        db.actor:move_to_ruck( item_in_slot )
      end
    end
  end
  if table.getn( items ) > 0 then
    ogse.save_var( script_name() .. ".active", active,    "array", "bool" )
    ogse.save_var( script_name() .. ".items",  items,     "array", "u16"  )
    ogse.save_var( script_name() .. ".slots",  new_slots, "array", "u8"   )
    dsh.exec_on_update( this.restore_slots )
  else
    ogse.delete_var( script_name() .. ".active" )
    ogse.delete_var( script_name() .. ".items"  )
    ogse.delete_var( script_name() .. ".slots"  )
  end
end


function on_select_item( obj, sobj )
  --log3("~~Selected item : [%s]", obj:name())
  selected_item_id = obj:id()
end


function on_key_down( key, bind )
  if key == DIK_keys.DIK_MOUSE1 then
    local wnd = level.get_inventory_wnd()
    if wnd:IsShown() then
      local x, y = wnd:GetCursorX(), wnd:GetCursorY()
      clicked_slot = get_slot_by_xy( x, y )
	end
  end
end


function on_key_up( key, bind )
  if not selected_item_id then return end
  local selected_item = level.object_by_id(selected_item_id)
  if not selected_item then return end
  if key == DIK_keys.DIK_MOUSE1 then
    local wnd = level.get_inventory_wnd()
    if wnd:IsShown() then
      local x, y = wnd:GetCursorX(), wnd:GetCursorY()
      local slot = get_slot_by_xy( x, y )
	  --
	  if not slot then return end --Курсор не на слоте - нечего делать.
	  if clicked_slot then
	    if clicked_slot == slot then return end --Просто кликнули по слоту - нечего делать
	    local item_in_slot = db.actor:item_in_slot(clicked_slot)
		if item_in_slot then
		  if selected_item_id ~= item_in_slot:id() then
			return --Выбранный предмет не находится в слоте - нечего делать
		  end
		end
	  end
	  --
	  local selected_items_slot
	  if db.actor:is_in_slot( selected_item ) then
        selected_items_slot = get_inv_item_slot( selected_item )
      end
      if not (selected_items_slot and selected_items_slot == slot) then
        local orig_slot = get_u32( selected_item:section(), "slot" )
        if
          orig_slot and slots[ slot ].orig_slots[ orig_slot ]
          and get_inv_item_slot( selected_item ) ~= slot
        then
          move_item_to_slot( selected_item, slot )
          db.actor:invalidate_inventory()
          update_inventory_window()
          clicked_slot = nil
          selected_item_id = nil
		end
      end
	end
  end
end


function get_slot_by_xy( x, y )
  local k = is_16_9_mode() and "wide" or "std"
  for n, v in pairs( slots ) do
    local sx, sy, sw, sh = unpack( v.coords[ k ] )
    if x > sx and x < sx + sw and y > sy and y < sy + sh then
      return n
    end
  end
end


function move_item_to_slot( obj, slot )
  if db.actor:is_in_slot( obj ) then
    --log3("~~[Move_item_to_slot] Move to ruck obj: [%s]", obj:name())
    db.actor:move_to_ruck( obj ) --Необходимо, иначе будут глюки и непонятные вылеты
  end
  local item_in_slot = db.actor:item_in_slot( slot )
  if item_in_slot then
    db.actor:move_to_ruck( item_in_slot )
  end
  --log3("~~[Move_item_to_slot] Set slot for obj: [%s], [%s]", obj:name(), slot)
  set_inv_item_slot( obj, slot )
  --log3("~~[Move_item_to_slot] Move to slot [%s] obj: [%s]", slot, obj:name())
  db.actor:move_to_slot_and_activate( obj )
  if db.actor:active_slot() ~= slot then
    --log3("~~[Move_item_to_slot] Activate slot with obj: [%s]", obj:name())
    db.actor:activate_slot( slot )
  end
end


function on_drop(obj) --Чтобы не было глюков при продаже неписям
	if not obj:is_weapon_magazined() then return end

	local slot_engine = get_inv_item_slot(obj)
	local slot_cfg = get_u32(obj:section(), "slot")
	if slot_engine ~= slot_cfg then
		set_inv_item_slot(obj, slot_cfg)
		--log3("--Change clot for [%s]: [%s]", obj:name(), slot_cfg)
	end
end
