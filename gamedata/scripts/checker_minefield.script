--KRodin: теперь этот скрипт не имеет к минам никакого отношения.
--Теперь скрипт нужен только для безопасного удаления всяких объектов

--local to_delete = {}

function add_to_delete(id)
	--if not to_delete[id] then
	--	to_delete[id] = id
	--	run_del_mines_timer()
	--end
	local sobj = alife():object(id)
	if sobj then
		alife():release(sobj)
	end
end

--[=[ --KRodin: по-моему, для удаления всего того, что здесь удаляется, таймер не нужен.
function delete_mines()
	for k, v in pairs(to_delete) do
		local sobj = alife():object(v)
		if sobj then
			--log3("~~Try to delete object [%s]", sobj:name())
			alife():release(sobj, true)
		else
			to_delete[k] = nil
		end
	end
end

local del_mines_t
function run_del_mines_timer()
  if not del_mines_t then
    del_mines_t = check_del_mines_timer():start()
  end
end

class "check_del_mines_timer" ( ogse_qt.quick_timer )
function check_del_mines_timer:__init() super()
end

function check_del_mines_timer:condition()
  return next(to_delete) == nil
end

function check_del_mines_timer:action()
  del_mines_t = nil
end

function check_del_mines_timer:update()
  delete_mines()
end
--]=]

--*****************************************************************************************
--KRodin: средство безопасного удаления всяких рестрикторов, в т.ч. подходит для аномалий.
local SomeRestrictions_tbl = {
	[clsid.level_changer] = true,
	[clsid.smart_terrain] = true,
	[clsid.space_restrictor] = true,
	[clsid.script_zone] = true,
	[clsid.smart_zone] = true,
	[clsid.respawn] = true,
	[clsid.zone] = true,
	[clsid.script_restr] = true,
	[clsid.obj_climable] = true,
}

local to_delete_restrs = {}
function release_restrictor(id)
	local sobj = alife():object(id)
	if not sobj then return end

	if IsAnomaly(sobj) and not ogse_anomaly.is_not_anomaly(sobj) then --С аномалиями разберется менеджер аномалий.
		ogse_anomaly.set_anomaly_mode(id, "anom_off")
	elseif not IsAnomaly(sobj) and not SomeRestrictions_tbl[sobj:clsid()] then --И такое бывает
		alife():release(sobj, true)
	elseif not to_delete_restrs[id] then
		to_delete_restrs[id] = id
		run_del_restrs_timer()
	end
end

function delete_restrs()
	local sim = alife()
	--
	for i=1, 65534 do
		local sobj = sim:object(i)
		if sobj then
			local pk
			if IsStalker(sobj) or IsMonster(sobj) then
				pk = get_netpk(sobj, 1)
			end
			if pk then
				ASSERT(pk:isOk(), "It is not stalker and not monster: [%s]", sobj:name())
				local data = pk:get()
				for _, anom_id in pairs(data.dynamic_in_restrictions) do
					if to_delete_restrs[anom_id] then
						--log3("~~[%s] Removing in restriction [%s] from [%s]", script_name(), anom_id, sobj:name())
						sim:remove_in_restriction(sobj, anom_id)
						--log3("~~[%s] Removed in restriction [%s] from [%s]", script_name(), anom_id, sobj:name())
					end
				end
				for _, anom_id in pairs(data.dynamic_out_restrictions) do --Может это и не нужно, но пусть на всякий случай будет.
					if to_delete_restrs[anom_id] then
						log3("~~[%s.get_lists] Removing out restriction [%s] from [%s]", script_name(), anom_id, sobj:name())
						sim:remove_out_restriction(sobj, anom_id)
						log3("~~[%s.get_lists] Removed out restriction [%s] from [%s]", script_name(), anom_id, sobj:name())
					end
				end
			end
		end
	end
	--
	for k, v in pairs(to_delete_restrs) do 
		local restr_sobj = sim:object(v)
		if not restr_sobj then
			log3("!!RESTRICTOR WITH ID [%s] NOT FOUND!", v)
		else
			log3("~~[%s] Releasing restrictor [%s]", script_name(), restr_sobj:name())
			sim:release(restr_sobj, true)
			to_delete_restrs[k] = nil
			log3("--[%s] Restrictor released!", script_name())
		end
	end
end

local del_restrs_t
function run_del_restrs_timer()
  if not del_restrs_t then
    del_restrs_t = check_del_restrs_timer():start()
  end
end

class "check_del_restrs_timer" ( ogse_qt.quick_timer )
function check_del_restrs_timer:__init() super()
end

function check_del_restrs_timer:condition()
  return next(to_delete_restrs) == nil
end

function check_del_restrs_timer:action()
  del_restrs_t = nil
end

function check_del_restrs_timer:update()
  delete_restrs()
end
