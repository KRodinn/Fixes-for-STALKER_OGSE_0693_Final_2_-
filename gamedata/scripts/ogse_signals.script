-------------------------------------------------------------------------------
--| ogse_signals.script                                                     |--
--| signals and slots system                                                |--
--| Malandrinus, OGS Evolution Team, 2011                                   |--
--| version 1.1                                                             |--
-------------------------------------------------------------------------------

--[=[
Можно подписывать на события глобальные функции, методы классов, "методы" таблиц, 
функциональные объекты.

------------===< Пример для глобальной функции: >===------------------------------

function some_global_function(arg1, arg2)
end
local slot_desc = {signal = "signal_name", fun = some_global_function, queued = true}
ogse_signals.get_mgr():subscribe(slot_desc) -- подписали в низкоприоритетную очередь
--...
ogse_signals.get_mgr():unsubscribe(slot_desc) -- отписали
вызвали сигнал
local sm = ogse_signals.get_mgr()
--...
sm.call("signal_name", arg1, arg2)

------------===< Пример для функционального объекта: >===-------------------------

class "some_luabind_class"
function some_luabind_class:__init()
  local mt = getmetatable(self)
  mt.__call = self.method_to_call
end
function some_luabind_class:method_to_call()
end

local slot_desc = {signal = "signal_name", fun = some_luabind_class()}
ogse_signals.get_mgr():subscribe(slot_desc) -- подписали в высокоприоритетную очередь
--...
ogse_signals.get_mgr():unsubscribe(slot_desc) -- отписали

Функциональный класс на таблице строится немного сложнее
local t = {}
function t:method_to_call()
end
local mt = {}
mt.__call = t.method_to_call
getmetatable(t, mt)
end

------------===< Пример для произвольного метода класса: >===----------------------

class "some_luabind_class"
function some_luabind_class:__init()
end
function some_luabind_class:method_to_call()
end

class obj = some_luabind_class()
local slot_desc = {signal = "signal_name", self = obj, fun = obj.method_to_call}
ogse_signals.get_mgr():subscribe(slot_desc) -- подписали в высокоприоритетную очередь
--...
ogse_signals.get_mgr():unsubscribe(slot_desc) -- отписали
--]=]


local mgr
function get_mgr()
  if not this.mgr then
    -- this.mgr инициализируется внутри конструтора. См. комментарии там.
    signals_mgr( "global", ogse_signals_addons_list.addons, false )
  end
  return this.mgr
end


-- таблица счётчиков незавершённых вызовов для всех менеджеров
local unfinished_count     = {}
local checking_initialized = false

class "signals_mgr"             -- менеджер сигналов
function signals_mgr:__init( name, modules_list, scan_for_autoattaching_modules )
  -- следующая строка предотвращает повторное создание экземпляра
  -- менеджера событий в том случае, когда функция get_mgr()
  -- вызывается в глобальной области одного из подписываемых модулей.
  --
  -- код в глобальной области срабатывает во время prefetch() далее в
  -- этой функции т.е., в этом случае этот вызов происходит до того,
  -- как отработает конструктор __init и тогда вариант this.mgr =
  -- this.mgr or signals_mgr() не успевает отработать, что приводит к
  -- повторному вызову конструктора.
  --
  -- Теоретически это не приводит к проблемам, поскольку экземпляров
  -- менеджера сигналов может быть несколько, но лучше от такого
  -- застраховаться.
  this.mgr      = self -- а так ссылку прописываем ещё до завершения конструктора
  self.mgr_name = name
  self.signals  = {}
  self.slots_in_process = {}
  if modules_list then -- если задали список модулей, то начинаем их подключение
    local registered_modules = {}
    if scan_for_autoattaching_modules then
      -- только если вообще подключаем модули, тогда проверяем опцию
      -- автоподключения.
      -- ищем и регистрируем все автоподключаемые плагины
      local fs    = getFS()
      local flist = fs:file_list_open_ex(
        "$game_scripts$", FS.FS_ListFiles + FS.FS_ClampExt, "ogse_*.script"
      )
      for i = 0, flist:Size() - 1 do
        local file  = flist:GetAt( i )
        local fname = file:NameFull()
        prefetch( fname )
        local module = _g[ fname ]
        if
          module and type( module ) == "table"
          and type( module.attach ) == "function" and module.auto_attach == true
        then
          self:subscribe_module( fname )
          registered_modules[ fname ] = true
        end
      end
    end
    -- регистрируем все явно подключаемые плагины
    for _, fname in ipairs( modules_list ) do
      if not registered_modules[ fname ] then
        self:subscribe_module( fname )
      end
    end
  end
  unfinished_count[ self.mgr_name ] = 0
  if not checking_initialized then -- больше одного цикла проверки не нужно
    local function hanged_calls_check()
      for mgr_name, count in pairs( unfinished_count ) do
        if count > 0 then       -- если есть незавершённые вызовы
          log3( debug.traceback() )
          local n = #self.slots_in_process
          if n > 0 then
            local slot = self.slots_in_process[ n ]
            log3( "[%s]: signal on top: [%s], script_name = [%s]", script_name(), slot.signal, slot.script_name )
          end
          abort( "Signal manager '"..mgr_name.."' crushed:\nOne of the calls hung! See stack dump for details." ) -- RIP
        end
      end
    end
    level.add_call( hanged_calls_check, function() end ) -- сторожевой таймер
    checking_initialized = true
  end
end


local function slots_equal( slot1, slot2 )
  return
    rawequal( slot1.self, slot2.self )
    and rawequal( slot1.fun, slot2.fun )
end


function signals_mgr:is_already_subscribed( slot_in_question )
  local slots = self.signals[ slot_in_question.signal ]
  if not slots then return false end
  local check_slots = slot_in_question.queued
    and { slots.queue }
    or  { slots.normal, slots.scheduled }
  for _, cur in ipairs( check_slots ) do
    for _, slot in ipairs( cur ) do
      if slots_equal( slot, slot_in_question ) then
        return true
      end
    end
  end
  return false
end


function signals_mgr:subscribe( slot_to_subscribe )
  ASSERT(
    not self:is_already_subscribed( slot_to_subscribe ),
    "signals_mgr:subscribe: can't subscrabe signal '"
      .. slot_to_subscribe.signal .. "', it's already subscribed"
  )
  ASSERT(
    slot_to_subscribe.fun,
    "signals_mgr:subscribe: 'fun' is a nil reference while attempting to subscribe signal '"
      .. slot_to_subscribe.signal .. "'"
  )
  if not slot_to_subscribe.script_name then
    local d = debug.getinfo( 2, "S" )
    if d then
      slot_to_subscribe.script_name = d.source
    end
  end
  local signal = slot_to_subscribe.signal
  self.signals[ signal ] = self.signals[ signal ]
    or self:make_empty_signal( signal )
  if slot_to_subscribe.queued then
    slot_to_subscribe.timeout = 0
    table.insert( self.signals[ signal ].queue,  slot_to_subscribe )
  else
    table.insert( self.signals[ signal ].normal, slot_to_subscribe )
  end
end


function signals_mgr:make_empty_signal( signal )
  local t = {
    [ "normal" ] = {}, [ "queue" ] = {}, [ "scheduled" ] = {},
    [ "next_in_normal"    ] = 1,
    [ "next_in_queue"     ] = 1,
    [ "next_in_scheduled" ] = 1,
  }
  if
    string.find( signal, "update" )
	and not string.find( signal, "first_update" )
  then
    t.time_limited = true
  else
    t.time_limited = false
  end
  return t
end


function signals_mgr:unsubscribe( slot_to_unsubscribe )
  ASSERT(
    self:is_already_subscribed( slot_to_unsubscribe ),
    "signals_mgr:unsubscribe: can't unsubscrabe signal '"
      .. slot_to_unsubscribe.signal
      .. "', id = " .. ( slot_to_unsubscribe.id or '' )
      .. ", which is not previously subscribed"
  )
  if unfinished_count[ self.mgr_name ] > 0 then
    -- если находимся в процессе выполнения вызова, то физически
    -- удалять слоты из очередей нельзя надо просто промаркировать их
    -- на удаление, чтобы не менять размер очереди.  в дальнейшем
    -- промаркированные на удаление слоты не будут вызываться, а при
    -- ближайшем выходе из рекурсивного цикла будут удалены физически.
    self.to_unsubscribe = self.to_unsubscribe or {}
    self.to_unsubscribe[ slot_to_unsubscribe.signal ] =
      self.to_unsubscribe[ slot_to_unsubscribe.signal ] or {}
    table.insert(
      self.to_unsubscribe[ slot_to_unsubscribe.signal ], slot_to_unsubscribe
    )
    -- маркируем его, чтобы игнорировался при вызовах
    slot_to_unsubscribe.unsubscribed = true
  else
    -- нет незавершённых вызовов, просто удаляем слот
    local qn, qc
    if slot_to_unsubscribe.queued then
      qn, qc = "queue",     "next_in_queue"
    elseif slot_to_unsubscribe.scheduled then
      qn, qc = "scheduled", "next_in_scheduled"
    else
      qn, qc = "normal",    "next_in_normal"
    end
    local slots = self.signals[ slot_to_unsubscribe.signal ]
    for i, slot in ipairs( slots[ qn ] ) do
      if slots_equal( slot, slot_to_unsubscribe ) then
        table.remove( slots[ qn ], i )
        if slots[ qc ] > i then
          slots[ qc ] = slots[ qc ] - 1
        end
        break
      end
    end
  end
end


function signals_mgr:cleanup_signal_subs( signal )
  if self.signals[ signal ] then
    self.signals[ signal ] = self:make_empty_signal( signal )
  end
end


function signals_mgr:subscribe_module( module_name )
  prefetch( module_name )
  local res, msg = check_module( module_name )
  local module = _g[ module_name ]
  ASSERT(
    module,
    "signals_mgr:subscribe_module: Failed to subscribe module '"..module_name.."'"
  )
  ASSERT(
    type( module ) == "table",
    "signals_mgr:subscribe_module: Failed to subscribe module '"
      .. module_name .. "', must be a table"
  )
  ASSERT(
    type( module.attach ) == "function",
    "signals_mgr:subscribe_module: Failed to subscribe module '"
      .. module_name .. "', has no 'attach' function"
  )
  module.attach( self )
end


function signals_mgr:call( signal_name, ... )
  local slots = self.signals[ signal_name ]
  if slots then
    unfinished_count[ self.mgr_name ] = unfinished_count[ self.mgr_name ] + 1
    self:process_call( signal_name, slots, ... )
    unfinished_count[ self.mgr_name ] = unfinished_count[ self.mgr_name ] - 1

    if self.to_unsubscribe and unfinished_count[ self.mgr_name ] == 0 then
      -- если нет незавершённых вызовов, то можно по-настоящему
      -- удалять промаркированные для отписки слоты
      for signal, slots in pairs( self.to_unsubscribe ) do
        for _, slot in ipairs( slots ) do
          self:unsubscribe( slot )
        end
      end
      self.to_unsubscribe = nil
    end

    if slots.reschedule_queue and slots.next_in_queue == 1 then
      slots.reschedule_queue = false
      if #slots.queue > 1 then
        table.sort(
          slots.queue, function( a, b ) return a.timeout < b.timeout end
        )
      end
    end
    if slots.reschedule_scheduled and slots.next_in_scheduled == 1 then
      slots.reschedule_scheduled = false
      if #slots.scheduled > 1 then
        table.sort(
          slots.scheduled, function( a, b ) return a.timeout < b.timeout end
        )
      end
    end
  end
end


function signals_mgr:process_call( signal_name, slots, ... )
  local work_time = 0
---------------------------------------------------------------------------------------------
  while slots.next_in_normal <= #slots.normal do --Цикл выполнится для всех слотов в таблице slots.normal
    local slot = slots.normal[ slots.next_in_normal ] --slots.next_in_normal - индекс текущего слота в таблице slots.normal. Его и будем пробовать запускать.
    if slot.unsubscribed then --Если этот слот отписан, но ещё не удалён
      slots.next_in_normal = slots.next_in_normal + 1 --Переходим следующему слоту
    else
      local result
      table.insert( self.slots_in_process, slot )
      local pt = profile_timer()
      pt:start()
      if slot.self then --Запуск слота
        result = slot.fun( slot.self, ... )
      else
        result = slot.fun( ... )
      end
      pt:stop()
      work_time = work_time + pt:time()
      table.remove( self.slots_in_process )
      if slot.timeout then --Если время выполнения слота, ему задали таймаут для следующего запуска
        slots.reschedule_scheduled = true --Нужно пересортировать scheduled очередь
        slot.scheduled = true --Помечаем, что слот теперь в scheduled очереди
        table.insert( slots.scheduled, slot ) --Добавляем его в scheduled очередь
        table.remove( slots.normal, slots.next_in_normal ) --И удаляем из normal очереди
		--Здесь не нужно делать slots.next_in_normal = slots.next_in_normal + 1, т.к на место удалённого слота поднимется следующий после него
      else --Таймаут не задали
        slots.next_in_normal = slots.next_in_normal + 1 --Переходим к следующему слоту
      end
      if slots.time_limited then --Если время запуска сигнала ограничено, т.е. это какой-нибудь update
--[=[
        if work_time >= 30000 then --Если вызов сигнала идет слишком долго
          log3( --Выведем в лог информации, какой слот у нас так тормозит
            "~~[%s]: signal [%s] time limited in 'normal' queue: [%s]. Last call spent [%s], script_name = [%s]. Next is [%s] from [%s].",
            script_name(), signal_name, work_time,
            pt:time(), slot.script_name,
            slots.next_in_normal, #slots.normal
          )
          return --Вообще завершаем process_call.
        end
--]=]
      else --Если это НЕ какой-нибудь update
        if result then break end --Если вызванный слот вернул true, цикл прерываем. Для апдейтов это делать на мой взгляд бессмысленно, т.к они постоянно пересортировываются.
      end
    end
  end
---------------------------------------------------------------------------------------------
  while slots.next_in_scheduled <= #slots.scheduled do --Цикл выполнится для всех слотов в таблице slots.scheduled
    slot = slots.scheduled[ slots.next_in_scheduled ] --slots.next_in_scheduled - индекс текущего слота в таблице slots.scheduled. Его и будем пробовать запускать.
    if slot.unsubscribed then --Если этот слот отписан, но ещё не удалён
      slots.next_in_scheduled = slots.next_in_scheduled + 1 --Переходим к следующему слоту
    else
      if slot.timeout > time_global() then break end --Если время таймаута для этого слота не истекло, значит рано запускать и все последующие, т.к слоты отсортированы по таймауту. Прерываем цикл.
      table.insert( self.slots_in_process, slot )
      local pt = profile_timer()
      pt:start()
      if slot.self then --Запуск слота
        slot.fun( slot.self, ... )
      else
        slot.fun( ... )
      end
      --Думаю, в этой очереди не нужно прерывать цикл после слота, вернувшего true, т.к последовательность вызовов постоянно меняется при пересортировке.
      pt:stop()
      work_time = work_time + pt:time()
      table.remove( self.slots_in_process )
      slots.reschedule_scheduled = true --Нужна пересортировка
      slots.next_in_scheduled = slots.next_in_scheduled + 1 --Переходим к следующему слоту
--[=[
      if slots.time_limited and work_time >= 30000 then --Если вызов сигнала идет слишком долго
        log3( --Выведем в лог информации, какой слот у нас так тормозит
          "~~[%s]: signal [%s] time limited in 'scheduled' queue: [%s]. Last call spent [%s], script_name = [%s]. Next is [%s] from [%s].",
          script_name(), signal_name, work_time,
          pt:time(), slot.script_name,
          slots.next_in_scheduled, #slots.scheduled
        )
        return --Вообще завершаем process_call.
      end
--]=]
    end
  end
  slots.next_in_normal    = 1
  slots.next_in_scheduled = 1
---------------------------------------------------------------------------------------------
  local wrapped = self:try_call_queued( signal_name, slots, ... ) --Затем срабатывает очередной сигнал в очереди, если имеется
  if wrapped then --если ничего не удалось выполнить и перешли в начало очереди
    if slots.reschedule_queue then --Если нужна пересортировка, пересортировываем очередь.
      slots.reschedule_queue = false
      if #slots.queue > 1 then
        table.sort(
          slots.queue, function( a, b ) return a.timeout < b.timeout end
        )
      end
    end
    -- т.к. предыдущая попытка ничего не выполнила, попробуем
    -- выполнить первый обработчик. Ну, что бы этот апдейт не был
    -- холостым. Результат нам уже не важен, т.к. либо он будет
    -- выполнен, либо нам просто сейчас нечего делать.
    self:try_call_queued( signal_name, slots, ... )
  end
---------------------------------------------------------------------------------------------
  if work_time > 30000 then --Чтобы знать какие сигналы много жрут
    log3( "~~[%s]: signal [%s] is too slow: [%s]", script_name(), signal_name, work_time )
  end
end


function signals_mgr:try_call_queued( signal_name, slots, ... )
  local slot    = slots.queue[ slots.next_in_queue ] --slots.next_in_queue - индекс текущего слота в таблице slots.queue. Его и будем пробовать запускать.
  local wrapped = false
  if slot then
    if not slot.unsubscribed then --Если этот слот не отписан. Маловероятно, но на всякий случай.
      if slot.timeout <= time_global() then --Если слот уже пора запускать (истекло время таймаута)
        slot.timeout = 0 --обнуляем таймаут
        table.insert( self.slots_in_process, slot )
        if slot.self then --Запуск слота
          slot.fun( slot.self, ... )
        else
          slot.fun( ... )
        end
        table.remove( self.slots_in_process )
        if slot.timeout > 0 then --Если в вызванной функции задан таймаут для следующего запуска
          slots.reschedule_queue = true --Нужна пересортировка
        end
      else --Если запускать этот слот ещё рано
        if slots.next_in_queue > 1 then --Если это НЕ первый слот в очереди
          wrapped = true --Надо на этом же апдейте попробовать запустить следующий слот
        end
        slots.next_in_queue = 1 --Если рано запускать текущий слот, значит рано запускать и все последующие, т.к они отсортированы по таймауту. Поэтому следующим слотом будем запускать первый в очереди.
        return wrapped --Больше здесь делать нечего. Выходим.
      end
    end
    slots.next_in_queue = slots.next_in_queue + 1 --Индекс следующего слота
    if slots.next_in_queue > #slots.queue then --Если индекс больше чем кол-во слотов в очереди, значит это был последний слот.
      slots.next_in_queue = 1 --Следующим запущенным слотом будет первый в очереди.
    end
  end
  return wrapped --Фух, закончили.
end


--Установить таймаут для слота, который выполняется в данный момент
function signals_mgr:reschedule( timeout )
  local n = #self.slots_in_process
  ASSERT( n > 0, "empty slots_in_process table" )
  local slot   = self.slots_in_process[ n ]
  slot.timeout = time_global() + timeout
end


--Установить таймаут для конкретного слота.
--Пример использования можно посмотреть в ogse_weather_mgr.
function signals_mgr:rechange_scheduled_time( slot_in_question, new_timeout )
  ASSERT(slot_in_question, "")
  local slots = self.signals[ slot_in_question.signal ]
  ASSERT(slots, "")
  local check_slots = slot_in_question.queued
    and { slots.queue }
    or  { slots.normal, slots.scheduled }
  for _, cur in ipairs( check_slots ) do
    for _, slot in ipairs( cur ) do
      if slots_equal( slot, slot_in_question ) then
		--log3("~~[%s] Changing new timeout: [%s], old timeout: [%s]", script_name(), time_global() + new_timeout, slot.timeout)
		slot.timeout = time_global() + new_timeout
        return
      end
    end
  end
  abort("[signals_mgr:rechange_scheduled_time] SLOT ISN'T SUBSCRIBED!")
end
