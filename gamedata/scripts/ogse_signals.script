-------------------------------------------------------------------------------
--| ogse_signals.script                                                     |--
--| signals and slots system                                                |--
--| Malandrinus, OGS Evolution Team, 2011                                   |--
--| version 1.1                                                             |--
-------------------------------------------------------------------------------

--[=[
Можно подписывать на события глобальные функции, методы классов, "методы" таблиц, 
функциональные объекты.

------------===< Пример для глобальной функции: >===------------------------------

function some_global_function(arg1, arg2)
end
local slot_desc = {signal = "signal_name", fun = some_global_function, queued = true}
ogse_signals.get_mgr():subscribe(slot_desc) -- подписали в низкоприоритетную очередь
--...
ogse_signals.get_mgr():unsubscribe(slot_desc) -- отписали
вызвали сигнал
local sm = ogse_signals.get_mgr()
--...
sm.call("signal_name", arg1, arg2)

------------===< Пример для функционального объекта: >===-------------------------

class "some_luabind_class"
function some_luabind_class:__init()
  local mt = getmetatable(self)
  mt.__call = self.method_to_call
end
function some_luabind_class:method_to_call()
end

local slot_desc = {signal = "signal_name", fun = some_luabind_class()}
ogse_signals.get_mgr():subscribe(slot_desc) -- подписали в высокоприоритетную очередь
--...
ogse_signals.get_mgr():unsubscribe(slot_desc) -- отписали

Функциональный класс на таблице строится немного сложнее
local t = {}
function t:method_to_call()
end
local mt = {}
mt.__call = t.method_to_call
getmetatable(t, mt)
end

------------===< Пример для произвольного метода класса: >===----------------------

class "some_luabind_class"
function some_luabind_class:__init()
end
function some_luabind_class:method_to_call()
end

class obj = some_luabind_class()
local slot_desc = {signal = "signal_name", self = obj, fun = obj.method_to_call}
ogse_signals.get_mgr():subscribe(slot_desc) -- подписали в высокоприоритетную очередь
--...
ogse_signals.get_mgr():unsubscribe(slot_desc) -- отписали
--]=]


local mgr
function get_mgr()
  if not this.mgr then
    -- this.mgr инициализируется внутри конструтора. См. комментарии там.
    signals_mgr( "global", ogse_signals_addons_list.addons, false )
  end
  return this.mgr
end


-- таблица счётчиков незавершённых вызовов для всех менеджеров
local unfinished_count     = {}
local checking_initialized = false

class "signals_mgr"             -- менеджер сигналов
function signals_mgr:__init( name, modules_list, scan_for_autoattaching_modules )
  -- следующая строка предотвращает повторное создание экземпляра
  -- менеджера событий в том случае, когда функция get_mgr()
  -- вызывается в глобальной области одного из подписываемых модулей.
  --
  -- код в глобальной области срабатывает во время prefetch() далее в
  -- этой функции т.е., в этом случае этот вызов происходит до того,
  -- как отработает конструктор __init и тогда вариант this.mgr =
  -- this.mgr or signals_mgr() не успевает отработать, что приводит к
  -- повторному вызову конструктора.
  --
  -- Теоретически это не приводит к проблемам, поскольку экземпляров
  -- менеджера сигналов может быть несколько, но лучше от такого
  -- застраховаться.
  this.mgr      = self -- а так ссылку прописываем ещё до завершения конструктора
  self.mgr_name = name
  self.signals  = {}
  self.slots_in_process = {}
  if modules_list then -- если задали список модулей, то начинаем их подключение
    local registered_modules = {}
    if scan_for_autoattaching_modules then
      -- только если вообще подключаем модули, тогда проверяем опцию
      -- автоподключения.
      -- ищем и регистрируем все автоподключаемые плагины
      local fs    = getFS()
      local flist = fs:file_list_open_ex(
        "$game_scripts$", FS.FS_ListFiles + FS.FS_ClampExt, "ogse_*.script"
      )
      for i = 0, flist:Size() - 1 do
        local file  = flist:GetAt( i )
        local fname = file:NameFull()
        prefetch( fname )
        local module = _g[ fname ]
        if
          module and type( module ) == "table"
          and type( module.attach ) == "function" and module.auto_attach == true
        then
          self:subscribe_module( fname )
          registered_modules[ fname ] = true
        end
      end
    end
    -- регистрируем все явно подключаемые плагины
    for _, fname in ipairs( modules_list ) do
      if not registered_modules[ fname ] then
        self:subscribe_module( fname )
      end
    end
  end
  unfinished_count[ self.mgr_name ] = 0
  if not checking_initialized then -- больше одного цикла проверки не нужно
    local function hanged_calls_check()
      for mgr_name, count in pairs( unfinished_count ) do
        if count > 0 then       -- если есть незавершённые вызовы
          log3( debug.traceback() )
          local n = table.getn( self.slots_in_process )
          if n > 0 then
            local slot = self.slots_in_process[ n ]
            log3( "[%s]: signal on top: %s, script_name = %s", script_name(), slot.signal, slot.script_name )
          end
          abort( "Signal manager '"..mgr_name.."' crushed:\nOne of the calls hung! See stack dump for details." ) -- RIP
        end
      end
    end
    level.add_call( hanged_calls_check, function() end ) -- сторожевой таймер
    checking_initialized = true
  end
end


local function compare_safe( a, b )
  local function a_eq_b( a, b ) return a == b end
  local err, res = pcall( a_eq_b, a, b )
  if err then return res end
  local function a_neq_b( a, b ) return a ~= b end
  local err, res = pcall( a_neq_b, a, b )
  if err then return not res end
  abort( "compare_safe: neither == nor ~= not working for compared objects" )
end


local function slots_equal( slot1, slot2 )
  return
    rawequal( slot1.self, slot2.self )
    and rawequal( slot1.fun, slot2.fun )
end


function signals_mgr:is_already_subscribed( slot_in_question )
  local slots = self.signals[ slot_in_question.signal ]
  if not slots then return false end
  local check_slots = slot_in_question.queued
    and { slots.queue }
    or  { slots.normal, slots.scheduled }
  for _, cur in ipairs( check_slots ) do
    for _, slot in ipairs( cur ) do
      if slots_equal( slot, slot_in_question ) then
        return true
      end
    end
  end
  return false
end


function signals_mgr:subscribe( slot_to_subscribe )
  ASSERT(
    not self:is_already_subscribed( slot_to_subscribe ),
    "signals_mgr:subscribe: can't subscrabe signal '"
      .. slot_to_subscribe.signal .. "', it's already subscribed"
  )
  ASSERT(
    slot_to_subscribe.fun,
    "signals_mgr:subscribe: 'fun' is a nil reference while attempting to subscribe signal '"
      .. slot_to_subscribe.signal .. "'"
  )
  if not slot_to_subscribe.script_name then
    local d = debug.getinfo( 2, "S" )
    if d then
      slot_to_subscribe.script_name = d.source
    end
  end
  local signal = slot_to_subscribe.signal
  self.signals[ signal ] = self.signals[ signal ]
    or self:make_empty_signal( signal )
  if slot_to_subscribe.queued then
    slot_to_subscribe.timeout = 0
    table.insert( self.signals[ signal ].queue,  slot_to_subscribe )
  else
    table.insert( self.signals[ signal ].normal, slot_to_subscribe )
  end
end


function signals_mgr:make_empty_signal( signal )
  local t = {
    [ "normal" ] = {}, [ "queue" ] = {}, [ "scheduled" ] = {},
    [ "next_in_normal"    ] = 1,
    [ "next_in_queue"     ] = 1,
    [ "next_in_scheduled" ] = 1,
  }
  if
    signal == "on_update"
    or signal == "on_monster_update"
    or signal == "on_npc_update"
    or signal == "on_physic_obj_update"
    or string.find( signal, "on_monster_update.", 1, true )
    or string.find( signal, "on_npc_update.", 1, true )
    or string.find( signal, "on_ph_update.", 1, true )
  then
    t.time_limited = true
  else
    t.time_limited = false
  end
  return t
end


function signals_mgr:unsubscribe( slot_to_unsubscribe )
  ASSERT(
    self:is_already_subscribed( slot_to_unsubscribe ),
    "signals_mgr:unsubscribe: can't unsubscrabe signal '"
      .. slot_to_unsubscribe.signal
      .. "', id = " .. ( slot_to_unsubscribe.id or '' )
      .. ", which is not previously subscribed"
  )
  if unfinished_count[ self.mgr_name ] > 0 then
    -- если находимся в процессе выполнения вызова, то физически
    -- удалять слоты из очередей нельзя надо просто промаркировать их
    -- на удаление, чтобы не менять размер очереди.  в дальнейшем
    -- промаркированные на удаление слоты не будут вызываться, а при
    -- ближайшем выходе из рекурсивного цикла будут удалены физически.
    self.to_unsubscribe = self.to_unsubscribe or {}
    self.to_unsubscribe[ slot_to_unsubscribe.signal ] =
      self.to_unsubscribe[ slot_to_unsubscribe.signal ] or {}
    table.insert(
      self.to_unsubscribe[ slot_to_unsubscribe.signal ], slot_to_unsubscribe
    )
    -- маркируем его, чтобы игнорировался при вызовах
    slot_to_unsubscribe.unsubscribed = true
  else
    -- нет незавершённых вызовов, просто удаляем слот
    local qn, qc
    if slot_to_unsubscribe.queued then
      qn, qc = "queue",     "next_in_queue"
    elseif slot_to_unsubscribe.scheduled then
      qn, qc = "scheduled", "next_in_scheduled"
    else
      qn, qc = "normal",    "next_in_normal"
    end
    local slots = self.signals[ slot_to_unsubscribe.signal ]
    for i, slot in ipairs( slots[ qn ] ) do
      if slots_equal( slot, slot_to_unsubscribe ) then
        table.remove( slots[ qn ], i )
        if slots[ qc ] > i then
          slots[ qc ] = slots[ qc ] - 1
        end
        break
      end
    end
  end
end


function signals_mgr:cleanup_signal_subs( signal )
  if self.signals[ signal ] then
    self.signals[ signal ] = self:make_empty_signal( signal )
  end
end


function signals_mgr:subscribe_module( module_name )
  prefetch( module_name )
  local res, msg = check_module( module_name )
  local module = _g[ module_name ]
  ASSERT(
    module,
    "signals_mgr:subscribe_module: Failed to subscribe module '"..module_name.."'"
  )
  ASSERT(
    type( module ) == "table",
    "signals_mgr:subscribe_module: Failed to subscribe module '"
      .. module_name .. "', must be a table"
  )
  ASSERT(
    type( module.attach ) == "function",
    "signals_mgr:subscribe_module: Failed to subscribe module '"
      .. module_name .. "', has no 'attach' function"
  )
  module.attach( self )
end


function signals_mgr:call( signal_name, ... )
  local slots = self.signals[ signal_name ]
  if slots then
    unfinished_count[ self.mgr_name ] = unfinished_count[ self.mgr_name ] + 1
    self:process_call( signal_name, slots, ... )
    unfinished_count[ self.mgr_name ] = unfinished_count[ self.mgr_name ] - 1
    if self.to_unsubscribe and unfinished_count[ self.mgr_name ] == 0 then
      -- если нет незавершённых вызовов, то можно по-настоящему
      -- удалять промаркированные для отписки слоты
      for signal, slots in pairs( self.to_unsubscribe ) do
        for _, slot in ipairs( slots ) do
          self:unsubscribe( slot )
        end
      end
      self.to_unsubscribe = nil
    end
    if slots.reschedule_queue and slots.next_in_queue == 1 then
      slots.reschedule_queue = false
      if table.getn( slots.queue ) > 1 then
        table.sort(
          slots.queue, function( a, b ) return a.timeout < b.timeout end
        )
      end
    end
    if slots.reschedule_scheduled and slots.next_in_scheduled == 1 then
      slots.reschedule_scheduled = false
      if table.getn( slots.scheduled ) > 1 then
        table.sort(
          slots.scheduled, function( a, b ) return a.timeout < b.timeout end
        )
      end
    end
  end
end


function signals_mgr:process_call( signal_name, slots, ... )
  local work_time = 0
  -- сперва срабатывают все высокоприоритетные сигналы
  while slots.next_in_normal <= table.getn( slots.normal ) do
    local slot = slots.normal[ slots.next_in_normal ]
    -- при рекурсивных вызовах отписанные, но ещё не удалённые
    -- слоты, необходимо пропустить
    if slot.unsubscribed then
      slots.next_in_normal = slots.next_in_normal + 1
    else
      local result
      table.insert( self.slots_in_process, slot )
      local pt = profile_timer()
      pt:start()
      if slot.self then
        result = slot.fun( slot.self, ... )
      else
        result = slot.fun( ... )
      end
      pt:stop()
      work_time = work_time + pt:time()
      table.remove( self.slots_in_process )
      if slot.timeout then
        slots.reschedule_scheduled = true
        slot.scheduled = true
        table.insert( slots.scheduled, slot )
        table.remove( slots.normal, slots.next_in_normal )
      else
        slots.next_in_normal = slots.next_in_normal + 1
      end
      if slots.time_limited then
        if work_time >= 30000 then
          log3(
            "[%s]: signal '%s' time limited in 'normal' queue: %s. Last call spent %s, script_name = %s. Next is %s from %s.",
            script_name(), signal_name, work_time,
            pt:time(), slot.script_name,
            slots.next_in_normal, table.getn( slots.normal )
          )
          return
        end
      else
        -- вызов заявил, что он финальный в цепочке вызовов
        if result then break end
      end
    end
  end
  while slots.next_in_scheduled <= table.getn( slots.scheduled ) do
    slot = slots.scheduled[ slots.next_in_scheduled ]
    if slot.unsubscribed then
      slots.next_in_scheduled = slots.next_in_scheduled + 1
    else
      if slot.timeout > time_global() then break end
      local result
      table.insert( self.slots_in_process, slot )
      local pt = profile_timer()
      pt:start()
      if slot.self then
        result = slot.fun( slot.self, ... )
      else
        result = slot.fun( ... )
      end
      pt:stop()
      work_time = work_time + pt:time()
      table.remove( self.slots_in_process )
      slots.reschedule_scheduled = true
      slots.next_in_scheduled = slots.next_in_scheduled + 1
      if slots.time_limited and work_time >= 30000 then
        log3(
          "[%s]: signal '%s' time limited in 'scheduled' queue: %s. Last call spent %s, script_name = %s. Next is %s from %s.",
          script_name(), signal_name, work_time,
          pt:time(), slot.script_name,
          slots.next_in_scheduled, table.getn( slots.scheduled )
        )
        return
      end
    end
  end
  slots.next_in_normal    = 1
  slots.next_in_scheduled = 1
  -- затем срабатывает очередной сигнал в очереди, если имеется
  local wrapped = self:try_call_queued( slots, ... )
  if wrapped then
    -- если ничего не удалось выполнить и перешли в начало очереди
    if slots.reschedule_queue then
      -- пересортируем очередь, если нужно
      slots.reschedule_queue = false
      if table.getn( slots.queue ) > 1 then
        table.sort(
          slots.queue, function( a, b ) return a.timeout < b.timeout end
        )
      end
    end
    -- т.к. предыдущая попытка ничего не выполнила, попробуем
    -- выполнить первый обработчик. Ну, что бы этот апдейт не был
    -- холостым. Результат нам уже не важен, т.к. либо он будет
    -- выполнен, либо нам просто сейчас нечего делать.
    self:try_call_queued( slots, ... )
  end
  if work_time > 30000 then
    log3( "[%s]: signal '%s' is too slow: %s", script_name(), signal_name, work_time )
  end
end


function signals_mgr:try_call_queued( slots, ... )
  local slot    = slots.queue[ slots.next_in_queue ]
  local wrapped = false
  if slot then
    if not slot.unsubscribed then -- очень маловероятно, но на всякий случай
      if slot.timeout <= time_global() then
        slot.timeout = 0
        table.insert( self.slots_in_process, slot )
        if slot.self then
          slot.fun( slot.self, ... )
        else
          slot.fun( ... )
        end
        table.remove( self.slots_in_process )
        if slot.timeout > 0 then
          slots.reschedule_queue = true
        end
      else
        if slots.next_in_queue > 1 then
          wrapped = true
        end
        slots.next_in_queue = 1
      end
    end
    slots.next_in_queue = slots.next_in_queue + 1
    if slots.next_in_queue > table.getn( slots.queue ) then
      slots.next_in_queue = 1
    end
  end
  return wrapped
end


function signals_mgr:reschedule( timeout )
  local n = table.getn( self.slots_in_process )
  ASSERT( n > 0, "empty slots_in_process table" )
  local slot   = self.slots_in_process[ n ]
  slot.timeout = time_global() + timeout
end
