-----------------------------------------------------------------------
--- trunk_inv.script
--- Интерфейс для работы с багажником
--- OGS Evolution Team 2011
--- version 1.4
-----------------------------------------------------------------------

function attach(sm) -- для менеджера сигналов
	sm:subscribe({signal = "on_spawn",         fun = this.on_spawn})
	sm:subscribe({signal = "on_body_hide",     fun = this.on_body_hide})
	sm:subscribe({signal = "on_destroy",       fun = this.on_destroy})
	sm:subscribe({signal = "on_take_from_box", fun = this.on_take_from_box})
end

local sim

function on_spawn() -- при появлении актора проинитить используемые в будущем глобальные переменные
	--log1("trunk_inv.on_spawn")
	sim = alife()
	--log3("sim=%s", type(sim))
end
-- имеет структуру {<car_id> = {}, ...}
local registry = nil

-- ВАЖНО! Эту функцию надо вызывать не раньше, чем появятся все уже заспавленные серверные объекты
-- сейчас вызывается при первом вызове биндера любой машины. Пусть так и будет, не трогать!
local function get_registry()
--	log1("trunk_inv.get_registry")
	if not registry then
		registry = {}
		for id=1,65534 do
			local s_trunk = sim:object(id)
			if s_trunk and s_trunk:section_name() == "trunk_box" then
				local car_id = s_trunk:spawn_ini():r_u32("params", "car_id")
				registry[car_id] = s_trunk
				local scar = sim:object(car_id)
			end
		end
	end
	return registry
end

-- найти id серверной машины для онлайнового багажника
local function find_car_id_for_trunk_object(trunk)
	ASSERT(trunk, "find_car_id_for_trunk_object: trunk argument is a nil reference")
	ASSERT(trunk:is_inventory_box(), "find_car_id_for_trunk_object: trunk argument is not an inventory box, section="..trunk:section()..", name="..trunk:name()..", id="..trunk:id().." clsid="..trunk:clsid())
	local reg = get_registry()
	ASSERT(reg, "find_car_for_trunk_object: can't get trunks registry")
	if not reg then return nil end
	for car_id,s_trunk in pairs(reg) do
		if s_trunk.id == trunk:id() then
			return car_id
		end
	end
	return nil
end

local delete_reg = nil

-- найти серверную машину для онлайнового багажника
local function find_car_for_trunk_object(trunk)
	local car_id = find_car_id_for_trunk_object(trunk)
	if sim and car_id and type(car_id) == "number" then
		local sobj = sim:object(car_id)
		if sobj and get_clsid(sobj) == clsid.car_s then
			return sobj
		elseif sobj then
			delete_reg = car_id
			return nil
		else
			return nil
		end		
	end
	return nil
end
-- настроить багажник для конкретной машины:
-- если ещё не было, создать
-- если остался на другом уровне - перенести на текущий
-- эта функция вызывается из биндера машины. 
function init_trunk(car)
	local reg = get_registry()
	local car_id = car:id()
	local car_gvid = car:game_vertex_id()
	--local car_lvid = car:level_vertex_id()
	--local car_pos = car:position()
	local s_trunk = reg[car_id]
	-- В этот момент все уже созданные багажники
	-- (точнее их серверные объекты) должны уже быть и соответственно быть зарегистрированы
	-- в базе данных багажников (что произойдёт при первом вызове get_registry).
	-- Значит, если в этой базе багажника для машины нет, то его надо создать
	
	if not s_trunk then -- для этой машины ещё не создавали багажник
		s_trunk = sim:create("trunk_box", vector():add(vector():set(0,-100,0)), 0, car_gvid) -- создаём под уровнем
		reg[car_id] = s_trunk -- регистрируем в глобальном хранилище
		local params = m_net_utils.get_invbox_data(s_trunk) -- запоминаем в серверном объекте идентификатор родительской машины
		params.custom = "[params]\ncar_id = "..car:id()
		params.oflags = 65339 -- 2 + 8 + 1024
		m_net_utils.set_invbox_data(params,s_trunk)
	else  -- багажник есть,
		if object_location_id(s_trunk) ~= object_location_id(car) then -- но на другом уровне. 
			sim:teleport_object("", vector():add(vector():set(0,-100,0)), 0, car_gvid, s_trunk.id) -- переносим на один уровень с машиной
			sim:teleport_object("", vector():add(vector():set(0,-100,0)), 0, car_gvid, s_trunk.id) -- переносим на один уровень с машиной
		end
		--sim:set_switch_online(s_trunk.id, true)
		--sim:set_switch_offline(s_trunk.id, false)
	end
	return s_trunk
end
-- удалить багажник для конкретной машины (вызывается из колбека на взрыв машины)
function remove_trunk(car)
	local s_trunk = get_strunk_for_car(car)
	ASSERT(s_trunk, "remove_trunk: car '"..car:name().."' has no trunk")
	registry[car:id()] = nil
	sim:release(s_trunk, true)
end

-- Для проверки открытия багажника из других скриптов
local trunk_opened = false

function open_trunk_dialog(car)
	ASSERT(car, "open_trunk_dialog: car is nil reference")
	local car_id = car:id()
	local reg = get_registry()
	local s_trunk = reg[car_id]
	ASSERT(s_trunk, "open_trunk_dialog: car id="..car_id..", car_sec="..alife():object(car_id):section_name().." is not registred in the trunks registry")
	local c_trunk = level.object_by_id(s_trunk.id)
	--ASSERT(c_trunk, "open_trunk_dialog: there is no online trunk for the car id="..car_id)
	if c_trunk then
		db.actor:open_inventory_box(c_trunk)
		car_info_wnd = car_info_wnd or car_info()
		ASSERT(car_info_wnd, "open_trunk_dialog: car_info_wnd is a nil reference")
		car_info_wnd:show(c_trunk)
		trunk_opened = true
	else
		-- не будем здесь делать вылета. Вдруг машина стоит прямо перед нами и мы нажали до того
		-- как ящик перешёл в онлайн
		log1("there is no online trunk for the car: "..car_id)
	end
end


function trunk_is_opened()
	return trunk_opened
end

function on_body_hide()
	trunk_opened = false
	if car_info_wnd then
		car_info_wnd:hide()
	end
end
function on_destroy()
	get_hud():RemoveDialogToRender(car_info_wnd)
	car_info_wnd = nil
	collectgarbage("collect")
end

-- получение параметров из секции машины: 
--   максимальная вместительность багажника, название машины, иконка машины
function get_car_data(car_section)
	ASSERT(car_section, "get_car_data: section is not defined")
	local max_trunk_weight = get_float(car_section, "max_trunk_weight", 0.0)
	local char_icon = get_string(car_section, "character_icon")
	ASSERT(char_icon, "get_car_data: 'character_icon' parameter is not defined in section '"..car_section.."'")
	local car_name = get_string(car_section, "car_name")
	ASSERT(car_name, "get_car_data: 'car_name' parameter is not defined in section '"..car_section.."'")
	return max_trunk_weight, car_name, char_icon
end

-- биндер для спецяшика
function bind(obj)
	obj:bind_object(trunk_box_binder(obj))
end
---------------------------------------------------------------------------------------------
class "trunk_box_binder" (object_binder)
function trunk_box_binder:__init(obj) super(obj)
	self.registry = get_registry()
	ASSERT(self.registry, "trunk_box_binder:__init: can not get trunks registry")
end 

local need_delete = nil

function trunk_box_binder:net_spawn(sobject)
	if not object_binder.net_spawn(self, sobject) then
		return false
	end
	self.scar = find_car_for_trunk_object(self.object)
	if not self.scar then -- если машины для багажника нет (была удалена)
		-- надо удалить объект багажника
		for i=0,self.object:inv_box_count()-1 do
			local item = self.object:object_from_inv_box(i)
			if item then
				local obj = sim:object(item:id())
				if obj then
					sim:release(obj, true)
				end
			end
		end
		if delete_reg then
			registry[delete_reg] = nil
		end
		need_delete = self.object:id()
		return false
	end
	local maxw, name, icon = get_car_data(self.scar:section_name())
	self.max_trunk_weight = maxw
	self.object:set_callback(151, self.on_put, self)
	return true
end

--function trunk_box_binder:reload(section)
--	object_binder.reload(self, section)
--end
function trunk_box_binder:update(delta)
	object_binder.update(self, delta)
	if need_delete then
		local obj = sim:object(need_delete)
		if obj then
			log1("!!RELEASE_BOX ["..tostring(need_delete).."]")
			sim:release(obj, true)
			need_delete = nil
		end
	end
end

function trunk_box_binder:get_weight()
	local weight = 0.0
	local trunk = self.object
	for i=0,trunk:inv_box_count()-1 do
		weight = weight + trunk:object_from_inv_box(i):get_weight()
	end
	return weight
end
function trunk_box_binder:on_put(item)
	if self.scar then
		if not self.no_weight_check and self:get_weight() > self.max_trunk_weight then
			ogse.autohiding_msg(game.translate_string("trunk_is_full_string"), 1000)
			self.object:transfer_item(item, db.actor) -- пихаем обратно
		end
		self.no_weight_check = false -- сбрасываем одноразовый флажок
		if car_info_wnd then
			car_info_wnd:update_info()
		end
	else
		--abort("ERROR! 'trunk_box_binder:on_put' There is no car object fo the trunk id ["..self.object:id().."]")
	end
end
function trunk_box_binder:net_destroy()
	self.object:set_callback(151, nil)
	object_binder.net_destroy(self)
end
-- вызывается из менеджера плагинов актора
function on_take_from_box(box, item, sitem)
	if box:section() == "trunk_box" then -- если взяли из спец.ящика (который багажник)
		if car_info_wnd then -- и сейчас активно акно с информацией о машине
			car_info_wnd:update_info() -- то обновляем его
		end
	end
end

-------------------- класс окна с описанием машины ------------------------------
class "car_info" (CUIScriptWnd)

function car_info:__init() super()
	local xml = CScriptXmlInit()
	xml:ParseFile("trunk_addon.xml")
	xml:InitWindow("main", 0, self)
	local bg = xml:InitStatic("char_info", self)
	self.icon = xml:InitStatic("char_info:icon_static", bg)
	
	self.name = xml:InitStatic("char_info:name_static", bg)
	
	xml:InitStatic("char_info:health_caption", bg)
	self.health = xml:InitStatic("char_info:health_static", bg)
	
	xml:InitStatic("char_info:max_weight_caption", bg)
	self.max_weight = xml:InitStatic("char_info:max_weight_static", bg)
	
	xml:InitStatic("char_info:weight_caption", bg)
	self.weight = xml:InitStatic("char_info:weight_static", bg)
	get_hud():AddDialogToRender(self)
end
function car_info:show(trunk)
	self.bnd = trunk:binded_object()
	ASSERT(self.bnd, "car_info:show: trunk has no binder")
	local max_trunk_weight, car_name, char_icon = get_car_data(self.bnd.scar:section_name())
	--
	self.icon:InitTexture(char_icon)
	self.name:SetTextST(car_name)
	local car = level.object_by_id(self.bnd.scar.id)
	ASSERT(car, "car_info:show: No online car")
	local special_car_object = car:get_car()
	ASSERT(special_car_object, "car_info:show: Not a car")
	local health = special_car_object:GetfHealth()
	self.health:SetText(string.format("%5.1f%%", health*100.0))
	self.max_weight:SetText(string.format("%5.1f", max_trunk_weight))
	self:update_info()
	--
	self:Show(true)
end
function car_info:hide()
	self.bnd = nil
	self:Show(false)
end
function car_info:update_info()
	if self.bnd then
		self.weight:SetText(string.format("%5.1f",self.bnd:get_weight()))
	end
end
local car_info_wnd

-----------------------------------------------------------------------------------------------------------------
-- получение серверного объекта багажного ящика для машины
function get_strunk_for_car(car)
	local reg = get_registry()
	ASSERT(reg, "get_strunk_for_car: can't get trunks registry")
	local s_trunk = reg[car:id()]
	ASSERT(s_trunk, "get_strunk_for_car: car has no trunk")
	return s_trunk
end
-- получение багажного ящика для машины
function get_trunk_for_car(car)
	local s_trunk = get_strunk_for_car(car)
	local trunk = level.object_by_id(s_trunk.id)
	ASSERT(trunk, "get_trunk_for_car: trunk exists but is offline")
	return trunk
end
--QUEST
-- вызывается из:
-- tasks_functor.check_esc_spawn_box_in_car_true()
function get_available_trunk_load(car)
	local trunk = get_trunk_for_car(car)
	ASSERT(trunk, "get_available_trunk_load: trunk exists but is offline")
	local bnd = trunk:binded_object()
	ASSERT(bnd, "get_available_trunk_load: trunk has no binder")
	local max_trunk_weight, car_name, char_icon = get_car_data(bnd.scar:section_name())
	local current_weight = bnd:get_weight()
	return (max_trunk_weight - current_weight)
end


-- вызыается из
-- tasks_functor.drive_yashik_to_lager()

--car - клиентский объект машины
--obj_section - секция объекта котоый спавнит
function get_item_from_trunk_by_section(car, obj_section)
	ASSERT(car, "is_item_in_car: nil car parameter")
	local trunk = get_trunk_for_car(car)
	ASSERT(trunk, "is_item_in_car: car has no trunk")
	for i=0,trunk:inv_box_count()-1 do
		local item = trunk:object_from_inv_box(i)
		if item:section() == obj_section then
			return item
		end
	end
	return nil
end

-- вызывается из
--tasks_functor.spawn_esc_spawn_box_in_car()

--Спавн в багажник машины
--сar - клиентский объект машины
--obj_section - секция объекта котоый спавнит
--count - количество
function spawn_item_in_trunk(car, obj_section, count)
	ASSERT(car, "spawn_item_in_trunk: nil car parameter")
	local trunk = get_trunk_for_car(car)
	ASSERT(trunk, "spawn_item_in_trunk: car has no trunk")
	local act = db.actor
	local lvid, gvid, id = act:level_vertex_id(), act:game_vertex_id(), act:id()
	local item
	for i = 1, count do
		item = sim:create(obj_section, vector(), lvid, gvid, id)
		ogse_st_mgr.start_timer("TransferItemFromActorToTrunk"..i, 1, "trunk_inv.transfer_from_actor_to_trunk", item.id, trunk)
	end
end

function transfer_from_actor_to_trunk(id, trunk)
	local act = db.actor
	local item = level.object_by_id(id)
	act:transfer_item(item, trunk)
end

--[=[
function spawn_ammo_in_trunk(car, obj_section, count)
	ASSERT(car, "spawn_item_in_trunk: nil car parameter")
	local trunk = get_trunk_for_car(car)
	ASSERT(trunk, "spawn_item_in_trunk: car has no trunk")
	local lvid, gvid, id = trunk:level_vertex_id(), trunk:game_vertex_id(), trunk:id()
	ogse.spawn_ammo_in_inv(obj_section, count, trunk)
end
--]=]

function remove_item_from_trunk_by_section(car, obj_section)
	local item = get_item_from_trunk_by_section(car, obj_section)
	ASSERT(item, "[remove_item_from_trunk_by_section] no item with section '%s' in the trunk of the car '%s'", obj_section, car:name())
	local sim = alife()
	local sitem = sim:object(item:id())
	sim:release(sitem, true)
end

------------------------------------------------------------------------------------------------------------------------------------------------------------

--Получение ближайшей машины
-- вызывается из:
--tasks_functor.drive_yashik_to_lager()
--tasks_functor.spawn_esc_spawn_box_in_car()
--tasks_functor.check_esc_spawn_box_in_car_true()

-- убрана нехорошая возможность получить любую машину по отсутствии секции
-- для этого лучше сделать отдельную функцию get_any_car
-- также функция возвращает клиентский объект машины вместо id
function get_nearest_car_by_section(sect_name)
	ASSERT(sect_name, "get_nearest_car_by_section: section parameter is nil or missed")
	--if db.cars == {} then return nil end
	local nearest_car
	local dist = math.huge
	for k,car in pairs(db.cars) do
		--local car = level.object_by_id(k)
		if car and car:section() == sect_name then
			local actor_pos = db.actor:position()
			local car_pos = car:position() --car:bone_position("exhausts")
			if actor_pos:distance_to(car_pos) < dist then
				nearest_car = car
				dist = actor_pos:distance_to(car_pos)
			end
		end
	end
	return nearest_car
end

function get_car_nearby()
	local nearest_car
	local dist = 6
	for k,car in pairs(db.cars) do
		--local car = level.object_by_id(k)
		if car then
			local actor_pos = db.actor:position()
			local car_pos = car:position() --car:bone_position("exhausts")
			if actor_pos:distance_to(car_pos) < dist then
				nearest_car = car
				dist = actor_pos:distance_to(car_pos)
			end
		end
	end
	return nearest_car
end

-- вызывается из:
--tasks_functor.precond_zaz_on_level()
--tasks_functor.not_precond_zaz_on_level()

--А существует ли на нашей локации нужный нам автомобиль?
--obj_section - секция объекта котоый спавнит
-- вся эта возня с определением, что машина на том же уровне, что и актор, не имеет смысла
-- если машина в онлайне (т.е. ищем функцией level.object_by_id(k)), то она по определению
-- на том же уровне, что и актор
function is_car_on_level(car_sect)
	for k,car in pairs(db.cars) do
		--local car = level.object_by_id(k)
		if car and car:section()==car_sect and car:get_car():GetfHealth()>0.05 then
			return true
		end
	end
	return false
end


--Расстояние от машины до нпс
-- вызывается из:
--tasks_functor.precond_give_yashik_to_actor()

--function distance_between_car_and_sid(sid, section_name, dist) -- <== было так
-- но судя по вызову, функция должна называться так
function car_in_range_exist(sid, section_name, dist)
	--local npc = sid and level_object_by_sid(sid) or db.actor -- эту муть убираем, для актора лучше сделать отдельную функцию
	local npc = level_object_by_sid(sid)
	ASSERT(npc, "is_car_in_range: object not found for sid = "..sid)
	for k, car in pairs(db.cars) do
		--local car = level.object_by_id(k)
		if car and car:section() == section_name and npc:position():distance_to(car:position()) < dist then
			return true
		end
	end
	return false
end
-----------------------------------------------------------------------
--- trunk_inv.script
--- Интерфейс для работы с багажником
--- OGS Evolution Team 2011
--- version 1.3
-----------------------------------------------------------------------
