function attach(sm)
	sm:subscribe({signal = "on_spawn",        fun = this.on_spawn})
	sm:subscribe({signal = "on_update",       fun = this.on_update, queued = true}) --KRodin: ни к чему обновлять hit_from_arts на каждом апдейте
	sm:subscribe({signal = "on_update",       fun = this.on_update_lp, queued = true})
	sm:subscribe({signal = "on_drop",         fun = this.on_item_drop})
	sm:subscribe({signal = "on_item_to_slot", fun = this.on_item_to_slot})
	sm:subscribe({signal = "on_item_to_belt", fun = this.on_item_to_belt})
	sm:subscribe({signal = "on_item_to_ruck", fun = this.on_item_to_ruck})
end

-- ключ - секция предмета на поясе, значение - количество предметов с такой секцией
-- при количестве 0 - из таблицы удаляется
belt = {}
local belt_ids = {} -- нужен только внутри модуля

local single_items = {
	["autodoctor"] = true,
}

function on_item_to_belt(item, sitem)
	local sect = item:section()
	--log3("on_item_to_belt: %s", sect)
	-- если предмет должен быть на поясе в единственном числе, то вертаем его в рюкзак и на этом заканчиваем
	local cur_cnt = belt[sect] or 0
	if single_items[sect] and cur_cnt > 0 then
		db.actor:move_to_ruck(item)
		return true
	end
	belt[sect] = cur_cnt + 1 -- увеличиваем счётчик или просто пишём единицу, если такой секции там ещё не было
	belt_ids[item:id()] = true
end
-- служебная функция для обновления пояса при потенциальном снятии оттуда предмета
local function belt_items_dec(item)
	local id = item:id()
	if belt_ids[id] then
		belt_ids[id] = nil
		local sect = item:section()
		belt[sect] = belt[sect] - 1
		if belt[sect] == 0 then
			belt[sect] = nil
		end
	end
end
-- при перекладывании с пояса в слот
function on_item_to_slot(item, sitem)
	-- принудительное убийство актора в случае перекидывания артефакта с пояса в слот
	-- такая ситуация при дальнейшей игре в любой случае чревата неизлечимыми глюками
	if item:is_artefact() then
		for i,k in pairs(belt_ids) do
			if i == item:id() then
				-- log1("Too bad - actor weared art from belt... bad idea... bye-bye actor 8(")
				alife():release(sitem, true)
				db.actor:kill(db.actor)
				db.actor:give_game_news(game.translate_string("inventory_art_hand_belt_text"), "ui\\ui_iconsTotal", Frect():set(0,188,83,47), 0, 10000)
				return true
			end
		end	
	end
	--
	belt_items_dec(item)
end
-- при перекладывании с пояса в рюкзак
function on_item_to_ruck(item, sitem)
	belt_items_dec(item)
end
-- если выкидываем прямо с пояса
function on_item_drop(item, sitem)
	belt_items_dec(item)
end

local make_hits = false
-- служебный таймер, считающий 300 апдейтов до срабатывания
class "count300" (ogse_qt.quick_timer)
function count300:__init() super()
	self.count = 0
end
function count300:condition()
	self.count = self.count + 1
	return self.count > 300
end
function count300:action()
	make_hits = true
end

function on_spawn()
	count300():start()
end
function on_update()
	if make_hits then
		hit_from_arts()
	end
end

function on_update_lp()
	spoilage_food()
end

local warning_last = nil

local dbg = false

-- Список ограничений по типам для иммунитетов, даваемых артефактами, в процентах
local immunities_data = {
	burn_immunity          = {min=80, max=99, hit_type=0, d_type="fire"},
	strike_immunity        = {min=80, max=99, hit_type=1, d_type="strike"},
	shock_immunity         = {min=80, max=99, hit_type=2, d_type="shock"},
	wound_immunity         = {min=80, max=99, hit_type=3, d_type="wound"},
	radiation_immunity     = {min=80, max=99, hit_type=4, d_type="radiation"},
	telepatic_immunity     = {min=80, max=99, hit_type=5, d_type="telepatic"},
	chemical_burn_immunity = {min=80, max=99, hit_type=6, d_type="chemical"},
	explosion_immunity     = {min=80, max=99, hit_type=7, d_type="explosive"},
	fire_wound_immunity    = {min=80, max=99, hit_type=8, d_type="fire_wound"},
}

local art_hit_koef = 0.02	-- Коэффициент хита, наносимого актору при превышении ограничения по иммунитету от артефактов

-- Нанесение хита актору при превышении ограничения по иммунитетам, получаемым от артефактов
local hit_from_arts_meter_time = time_global() + 100
function hit_from_arts()
	--log1("hit_from_arts")
	local uptime = time_global()
	if uptime < hit_from_arts_meter_time then return end
	hit_from_arts_meter_time = uptime + 100

	local immunities = {
		burn_immunity = 0,
		strike_immunity = 0,
		shock_immunity = 0,
		wound_immunity = 0,
		radiation_immunity = 0,
		telepatic_immunity = 0,
		chemical_burn_immunity = 0,
		explosion_immunity = 0,
		fire_wound_immunity  = 0,
	}

	for section, obj_num in pairs(belt) do
		if string.find(section, "af_") and section ~= "af_maska" then
-- -- log1("Найден артефакт: " .. section .. ", " .. obj_num .. " штук.")
			if sys_ini:section_exist(section) then
				if sys_ini:line_exist(section, "hit_absorbation_sect") then
					local obj_hit_absorbation_sect = sys_ini:r_string(section, "hit_absorbation_sect")
					if sys_ini:section_exist(obj_hit_absorbation_sect) then
-- -- log1("Его секция иммунитетов: " .. obj_hit_absorbation_sect)
						for immunity, value in pairs(immunities) do
							if sys_ini:line_exist(obj_hit_absorbation_sect, immunity) then
								local tmp_immunity = sys_ini:r_string(obj_hit_absorbation_sect, immunity)
								tmp_immunity = (1-tmp_immunity)*100
								immunities[immunity] = immunities[immunity] + (tmp_immunity*obj_num)
							end
						end
					end
				end
			end
		end
	end
	--print_table_inlog(immunities, "immunities")
	for immunity, immunity_value in pairs(immunities) do
		local immunity_data = immunities_data[immunity]
		if immunity_value > immunity_data.min then
			local burn_hit = immunity_value - immunity_data.min
			local art_hit = hit()
			local d_type = immunity_data.d_type
			art_hit.direction = vector():set(0,0,0)
			art_hit.impulse = 0
			art_hit.draftsman = db.actor
			art_hit.power = burn_hit*art_hit_koef
			art_hit.type = immunity_data.hit_type
			db.actor:hit(art_hit)
	-- -- log1("Наносим хит: " .. art_hit.type .. art_hit.power)
			if not has_alife_info("hit_from_arts_story") then
				db.actor:give_info_portion("hit_from_arts_story")
			end
			if (not warning_last or warning_last ~= d_type) and not immunity_data.warning_given then
				news_text = string.format(game.translate_string("inventory_art_warning_pattern_text"), game.translate_string("inventory_"..d_type.."_protect_text"), tostring(immunity_data.min), game.translate_string("inventory_"..d_type.."_protect_effect_text"))
				db.actor:give_game_news(news_text, "ui\\ui_iconsTotal", Frect():set(0,188,83,47), 0, 10000)
				warning_last = d_type	
				immunity_data.warning_given = true
			end
			if immunity_value > immunity_data.max then
				art_hit.type = random_hit_type_select(immunity_data.hit_type)
				db.actor:hit(art_hit)
	-- -- log1("Наносим хит: " .. art_hit.type .. art_hit.power)
			end

		end
	end
end

-- Выбор случайного типа хита
function random_hit_type_select(ignore_type)

	local hit_type = {0,	-- burn
					1,		-- shock
					2,		-- strike
					3,		-- wound
					4,		-- radiation
					5,		-- telepatic
					6,		-- chemical_burn
					7,		-- explosion
					8}		-- fire_wound

	if ignore_type ~= nil then
		for i,v in pairs(hit_type) do
			if v == ignore_type then
				table.remove(hit_type, i)
			end
		end
	end

	return  hit_type[math.random(table.getn(hit_type))]
end

local food_spoilage_db = {
	["salo"]      = 0.2,
	["kolbasa"]   = 0.2,
	["kefir"]     = 0.2,
	["bread"]     = 0.4,
	["kartoshka"] = 0.4,
	["conserva2"] = 0.4,
	["syrok"]     = 0.6,
	["conserva"]  = 0.6,
	["irp-b"]     = 0.8,
}
-- Порча еды
function spoilage_food()
	if level.main_input_receiver() then return end
	local spoiled_items = {}
	db.actor:inventory_for_each(function(item, npc)
		if db.actor:is_in_ruck(item) then
			local sec = item:section()
			if food_spoilage_db[sec] and db.actor.radiation > food_spoilage_db[sec] then
				table.insert(spoiled_items, item)
			end
		end
	end)
	local ids = {}
	for _,item in pairs(spoiled_items) do
		local bad_sec = item:section().."_bad"
		ogse.remove_item(item)  
		ogse.spawn_item_in_inv(bad_sec)
		table.insert(ids, item:id())
	end
	if #ids > 0 then 
		ogse_addons.wait_for_deleted_objects_to_disappear(ids):start()
	end
end
