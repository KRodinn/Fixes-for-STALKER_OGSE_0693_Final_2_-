--[[------------------------------------------------------------------------------------------------------------------
Smart Terrain (механизм, организовывающий всех сталкеров и некоторых монстров в сцены)
Чугай Александр
!без симуляции не работает!
--------------------------------------------------------------------------------------------------------------------]]

local check_period

if not editor() then
	check_period = game.CTime()
	check_period:setHMS( 0, 0, 50 ) -- 50 игровых секунд

	CTime_0 = game.CTime()
end

local monster_classes

local disagreed, agreed, agreed_exclusive = 0, 1, 2

local smart_section = "smart_terrains"

local smart_terrains = {}
--[[ список всех серверных объектов смартов, которые зарегистрированы в симуляторе
Формат:
	smart_terrains = {
		level_name = { id=obj, id=obj, ... },
		level_name = { id=obj, id=obj, ... },
		...
	}
]]

exclusives = {}
--[[ увеличивается на 1 в каждом se_monster.se_monster:fill_exclusives() и se_stalker.se_stalker:fill_exclusives()
Формат:
	exclusives = {
		smart_name1 = <number of ?available? exclusive positions in smart_name1>,
		smart_name2 = <number of ?available? exclusive positions in smart_name2>,
		...
	}
]]


----------------------------------------------------------------------------------------------------------------------
-- Класс "se_smart_terrain". Обеспечивает поддержку smart terrain в ОФЛАЙНЕ.
-- Унаследован от скриптовой зоны.
----------------------------------------------------------------------------------------------------------------------
class "se_smart_terrain" ( cse_alife_smart_zone )

function se_smart_terrain:__init( section ) super( section )
--	log1( "se_smart_terrain::se_smart_terrain called!" )

	self.registred = false
	self.duration_end = game.CTime() -- убрать
	self.idle_end     = game.CTime() -- убрать
end

-- использовалась в вырезанном оффлайновом комбате
function se_smart_terrain:detect_probability()
--	log1( "se_smart_terrain::detect_probability called!" )
	return 0
end

function se_smart_terrain:print()
	log1( "NPCs:" )
	if self.npc_info then
		for id, v in pairs( self.npc_info ) do
			log3( "    %d %s", id, tostring(v.name) )
		end
	end
end

-- сохранение
function se_smart_terrain:STATE_Write( packet )
--	log1( "se_smart_terrain::STATE_Write called!" )
	cse_alife_smart_zone.STATE_Write( self, packet )

--	self:print()

	utils.w_CTime( packet, self.duration_end ) -- убрать
	utils.w_CTime( packet, self.idle_end ) -- убрать

	if self.gulag_working then
		packet:w_bool( true )

		self.gulag:save_common( packet )

		local n = 0

		for id, v in pairs( self.npc_info ) do
			n = n + 1
		end

		packet:w_u8( n )

		for id, v in pairs( self.npc_info ) do
			packet:w_u16  ( id )
			packet:w_u8   ( v.o_group )
			packet:w_u8   ( v.o_squad )
			packet:w_bool ( v.exclusive )
			utils.w_CTime ( packet, v.stay_end )

			self.gulag:save_obj( packet, id )
		end

		packet:w_bool ( self.population_locked )
	else
		packet:w_bool( false )
	end
end

-- восстановление
function se_smart_terrain:STATE_Read( packet, size )
--	log1( "se_smart_terrain::STATE_Read called!" )
	cse_alife_smart_zone.STATE_Read( self, packet, size )

--	log1( "before read_params" )
--	self:print()
	
	self:read_params()

	-- под LevelEditor не пытаться читать из пакета ничего
	if editor() then
		return
	end

--	log3( "name=%s, script_version=%d", self:name(), self.script_version )

	self.duration_end = utils.r_CTime( packet ) -- убрать
	self.idle_end     = utils.r_CTime( packet ) -- убрать

	self.gulag_working = packet:r_bool()

	-- если есть работающий гулаг
	if self.gulag_working then
		self.check_time = CTime_0

		self.gulag:load_common( packet )

		local n = packet:r_u8()
		local o_id, o

--		log3( "npc_info=%s", tostring( n ) )

		for i = 1, n do
			o_id = packet:r_u16()
			self.npc_info[o_id] = {}
			o = self.npc_info[o_id]

			o.o_group   = packet:r_u8()
			o.o_squad   = packet:r_u8()
			o.exclusive = packet:r_bool()
			o.stay_end  = utils.r_CTime( packet )

			self.gulag:load_obj( packet, o_id )
		end

		self.population_locked = packet:r_bool()
	end

--	log3( "after read [%s]", self:name())
--	self:print()
end

-- инициализировать работу смарт террейна.
-- после этой функции смарт ПОЛНОСТЬЮ работоспособен.
-- вызывается из всех мест, которые могут вызвать другие объекты:
--   se_smart_terrain:enabled()
--   se_smart_terrain:update()
--   xr_gulag.setup_gulag_and_logic_on_spawn()
--   xr_gulag.get_npc_gulag()
--   xr_gulag.get_gulag_by_name()
--   xr_gulag.get_gulag_by_sid()

function se_smart_terrain:initialize_if_needed()
	if not self.initialized then
		sim_statistic.update()

		self:get_se_objs()

		self:preserve_exclusives()

		self.initialized = true
	end
end

-- зарезервировать места для эксклюзивных персонажей
-- выполняется строго один раз как часть initialize_if_needed
function se_smart_terrain:preserve_exclusives()
	local e = exclusives[self:name()]

	if e then
--'	log3( "[smart_terrain %s] exclusives=%d", self:name(), e )

	self.exclusives = e
--'	log3("[smart_terrain %s] preserve_exclusives [%s]", self:name(), tostring(self.gulag.capacity_non_exclusive))
		self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - e

		exclusives[self:name()] = nil
	else
		self.exclusives = 0
	end
end

-- получить серверные объекты персонажей
-- выполняется строго один раз как часть initialize_if_needed
function se_smart_terrain:get_se_objs()
  local sim = alife()
  local del = {}
  for id, v in pairs( self.npc_info ) do
    local obj = sim:object( id )
    if obj then
	  sim_statistic.add( obj )
      self:fill_npc_info( obj, v )
    else
      log2(
        "[smart_terrain %s] can't get server object id=%d", self:name(), id
      )
      table.insert( del, id )
    end
  end
  for _, id in ipairs( del ) do
    self.npc_info[ id ] = nil
    self.gulag:removeObject( id )
  end
end

-- заполнить информацию о персонаже
-- у монстров нету метода profile_name()
-- TODO передавать в предикаты не npc_info, а объект
function se_smart_terrain:fill_npc_info( obj, npc_info )
	if not npc_info then
		npc_info = {}
	end

	npc_info.se_obj       = obj

	npc_info.class_id     = obj:clsid()
	npc_info.section_name = obj:section_name()
	npc_info.name         = obj:name()
	npc_info.story_id     = obj.m_story_id
	npc_info.community    = self:get_obj_community( obj )
	npc_info.profile_name = obj.profile_name and obj:profile_name()
	npc_info.rank         = obj:rank()

	npc_info.group        = obj:g_group()
	npc_info.squad        = obj:g_squad()
	npc_info.team         = obj:g_team()

	if npc_info.profile_name then
		npc_info.is_sniper = string.find( npc_info.profile_name, "sniper" ) ~= nil
	end
	npc_info.is_sniper_name = string.find( npc_info.name, "sniper" ) ~= nil

	local t               = obj.smart_terrain_conditions
	if t then
		t = t[self:name()]
	end

	npc_info.cond         = t
	return npc_info
end

-- возвращает:
-- а) если сталкер: группировку сталкера и true
-- б) если монстр:  вид монстра и false
-- TODO: заменить на глобальный функционал
function se_smart_terrain:get_obj_community( obj )
	local cls = obj:clsid()

	if cls == clsid.script_stalker then
		return obj:community(), true
	else
		return monster_classes[cls], false
	end
end

-- инициализация.
-- чтение custom data.
-- вызывается строго один раз как часть STATE_Read
function se_smart_terrain:read_params()
	local ini  = self:spawn_ini()
	local sect = "smart_terrain"

	if not ini:section_exist( sect ) then
		sect = "gulag1"

		if not ini:section_exist( sect ) then
			--log3( "[smart_terrain %s] no configuration!", self:name() )
			self.disabled = true
			return
		end
	end

	ASSERT(ini:line_exist( sect, "type" ), "[smart_terrain %s] type is not specified", self:name() )

	local gp       = {}

	self.npc_info  = {}          -- group и squad для каждого npc
	self.gparams   = gp          -- настройки гулага

	gp.type        = get_string( sect, "type",   nil, ini )
	gp.preset_name = get_string( sect, "preset", nil, ini )
--'	log3("%s read_params preset name [%s]", self:name(), tostring(gp.preset_name))
	gp.capacity    = get_float( sect, "capacity", 100, ini ) -- ёмкость. а настоящая ёмкость = min(эта_ёмкость, ёмкость гулага)
	gp.squad       = get_float( sect, "squad", nil, ini )
	gp.respawn = get_string( sect, "respawn", nil, ini )

	local cond_str = get_string( sect, "cond",    nil, ini )
	if cond_str then
		gp.cond = xr_logic.parse_condlist( nil, sect, "cond", cond_str)
	end

	local groups_str = get_string( sect, "groups",  nil, ini )
	if groups_str then
		gp.groups = parse_nums(groups_str)
	end

	local s_comm = get_string( sect, "communities", nil, ini )
	if s_comm then
		local t = parse_names( s_comm )

		for i, v in ipairs( t ) do
			self.accepted_communities = self.accepted_communities or {}
			self.accepted_communities[v] = true
		end
	end

	self.rank_inc_min = get_u32( "smart_terrain_rank_change", "min" )
	self.rank_inc_max = get_u32( "smart_terrain_rank_change", "max" )

	self.population_locked = false

	self.gulag = xr_gulag.gulag( self, self.gparams.type, self.gparams.squad, self.gparams.groups, self.npc_info, self.gparams.capacity )

	self.gulag_working = false
end

-- таблица level_groups задаёт что-то вроде карты, где локации сгруппированы в области.
-- Неписи пойдут в смарт с другого уровня, только если этот уровень находится в одной группе со смартом.
-- Вероятно, надо глянуть на карту и убедиться, что эти группы заданы осмысленно.
-- как минимум, группы должны обеспечивать связность графа в пределах локаций одной группы, и также
-- надо согласовывать место спавна неписей и группы, иначе заспавненные неписи не смогут 
-- попасть в свой смарт. 
-- если локация не прописана в этой таблице, то она будет автоматически изолирована.
local level_groups = {
    l01_escape = "group1",
    l02_garbage = "group1",
    l03_agroprom = "group1",
    l03u_agr_underground = "group1",
    l04_darkvalley = "group1",
    l04u_labx18 = "group1",
    l05_bar = "group1",
    l06_rostok = "group1",
    l07_military = "group1",
    l08_yantar = "group1",
    l08u_brainlab = "group1",
    l10_radar = "group1",
    l10u_bunker = "group1",
    l11_pripyat = "group1",
    l12_stancia = "group3",
    l12u_sarcofag = "group3",
    l12u_control_monolith = "group3",
    l12_stancia_2 = "group3",
	l09_deadcity_ogse = "group1",
	l13_generators_ogse = "group3",
	k01_darkscape_ogse = "group1",
	l22_marsh = "group1",
	l23_x9 = "group3"
}

function is_same_level_group( l1, l2 )
  local g1 = level_groups[ l1 ] or l1
  local g2 = level_groups[ l2 ] or l2
  return g1 == g2
end

--[[
Подходит ли объект гулагу?
1) если объект не согласен сюда идти, то smart terrain его не возьмёт
2) если объект согласен идти куда угодно, то проверить, есть ли ещё места, подходит ли он гулагу,
   подходит ли он хоть на одну работу
3) если объект согласен идти только в этот смарт, то принимаем даже если нету места (он вытеснит кого-то), проверить,
   подходит ли он гулагу, подходит ли он хоть на одну работу
------------
Второй аргумент - результат работы функии obj_accepts_smart_terrain - тип согласия объекта на
вступление в этот смарт.
Вызывается как часть enabled
]]
function se_smart_terrain:smart_terrain_accepts_obj( obj, obj_agreement )
	if obj_agreement == disagreed then -- объект в этот смарт идти не хочет
--		log3("[%s] disagreed", obj:name())
		return false
	end

	if xr_companion.is_companion(obj.id) then -- это компаньон, нечего ему в смарте делать
		return false
	end	

	-- в любом случае, если хочет идти только в этот, или если готов без условий и при этом гулаг не заполнен полностью
	if obj_agreement == agreed_exclusive or 
		self.gulag:get_non_exclusive_population() < self.gulag.capacity_non_exclusive
	then
		local community, is_stalker = self:get_obj_community( obj )

		if not community then return false end -- фантомов не принимаем никуда
		if not obj:alive() then return false end -- мертвых не принимаем тоже

        --' Проверка что смарттеррейн и НПС находятся в одном кластере уровней (чтобы не ходили через БАР)
		local npc_level_name = ""
		if game_graph():valid_vertex_id( obj.m_game_vertex_id ) then
			npc_level_name = object_level_name(obj)
		end
		if not is_same_level_group( object_level_name(self), npc_level_name ) then
            return false -- с этого уровня в этот смарт идти нельзя
        end
		-- если в кастомдате смарта есть перечень допустимых группировок
		-- и непись не попадает в эту группировку
		if self.accepted_communities and not self.accepted_communities[community] then
			return false -- то не подходит
		end
		-- выполнить проверку, заданную скриптом для конкретного уровня (обычно соответствие типа гулага и параметров непися)
		if not xr_gulag.checkNpc( community, is_stalker, self.gparams.type, obj:rank(), obj ) then
			return false
		end
		-- если есть работа
		return self.gulag:is_there_any_suitable_job( self:fill_npc_info( obj ), obj_agreement == agreed_exclusive )
	else
		return false -- если не эксклюзив для этого смарта и места нет, то не подходит
	end
end

--[[ подходит ли гулаг объекту?
у объекта в custom data прописаны условия для некоторых smart_terrains:
	<smart_terrain_name1> = <condlist1>
	<smart_terrain_name2> = <condlist2>
	...
Если для какого-то smart_terrain условие выполнилось, он называется эксклюзивным.
Если у объекта появился хоть один эксклюзивный smart terrain, то он будет согласен идти только в него.
Если не появилось ни одного эксклюзивного, то он согласен идти в любой.
Функция возвращает одно из трёх значений:
disagreed        - в этот не идёт
agreed_exclusive - идёт только в этот
agreed           - согласен идти в этот на неэкслюзивной основе
]]
-- TODO а если в начале эксклюзивный, а потом в любой?
-- вариант: any=condlist

function se_smart_terrain:obj_accepts_smart_terrain( obj )

	if xr_companion.is_companion(obj.id) then -- это компаньон, нечего ему в смарте делать
		return disagreed
	end	

	if obj.smart_terrain_conditions then -- если вообще есть какие-то специальные условия насчёт смартов
		-- перебираем все варианты условий из секции непися
		-- TODO: зачем перебирать условия для всех смартов, если можно по ключу выбрать только
		-- условие для этого?
		--log3("~~\nSmart_terrain_conditions for object [%s]: %s", obj:name(), obj.smart_terrain_conditions)
		if xr_logic.pick_section_from_condlist( db.actor_proxy, obj, obj.smart_terrain_conditions["none"]) then
			return disagreed -- явно прописано, что не идёт ни в какой смарт
		else
			local condlist = obj.smart_terrain_conditions[self:name()]
			if condlist then -- есть условие для этого смарта
				if xr_logic.pick_section_from_condlist( db.actor_proxy, obj, condlist ) then
					return agreed_exclusive -- идёт только в этот смарт
				end
			end
		end
		return disagreed -- в этот не идёт
	end
	-- здесь имеем: эксклюзивов нет, явного запрета тоже нет
	--
	--' Если объекту запрещено переходить в online и эксклюзивные
	--' смарты недоступны, то не пускаем его никуда. Это исключает
	--' переброску отключенных до (или после) определённого события
	--' людей и мутантов в другой неэксклюзивный смарт.
	--
	----if not obj:can_switch_online() then return disagreed end --старая проверка
	if
		obj.spawner
		and xr_logic.pick_section_from_condlist( db.actor, obj, obj.spawner ) == nil
	then
		return disagreed
	end

	return agreed -- просто согласен идти в этот смарт без обязаловки
end

local team_smtr_assigned = {}

-- может ли объект быть добавлен в smart terrain?
-- вызывается симулятором при поиске задания для объекта/группы.
-- если объект - группа, то вернёт true только если все объекты в группе вернут true
function se_smart_terrain:enabled(obj)
	-- DEBUG
	if self.disabled then
--		log3("[smart_terrain %s] DISABLED obj=%s (self.disabled)", self:name(), obj:name())
		return false
	end
	--// xr_companion
	if xr_companion.is_companion(obj.id) then
		return false
	end	
	--// xr_companion	

	-- если всё это делаем в первый раз
	self:register_if_needed() -- проинитим ...вообще-то это должно с гарантией происходить при создании смарта движком,
	self:initialize_if_needed() -- но на всякий случай...

	-- если гулаг активен (по cond_list из кастомдаты смарта) и не заблокировано добавление персонажей
	if self:is_gulag_available() then
		local b = self:obj_accepts_smart_terrain( obj ) -- если смарт подходит неписю
		if self.population_locked then
			return b == agreed_exclusive -- если гулаг заблокирован, то принимать только экслюзивных неписей
		else
			local a = self:smart_terrain_accepts_obj( obj, b ) -- и непись подходит смарту
			return a
		end
	else
		return false
	end
end

-- возвращает меру подходящести персонажа смарттерейну.
-- вызывается для всех смарттерейнов, которые вернули true из enabled
-- для того, чтобы выбрать тот единственный, в который персонаж всё-таки пойдёт.
-- критерии:
--   1) если объект уже бывал в других смартах, то чем больше свободных работ на уровне этого смарта, тем лучше
--   2) иначе ближе - лучше
-- TODO Оптимизировать
-- на основе это функции принимается решение для непися (не смарта), т.е. здесь непись выбирает себе смарт
-- для какого смарта число больше, туда и пойдёт
function se_smart_terrain:suitable( obj )
	if xr_companion.is_companion(obj.id) then -- это компаньон, нечего ему в смарте делать
		return 0
	end		
	--' Повысить подходящесть эксклюзивного смарттеррейна
	if self:obj_accepts_smart_terrain(obj) == agreed_exclusive then -- некрасиво, уже ведь проверяли, а фунция некислая
		-- TODO: оптимизировать
		--v = 100000 --'Так чтобы все эксклюзивные были заведомо лучше
		return 100000 -- сразу возвращаем, зачем ещё что-то проверять, если это заведомо больше всех
	end

  local k = 1                  -- коэффициент привлекательности смарта
  local self_lname = object_level_name( self )
  if object_level_name( obj ) ~= self_lname then
    -- смарт на другой локации будет привлекательнее смарта на текущей
    -- локации непися. Полагаю, это приведет к большей движухе.
    k = 10 + math.random( 0, 10 )
  end

  local v = 0        -- посчитаем доступное на уровне количество работ
  -- перебираем все гулаги на одном уровне с этим
  for id, strn in pairs( smart_terrains[ self_lname ] ) do
    if strn:is_gulag_available() then -- если они доступны
      -- то суммируем их вакансии
      v = v + strn.gulag.capacity - strn.gulag:get_population()
    end
  end
  -- непонятен критерий! Получается, неэксклюзивный непись почти
  -- всегда пойдёт на уровень с тупо большим числом смартов, а уровни
  -- с небольшим количеством смартов заселятся в последнюю очередь.
  -- надо подумать над критерием.  Кроме того, непонятно, где
  -- прописывается ограничение по рангу/силе монстров. Может это
  -- сделать здесь?
  return v * k -- возвращаем фактически число вакансий на уровне
end

------------ добавить npc в smart terrain.
-- после того, как движок с помощью suitable выбрал подходяший смарт, он регистрирует непися в нём
-- с помощью этой функции:
-- если места нету или нету свободных подходящих работ, то
-- вытолкнуть из этого smart terrain с подходящей работы объект, который попал в него не эксклюзивно.
function se_smart_terrain:register_npc( obj )

	--log3( "[smart_terrain %s] register called obj=%s gulag_type=%s", self:name(), obj:name(), self.gparams.type )

	local npc_info = {
		-- старые squad и group
		o_group        = obj:g_group(),
		o_squad        = obj:g_squad(),
		-- опять вызыываем эту функцию, хотя вроде бы это уже два раза сделали только что TODO: оптимизировать
		exclusive      = self:obj_accepts_smart_terrain( obj ) == agreed_exclusive, 

		stay_end       = game.CTime()
	}

	self:fill_npc_info( obj, npc_info )

	if self.gulag_working and -- если гулаг активен, т.е. содержит неписей
--	   ( self.gulag:get_population() == self.gulag.capacity or
	   not self.gulag:is_there_any_suitable_job( npc_info, false ) --) и нет неэксклюзивных работ
	   -- а не надо ли проверить на эксклюзивность персонажа?
	then
		--log3( "get_population=%d capacity=%d", self.gulag:get_population(), self.gulag.capacity )
		--log3( "is_there_any_suitable_job=%s", tostring(self.gulag:is_there_any_suitable_job(npc_info, false)) )
		--log1( table.tostring(self.npc_info) )
		self:kick_someone_non_exclusive( npc_info ) -- кого-то выкидываем
	end

	self:update_obj_rank( obj )

	obj.was_in_smart_terrain = true

	self.npc_info[obj.id] = npc_info

	if not self.gulag_working then -- если там ещё нет объектов
		self:create_gulag() -- активировали гулаг
	end

	self.gulag:addObject( obj.id ) -- таки добавили объект

	sim_statistic.add( obj )

	self.gulag:update() -- обновили

--	log3( "[smart_terrain %s] added %s to gulag type=%s", self:name(), obj:name(), self.gparams.type )
end

-- отпустить npc
-- TODO а если такого объекта уже нету?
function se_smart_terrain:unregister_npc( obj )
	--' Если анрегистрим мертвого эксклюзивного НПС, нужно уменьшить счетчик эксклюзивности
	if obj.smart_terrain_conditions then
		local condlist = obj.smart_terrain_conditions[self:name()]
		if condlist and xr_logic.pick_section_from_condlist( db.actor_proxy, obj, condlist ) then
			self.exclusives = self.exclusives - 1 --' уменьшаем счетчик
			self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive + 1
		end
	end

	local n = self.npc_info[obj.id]
	--if not n then
	--	log3( "self.npc_info[obj.id] = nil !!! obj.id=%d", obj.id )
	--	self:print()
	--	self.gulag:print()
	--end

	self.gulag:removeObject( obj.id )

	obj.squad = n.o_squad
	obj.group = n.o_group

	self.npc_info[obj.id] = nil

	obj:clear_smart_terrain()

	sim_statistic.remove( obj )

--'	if sim_statistic.show_stalker_spot == true and obj:alive() then
--'		local community, rank = sim_statistic.getNpcType(obj)
--'		local spot = "alife_presentation_monstr"
--'		if IsStalker(obj) then
--'			spot = "alife_presentation_"..community
--'		end
--'		local str = obj:name().." "..self:name().."\\n".."<<removed>>"
--'		level.map_change_spot_hint(obj.id, spot, str)		
--'	end

--	log3( "[smart_terrain %s] removed %s from gulag type=%s, strn_id=%s", self:name(), obj:name() or "<<<nil>>>", self.gparams.type, obj:smart_terrain_id())
end

-- увеличить ранг сталкера при регистрации в смарте
function se_smart_terrain:update_obj_rank( obj )
	local community, is_stalker = self:get_obj_community( obj )

	if is_stalker then
		local old_rank = obj:rank()

		obj:set_rank( old_rank + math.random( self.rank_inc_min, self.rank_inc_max ) )

--		log3( "[smart_terrain %s] obj=%s rank %d -> %d", self:name(), obj:name(), old_rank, obj:rank() )
	end
end

-- выгнать из-под смарттеррейна первого попавшегося неэксклюзивного персонажа,
-- который занимает работу, подходящую новому персонажу.
-- TODO а если я выгоню кого-то, а его работа не подойдёт по idle ?
function se_smart_terrain:kick_someone_non_exclusive( new_npc_info )
	for obj_id, npc_info in pairs( self.npc_info ) do
		if not npc_info.exclusive and self.gulag:obj1_job_suits_obj2( obj_id, new_npc_info ) then
			--log3("[smart_terrain %s] kicking %s", self:name(), npc_info.name)
			self:unregister_npc( npc_info.se_obj )
			return
		end
	end

	abort( "[smart_terrain %s] can't add npc, all are exclusive or there are no suitable jobs", self:name() )
end


function se_smart_terrain:reset_npc_logic(obj)
	if obj then
		local npc = level.object_by_id(obj.id)
		local npc_id = obj.id
		if npc then
			xr_logic.reset_generic_schemes_on_scheme_switch(npc, "nil", "nil")
		end
		if db.storage[npc_id] then
			db.storage[npc_id].overrides = nil
			db.storage[npc_id].active_section = nil
			db.storage[npc_id].active_scheme = nil	
		end
	end
end
-- выдать объекту задание.
-- вызывается движком после включения непися в состав смарта
-- задание в оффлайне заключается попросту топать к смарту, где непись 
-- выйдет в онлайн и будет подхвачен уже логикой гулага
function se_smart_terrain:task( obj )

	--// xr_companion
		if xr_companion.is_companion(obj.id) then -- и как он здесь оказался?
			self:unregister_npc(obj)
			return CALifeSmartTerrainTask("simulation_default_path")
		end
	--// xr_companion
  
  	local path_name = self.gulag:get_obj_job_path_name( obj.id )
	if not path_name then
		log1("!!WARNING: NO PATH ["..obj.id.."] ["..obj:name().."] ["..self:name().."] PATH ["..tostring(path_name).."]")
		--log3("[smart_terrain %s] task: obj=%s job_path=nil, CLEARING", self:name(), obj:name() )
		self.gulag:free_obj( obj.id )
		self:unregister_npc(obj) --'Затычка против вылета.
		self:reset_npc_logic(obj)
		return CALifeSmartTerrainTask("simulation_default_path")
	end

--'	log3("SEETING TASK PATH %s = %s", obj:name(), path_name)
	--' Пробуем проапдейтить типс чувака на карте
--'	if sim_statistic.show_stalker_spot == true and obj:alive() then
--'		local community, rank = sim_statistic.getNpcType(obj)
--'		local spot = "alife_presentation_monstr"
--'		if IsStalker(obj) then
--'			spot = "alife_presentation_"..community
--'		end
--'		local str = obj:name().." "..self:name().."\\n"..path_name

--'		level.map_change_spot_hint(obj.id, spot, str)		
--'	end

	return CALifeSmartTerrainTask( path_name )
end

-- может ли данный гулаг создаться в данный момент?
function se_smart_terrain:is_gulag_available()
	-- если есть специальные условия создания гулага
	if self.gparams.cond then
		-- то используем их
		local bb = xr_logic.pick_section_from_condlist( db.actor_proxy, self, self.gparams.cond ) ~= nil
		self:show_smart_debug_spot(bb)
		return bb
	else -- если специальных условий нет
		self:show_smart_debug_spot(true)
		return true -- то значит всегда можно работать
	end
end

function se_smart_terrain:show_smart_debug_spot(avail)
	if sim_statistic.show_smart_spot == true then
		--' Показать отметку
		local str = self:name().." ("..tostring(self.gulag.state)..")\\n".."pop = "..tostring(self.gulag:get_population()).."("..tostring(self.gulag.capacity_non_exclusive)..":"..tostring(self.gulag.capacity)..") comed = "..tostring(self.gulag:get_population_comed())

		if self.debug_avail ~= avail then
			if self.debug_avail == true then
				level_tasks.remove_location_by_id(self.id, "alife_presentation_smart_on")
			elseif self.debug_avail == false then
				level_tasks.remove_location_by_id(self.id, "alife_presentation_smart_off")
			end
			if avail == true then
				level.map_add_object_spot(self.id, "alife_presentation_smart_on", str)
			else
				level.map_add_object_spot(self.id, "alife_presentation_smart_off", str)
			end
			self.debug_avail = avail
		else
			if avail == true then
				level.map_change_spot_hint(self.id, "alife_presentation_smart_on", str)
			else
				level.map_change_spot_hint(self.id, "alife_presentation_smart_off", str)
			end
		end
		 self.spot_showed = true
	else
		--' Убрать отметку
		if self.spot_showed == nil then
			return
		end
		self.spot_showed = nil
		if self.debug_avail == true then
			level_tasks.remove_location_by_id(self.id, "alife_presentation_smart_on")
		else
			level_tasks.remove_location_by_id(self.id, "alife_presentation_smart_off")
		end		
	end
end

-- в гулаг поступил первый персонаж и он начинает работать
-- название в целом запутывает! Это не создание, а скорее активация гулага
function se_smart_terrain:create_gulag()
	self.check_time = CTime_0

	self.gulag:initialize()

	self.gulag_working = true
end

-- всех освободить, убить гулаг,
-- создать новый нерабочий гулаг, зарезервировать в нём места для эксклюзивных
function se_smart_terrain:remove_gulag( disable )
	-- DEBUG
	self.disabled = disable
	--------

	if not self.gulag_working then
		return
	end

	--log3( "[smart_terrain %s] removed gulag type=%s", self:name(), self.gparams.type )

	-- освободить всех персонажей
	for id, npc_info in pairs( self.npc_info ) do
		self:unregister_npc( npc_info.se_obj )
	end

	self.gulag = xr_gulag.gulag( self, self.gparams.type, self.gparams.squad, self.gparams.groups, self.npc_info, self.gparams.capacity )
	self.gulag:load_jobs()

	self.gulag_working = false

	self.gulag.capacity_non_exclusive = self.gulag.capacity_non_exclusive - self.exclusives
--'	self:show_smart_debug_spot(false)
end

-- заполняет таблицу monster_classes
-- TODO: заменить на глобальный функционал
function se_smart_terrain:fill_monster_classes()
	if not monster_classes then
		monster_classes = {
			[clsid.bloodsucker_s ] = "bloodsucker",
			[clsid.boar_s        ] = "boar",
			[clsid.burer_s       ] = "burer",
			[clsid.cat_s         ] = "cat",
			[clsid.chimera_s     ] = "chimera",
			[clsid.controller_s  ] = "controller",
			[clsid.pseudodog_s   ] = "pseudodog",
			[clsid.psy_dog_s     ] = "psy_dog",
			[clsid.dog_s         ] = "dog",
			[clsid.flesh_s       ] = "flesh",
			[clsid.fracture_s    ] = "fracture",
			[clsid.poltergeist_s ] = "poltergeist",
			[clsid.gigant_s      ] = "pseudo_gigant",
			[clsid.snork_s       ] = "snork",
			[clsid.tushkano_s    ] = "tushkano",
			[clsid.zombie_s      ] = "zombie"
		}
	end
end

-- регистрация объекта в симуляторе.
-- вызывается движком после загрузки/создания объекта.
function se_smart_terrain:on_register()

	cse_alife_smart_zone.on_register( self )

	--TODO: А что будет если это удалить?
	if has_alife_info("pri_stadium_scene_start") and string.find(self:name(), "pri_wave") then
		self:remove_gulag(true)
	end		

	-- проинитить объект
	self:register_if_needed()
	self:initialize_if_needed()
end

function se_smart_terrain:register_if_needed()
	--' Если уже зарегистрены то ничего не делать.
	if self.registred then
		return
	end
	self.registred = true
	
	--log3( "%s register called", self:name() )
	-- DEBUG
	if self.disabled then
		return
	end

	self:fill_monster_classes()

	local level_name = object_level_name(self)

	if not self.gparams.preset_name then
		self.gparams.preset_name = level_name
	end

	if not smart_terrains[level_name] then
		smart_terrains[level_name] = {}
	end

	smart_terrains[level_name][self.id] = self

	if self.gparams.respawn then
		db.strn_by_respawn[self.gparams.respawn] = self
	end

	self.gulag:load_jobs()

	if self.gulag_working then
		self.gulag:initialize()
	end

	sim_statistic.reinit()

	-- Регистрация в таскменеджере
	task_manager.get_random_task():register_target(self)
end



-- дерегистрация объекта в симуляторе.
-- вызывается движком перед удалением объекта (вызывается ли вообще, смарты никто не удаляет)
function se_smart_terrain:on_unregister()
	cse_alife_smart_zone.on_unregister( self )

--	log3( "[smart_terrain %s] on_unregister called", self:name() )

	local lvl_smarts = smart_terrains[object_level_name(self)]

	if lvl_smarts then
		lvl_smarts[self.id] = nil
	end

	if self.gparams and self.gparams.respawn then
		db.strn_by_respawn[self.gparams.respawn] = nil
	end

	db.actor_proxy:deinit() -- ?? вызывается из каждого такого метода
end

-- вызвать спавнер, если настроен.
-- вызывается из gulag:beginJob( obj_id )
function se_smart_terrain:call_respawn()
	if self.gparams.respawn then
		dsh_respawn.spawn( self.gparams.respawn )
	end
end

-- возвращает строку с принимаемыми группировками и рангами
function se_smart_terrain:stat_get_accepted_communities() -- отладочная, только для информации!!
	local comms = {}

	-- from preset
	local ltx         = dsh.cached_ini_file( "misc\\" .. self.gparams.type .. ".ltx" )
	local preset_name = self.gparams.preset_name

	if ltx and ltx:section_exist( preset_name ) then
		local result, field, str
		local n = ltx:line_count( preset_name )

		for i = 0, n-1 do
			result, field, str = ltx:r_line( preset_name, i, "", "" )

			if not self.accepted_communities or self.accepted_communities[field] then
				comms[field] = str
			end
		end
	end

	-- from custom data
	if self.accepted_communities then
		for comm, v in pairs( self.accepted_communities ) do
			if not comms[comm] then
				comms[comm] = "all"
			end
		end
	end

	-- prepare return
	local s = ""

	for comm, ranks in pairs( comms ) do
		s = s .. comm .. "(" .. ranks .. "),"
	end

	return s
end

-- вывод статистики смарта
function se_smart_terrain:stat() -- отладочная, только для информации!!
	local s = object_level_name(self) .. " " .. self:name()

	local pop   = self.gulag:get_population()
	local cap   = self.gulag.capacity

	local avail = self:is_gulag_available()

	if avail then
		s = s .. " enabled "
	else
		s = s .. " disabled "
	end

	s = s .. pop .. " " .. cap .. " " .. self:stat_get_accepted_communities()

	log3( s )

--	for id, npc_info in pairs( self.npc_info ) do
--		log3( "    %s", npc_info.name )
--	end

	return avail, pop, cap
end

-- Обновление.
-- В онлайне вызывается через binder.
-- Также может вызваться принудительно из xr_effects
-- Если мужиков в гулаге больше не осталось или условия существования гулага не выполняются, то убрать гулаг.
function se_smart_terrain:update()
--	log1( "se_smart_terrain::update called!" )
	cse_alife_smart_zone.update( self )

	if not self.gulag_working then
		return
	end

	if self:is_gulag_available() then
		local cur_time = game.get_game_time()
		if self.check_time < cur_time then
			self.check_time = cur_time + check_period

			--' проверять, не собрался ли кто-то к этому времени уже уходить
			for id, npc_info in pairs( self.npc_info ) do
				if npc_info.cond and not xr_logic.pick_section_from_condlist( db.actor_proxy, npc_info.se_obj, npc_info.cond ) then
					--log3("[smart_terrain %s] leaving %s", self:name(), npc_info.name)
					self:unregister_npc( npc_info.se_obj )
				end
			end

			if self.gulag:get_population() == 0 then
				self:remove_gulag()
			else
				self.gulag:update()
			end
		end
	else
		self:remove_gulag()
	end
end

function prot_smt_td(obj)
	if IsStalker(obj) or IsMonster(obj) then
		return obj:smart_terrain_id()
	else	
		return 65535
	end
end

--------------------
-- найти и почистить гулаг объекта
-- вызывается из кучи мест. Скорее всего дубируется многократно
function on_death( obj_id )
--	log3( "on_death obj_id=%d", obj_id )
	local sim = alife()
	if sim then
		local obj = sim:object( obj_id )
		if obj then
			local smrt_id = obj:smart_terrain_id()
			if 65535 ~= smrt_id then
				local smrt = sim:object(smrt_id)
				if smrt and smrt.gulag then
					smrt.gulag:clear_dead(obj_id)
				end
			end
		end
	end
end

-----------------------
--' Удаляет объект из смарттеррейнов.
function unregister_npc(npc)
	local sim = alife()
	
	if sim then
		local obj     = sim:object(npc.id)
		local strn_id = obj:smart_terrain_id()

		if strn_id ~= 65535 then
			if sim:object(strn_id) then
				sim:object(strn_id):unregister_npc(obj)
			end
		end
	end
end



--------------------
-- прочитать секцию [smart_terrains]
-- вызывается объектами, которые могут ходить под smart terrain
-- вызывается из se_monster:fill_exclusives() в файле se_monster и  и se_stalker.se_stalker:fill_exclusives()
--
-- Добавлена поддержка [smart_terrains] в файле логики
-- https://github.com/dsh2dsh/op2ogse/commit/d95b91610c4b346ab7cc08ef17e1c3a7ba9ed9fc
function read_smart_terrain_conditions( self )
  local ini = self.ini
  if ini then
    if
      ( not ini:section_exist( smart_section ) )
      and ini:section_exist( "logic" )
    then
      local cfg = get_string( "logic", "cfg", nil, ini )
      if cfg then
		log3("~~[smart_terrain %s]: Smart section not found in spawn_ini(). Will be used logic file: [%s]", self:name(), cfg)
        ini = dsh.cached_ini_file( cfg )
      end
    end
  end
  if ini and ini:section_exist( smart_section ) then
    local conds   = {}
    local accepts = false
    local n       = ini:line_count( smart_section )
    if n > 0 then
      for i = 0, n - 1 do
        local result, field, str = ini:r_line( smart_section, i, "", "" )
        conds[ field ] = xr_logic.parse_condlist(
          self, smart_section, field, str
        )
      end
	  --log3("~~\n[Smart Terrain] Conditions for %s: %s", self:name(), conds)
      return conds
    end
  end
  --log3("!![smart_terrain %s]: Smart section not found!", self:name())
  return nil
end

--------------------
-- Вывод статистики по всем смартам в симуляции
function stat()
	log1( "--------------- Smart terrains statistics START ----------------------" )

	local jobs, jobs_in_avail, occupied
	local level_stats = {}

	for level_name, t in pairs( smart_terrains ) do
		jobs, jobs_in_avail, occupied = 0, 0, 0

		for id, strn in pairs( t ) do
			local avail, pop, cap = strn:stat()

			jobs       = jobs     + cap
			occupied   = occupied + pop

			if avail then
				jobs_in_avail = jobs_in_avail + cap
			end
		end

		local l = {}
		level_stats[level_name] = l

		l.jobs          = jobs
		l.occupied      = occupied
		l.jobs_in_avail = jobs_in_avail
	end

	jobs, jobs_in_avail, occupied = 0, 0, 0

	log1("")

	for level_name, l in pairs( level_stats ) do
		log3( "Level %s :", level_name )
		log3( "    Jobs in all smart terrains : %d",       l.jobs )
		log3( "    Jobs in available smart terrains : %d", l.jobs_in_avail )
		log3( "    Occupied jobs : %d",                    l.occupied )

		jobs          = jobs          + l.jobs
		jobs_in_avail = jobs_in_avail + l.jobs_in_avail
		occupied      = occupied      + l.occupied
	end

	log3( "All levels:" )
	log3( "    Jobs in all smart terrains : %d",       jobs )
	log3( "    Jobs in available smart terrains : %d", jobs_in_avail )
	log3( "    Occupied jobs : %d",                    occupied )

	log1( "--------------- Smart terrains statistics END ------------------------" )
end
