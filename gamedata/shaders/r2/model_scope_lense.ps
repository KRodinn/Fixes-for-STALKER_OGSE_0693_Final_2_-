#include "common.h"

///////////////////////////
// Глобальные параметры шейдеров --#SM+#--
uniform float4x4	m_script_params; 

//KRodin: закомменчено, т.к. вызывает ошибку  error X3650: 'm_hud_params': global variables cannot use the 'half' type in ps_3_0. To treat this variable as a float, use the backwards compatibility flag.
//uniform	half4		m_hud_params;	// zoom_rotate_factor, secondVP_zoom_factor, NULL, NULL
uniform	float4		m_hud_params;	// zoom_rotate_factor, secondVP_zoom_factor, NULL, NULL

//Тоже самое
//uniform	half4		m_blender_mode;	// x\y = [0 - default, 1 - night vision, 2 - thermal vision]; x - основной вьюпорт, y - второй впьюпорт, z = ?, w = [0 - идёт рендер обычного объекта, 1 - идёт рендер детальных объектов (трава, мусор)]
uniform	float4		m_blender_mode;	// x\y = [0 - default, 1 - night vision, 2 - thermal vision]; x - основной вьюпорт, y - второй впьюпорт, z = ?, w = [0 - идёт рендер обычного объекта, 1 - идёт рендер детальных объектов (трава, мусор)]

///////////////////////////

struct 	v2p
{
 	float2 	tc0: 		TEXCOORD0;	// base
 	half3 	tc1: 		TEXCOORD1;	// environment
  	half4	c0:			COLOR0;		// sun.(fog*fog)
};

//////////////////////////////////////////////////////////////////////////////////////////

float  resize(float input, float factor, float offset)
{
	return (input-0.5f+offset) / factor+0.5f-offset;
}

uniform sampler2D	s_vp2;
uniform sampler2D	s_skymap;

uniform samplerCUBE	s_env0;
uniform samplerCUBE	s_env1;

float random(float2 co)
{
      return 0.5+(frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453))*0.5;
};

half4 	main	( v2p I )	: COLOR
{
	half4	t_base 		= tex2D		(s_base,	I.tc0);		// Текстура сетки
	half4	t_skymap 	= tex2D		(s_skymap,	I.tc0);		// Карта отражения неба
	
	// Растягиваем картинку в линзе так, чтобы на любом разрешении экрана были правильные пропорции
	I.tc0.x = resize(I.tc0.x, ogse_c_resolution.x/ogse_c_resolution.y, 0); //KRodin: заменил на ogse_c_resolution
	half4	t_vp2	 = tex2D		(s_vp2, I.tc0);			// Изображение со второго вьюпорта
	half3	final	 = half3(0, 0, 0);
	
	if (m_blender_mode.x == 1.f)
	{	//** Ночной режим **//
	
		// Рассчитываем случайный шум пикселя
		float noise		= random(I.tc0*timers.z) * 0.3;
		
		// Осветляем картинку в 7 раз
		t_vp2.rgb *= 7;
		
		// Обесцвечиваем пиксель
		float gray = ((t_vp2.r + t_vp2.g + t_vp2.b)/3);
		t_vp2.rgb = half3(gray, gray, gray);
		
		// Добавляем зелёный оттенок
		t_vp2.g += (0.4 + noise);
		
		// Миксуем с сеткой
		final	= lerp	(t_vp2, t_base, t_base.a);
	}
	else
	{	//** Стандартный режим **//
	
		// Текущая и следующая текстура неба
		//half3	env0		= texCUBE	(s_env0, I.tc1);
		//half3	env1		= texCUBE	(s_env1, I.tc1);
		//half3	env			= lerp		(env0, env1, L_ambient.w);	// Их миксовка
		
		// Миксуем всё и собираем финальную картинку
		half3 	base	= lerp	(t_vp2, t_base, t_base.a);		// Сетку с вьюпортом
		//		final	= lerp	(base,  env,    t_skymap.a);	// base c небом
		final	= base;
	}
	
	// out
	return  half4	(final.r, final.g, final.b, m_hud_params.x);
}
